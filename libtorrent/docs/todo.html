<html><head>
<script type="text/javascript">
/* <![CDATA[ */
	var expanded = -1
	function expand(id) {
		if (expanded != -1) {
			var ctx = document.getElementById(expanded);
			ctx.style.display = "none";
			// if we're expanding the field that's already
			// expanded, just collapse it
			var no_expand = id == expanded;
			expanded = -1;
			if (no_expand) return;
		}
		var ctx = document.getElementById(id);
		ctx.style.display = "table-row";
		expanded = id;
	}
/* ]]> */
</script>

</head><body>
<h1>libtorrent todo-list</h1>
<span style="color: #f00">3 urgent</span>
<span style="color: #f77">47 important</span>
<span style="color: #3c3">55 relevant</span>
<span style="color: #77f">4 feasible</span>
<span style="color: #999">172 notes</span>
          <table width="100%" border="1" style="border-collapse: collapse;"><tr style="background: #f44"><td>relevance&nbsp;4</td><td><a href="javascript:expand(0)">../test/test_dht.cpp:1314</a></td><td>pass in the actual salt as a parameter</td></tr><tr id="0" style="display: none;" colspan="3"><td colspan="3"><h2>pass in the actual salt as a parameter</h2><h4>../test/test_dht.cpp:1314</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
	key_desc_t const desc_error[] =
	{
		{ "e", bdecode_node::list_t, 2, 0 },
		{ "y", bdecode_node::string_t, 1, 0},
	};

	bdecode_node desc_error_keys[2];

	// ==== get / put mutable items ===

	span&lt;char const&gt; itemv;

	signature sig;
	char buffer[1200];
	sequence_number seq(4);
	public_key pk;
	secret_key sk;
	get_test_keypair(pk, sk);

<div style="background: #ffff00" width="100%">	for (int with_salt = 0; with_salt &lt; 2; ++with_salt)
</div>	{
		seq = sequence_number(4);
		std::printf("\nTEST GET/PUT%s \ngenerating ed25519 keys\n\n"
			, with_salt ? " with-salt" : " no-salt");
		std::array&lt;char, 32&gt; seed = ed25519_create_seed();

		std::tie(pk, sk) = ed25519_create_keypair(seed);
		std::printf("pub: %s priv: %s\n"
			, aux::to_hex(pk.bytes).c_str()
			, aux::to_hex(sk.bytes).c_str());

		std::string salt;
		if (with_salt) salt = "foobar";

		hasher h(pk.bytes);
		if (with_salt) h.update(salt);
		sha1_hash target_id = h.final();

		std::printf("target_id: %s\n"
			, aux::to_hex(target_id).c_str());

		send_dht_request(t.dht_node, "get", t.source, &amp;response
			, msg_args().target(target_id));

		key_desc_t const desc[] =
		{
			{ "r", bdecode_node::dict_t, 0, key_desc_t::parse_children },
			{ "id", bdecode_node::string_t, 20, 0},
			{ "token", bdecode_node::string_t, 0, 0},
			{ "ip", bdecode_node::string_t, 0, key_desc_t::optional | key_desc_t::last_child},
</pre></td></tr><tr style="background: #f44"><td>relevance&nbsp;4</td><td><a href="javascript:expand(1)">../test/test_dht.cpp:2200</a></td><td>pass in th actual salt as the argument</td></tr><tr id="1" style="display: none;" colspan="3"><td colspan="3"><h2>pass in th actual salt as the argument</h2><h4>../test/test_dht.cpp:2200</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		}
	}
	g_got_peers.clear();
}

} // anonymous namespace

TORRENT_TEST(get_peers_v4)
{
	test_get_peers(rand_v4);
}

TORRENT_TEST(get_peers_v6)
{
	if (supports_ipv6())
		test_get_peers(rand_v6);
}

namespace {

<div style="background: #ffff00" width="100%">void test_mutable_get(address(&amp;rand_addr)(), bool const with_salt)
</div>{
	dht_test_setup t(udp::endpoint(rand_addr(), 20));

	public_key pk;
	secret_key sk;
	get_test_keypair(pk, sk);

	char buffer[1200];
	sequence_number seq(4);
	span&lt;char const&gt; itemv;
	bdecode_node response;

	std::string salt;
	if (with_salt) salt = "foobar";

	// mutable get

	g_sent_packets.clear();

	udp::endpoint const initial_node(rand_addr(), 1234);
	dht::node_id const initial_node_id = to_hash("1111111111222222222233333333334444444444");
	t.dht_node.m_table.add_node(node_entry{initial_node_id, initial_node, 10, true});

	g_put_item.assign(items[0].ent, salt, seq, pk, sk);
	t.dht_node.put_item(pk, std::string()
		, std::bind(&amp;put_mutable_item_cb, _1, _2, 0)
		, put_mutable_item_data_cb);

	TEST_EQUAL(g_sent_packets.size(), 1);

</pre></td></tr><tr style="background: #f44"><td>relevance&nbsp;4</td><td><a href="javascript:expand(2)">../src/disk_io_thread.cpp:1149</a></td><td>instead of doing this. pass in the settings to each storage_interface call. Each disk thread could hold its most recent understanding of the settings in a shared_ptr, and update it every time it wakes up from a job. That way each access to the settings won't require a std::mutex to be held.</td></tr><tr id="2" style="display: none;" colspan="3"><td colspan="3"><h2>instead of doing this. pass in the settings to each storage_interface
call. Each disk thread could hold its most recent understanding of the settings
in a shared_ptr, and update it every time it wakes up from a job. That way
each access to the settings won't require a std::mutex to be held.</h2><h4>../src/disk_io_thread.cpp:1149</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			DLOG("perform_job job: %s ( %s%s) piece: %d offset: %d outstanding: %d\n"
				, job_action_name[j-&gt;action]
				, (j-&gt;flags &amp; disk_io_job::fence) ? "fence ": ""
				, (j-&gt;flags &amp; disk_io_job::force_copy) ? "force_copy ": ""
				, static_cast&lt;int&gt;(j-&gt;piece), j-&gt;d.io.offset
				, j-&gt;storage ? j-&gt;storage-&gt;num_outstanding_jobs() : -1);
		}
#endif

		std::shared_ptr&lt;storage_interface&gt; storage = j-&gt;storage;

#ifdef TORRENT_EXPENSIVE_INVARIANT_CHECKS
		if (j-&gt;storage)
		{
			std::unique_lock&lt;std::mutex&gt; l(m_cache_mutex);
			auto const&amp; pieces = j-&gt;storage-&gt;cached_pieces();
			for (auto const&amp; p : pieces)
				TORRENT_ASSERT(p.storage == j-&gt;storage);
		}
#endif
<div style="background: #ffff00" width="100%">		if (storage &amp;&amp; storage-&gt;m_settings == nullptr)
</div>			storage-&gt;m_settings = &amp;m_settings;

		TORRENT_ASSERT(static_cast&lt;int&gt;(j-&gt;action) &lt; int(job_functions.size()));

		m_stats_counters.inc_stats_counter(counters::num_running_disk_jobs, 1);

		// call disk function
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(3)">../test/test_dht.cpp:111</a></td><td>make the mock_socket hold a reference to the list of where to record packets instead of having a global variable</td></tr><tr id="3" style="display: none;" colspan="3"><td colspan="3"><h2>make the mock_socket hold a reference to the list of where to record
packets instead of having a global variable</h2><h4>../test/test_dht.cpp:111</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">}

void add_and_replace(node_id&amp; dst, node_id const&amp; add)
{
	bool carry = false;
	for (int k = 19; k &gt;= 0; --k)
	{
		int sum = dst[k] + add[k] + (carry ? 1 : 0);
		dst[k] = sum &amp; 255;
		carry = sum &gt; 255;
	}
}

void node_push_back(std::vector&lt;node_entry&gt;* nv, node_entry const&amp; n)
{
	nv-&gt;push_back(n);
}

void nop_node() {}

<div style="background: #ffff00" width="100%">std::list&lt;std::pair&lt;udp::endpoint, entry&gt;&gt; g_sent_packets;
</div>
struct mock_socket final : socket_manager
{
	bool has_quota() override { return true; }
	bool send_packet(aux::listen_socket_handle const&amp;, entry&amp; msg, udp::endpoint const&amp; ep) override
	{
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(4)">../test/test_dht.cpp:120</a></td><td>ideally the mock_socket would contain this queue of packets, to make tests independent</td></tr><tr id="4" style="display: none;" colspan="3"><td colspan="3"><h2>ideally the mock_socket would contain this queue of packets, to
make tests independent</h2><h4>../test/test_dht.cpp:120</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		int sum = dst[k] + add[k] + (carry ? 1 : 0);
		dst[k] = sum &amp; 255;
		carry = sum &gt; 255;
	}
}

void node_push_back(std::vector&lt;node_entry&gt;* nv, node_entry const&amp; n)
{
	nv-&gt;push_back(n);
}

void nop_node() {}

std::list&lt;std::pair&lt;udp::endpoint, entry&gt;&gt; g_sent_packets;

struct mock_socket final : socket_manager
{
	bool has_quota() override { return true; }
	bool send_packet(aux::listen_socket_handle const&amp;, entry&amp; msg, udp::endpoint const&amp; ep) override
	{
<div style="background: #ffff00" width="100%">		g_sent_packets.push_back(std::make_pair(ep, msg));
</div>		return true;
	}
};

std::shared_ptr&lt;aux::listen_socket_t&gt; dummy_listen_socket(udp::endpoint src)
{
	auto ret = std::make_shared&lt;aux::listen_socket_t&gt;();
	ret-&gt;local_endpoint = tcp::endpoint(src.address(), src.port());
	ret-&gt;external_address.cast_vote(src.address()
		, aux::session_interface::source_dht, rand_v4());
	return ret;
}

std::shared_ptr&lt;aux::listen_socket_t&gt; dummy_listen_socket4()
{
	auto ret = std::make_shared&lt;aux::listen_socket_t&gt;();
	ret-&gt;local_endpoint = tcp::endpoint(addr4("192.168.4.1"), 6881);
	ret-&gt;external_address.cast_vote(addr4("236.0.0.1")
		, aux::session_interface::source_dht, rand_v4());
	return ret;
}

std::shared_ptr&lt;aux::listen_socket_t&gt; dummy_listen_socket6()
{
	auto ret = std::make_shared&lt;aux::listen_socket_t&gt;();
	ret-&gt;local_endpoint = tcp::endpoint(addr6("2002::1"), 6881);
	ret-&gt;external_address.cast_vote(addr6("2002::1")
		, aux::session_interface::source_dht, rand_v6());
	return ret;
}
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(5)">../test/test_dht.cpp:1271</a></td><td>split this up into smaller tests</td></tr><tr id="5" style="display: none;" colspan="3"><td colspan="3"><h2>split this up into smaller tests</h2><h4>../test/test_dht.cpp:1271</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	}

	lt::aux::array&lt;node_entry, 9&gt; build_nodes(sha1_hash target)
	{
		return lt::aux::array&lt;node_entry, 9&gt;(
			std::array&lt;node_entry, 9&gt; {
			{ { target, udp::endpoint(addr4("1.1.1.1"), 1231), 10, true}
			, { target, udp::endpoint(addr4("2.2.2.2"), 1232), 10, true}
			, { target, udp::endpoint(addr4("3.3.3.3"), 1233), 10, true}
			, { target, udp::endpoint(addr4("4.4.4.4"), 1234), 10, true}
			, { target, udp::endpoint(addr4("5.5.5.5"), 1235), 10, true}
			, { target, udp::endpoint(addr4("6.6.6.6"), 1236), 10, true}
			, { target, udp::endpoint(addr4("7.7.7.7"), 1237), 10, true}
			, { target, udp::endpoint(addr4("8.8.8.8"), 1238), 10, true}
			, { target, udp::endpoint(addr4("9.9.9.9"), 1239), 10, true} }
		});
	}

span&lt;char const&gt; const empty_salt;

<div style="background: #ffff00" width="100%">void test_put(address(&amp;rand_addr)())
</div>{
	dht_test_setup t(udp::endpoint(rand_addr(), 20));

	bdecode_node response;
	bool ret;

	// ====== put ======

	init_rand_address();
	udp::endpoint eps[1000];
	for (int i = 0; i &lt; 1000; ++i)
		eps[i] = udp::endpoint(rand_addr(), (rand() % 16534) + 1);

	announce_immutable_items(t.dht_node, eps, items, sizeof(items)/sizeof(items[0]));

	key_desc_t const desc2[] =
	{
		{ "y", bdecode_node::string_t, 1, 0 }
	};

	bdecode_node desc2_keys[1];

	key_desc_t const desc_error[] =
	{
		{ "e", bdecode_node::list_t, 2, 0 },
		{ "y", bdecode_node::string_t, 1, 0},
	};

	bdecode_node desc_error_keys[2];

</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(6)">../test/test_dht.cpp:2669</a></td><td>use dht_test_setup class to simplify the node setup</td></tr><tr id="6" style="display: none;" colspan="3"><td colspan="3"><h2>use dht_test_setup class to simplify the node setup</h2><h4>../test/test_dht.cpp:2669</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			args.nodes({nodes[8]});

		send_dht_response(t.dht_node, response, nodes[i].ep(), args);
		g_sent_packets.erase(packet);

		// once we've sent the response from the farthest node, we're done
		if (i == 0) break;
	}

	TEST_EQUAL(g_put_count, 1);
	// k nodes should now have outstanding put requests
	TEST_EQUAL(g_sent_packets.size(), 8);

	g_sent_packets.clear();
	g_put_item.clear();
	g_put_count = 0;
}

TORRENT_TEST(dht_dual_stack)
{
<div style="background: #ffff00" width="100%">	dht::dht_settings sett = test_settings();
</div>	mock_socket s;
	auto sock4 = dummy_listen_socket4();
	auto sock6 = dummy_listen_socket6();
	obs observer;
	counters cnt;
	node* node4p = nullptr, *node6p = nullptr;
	auto get_foreign_node = [&amp;](node_id const&amp;, std::string const&amp; family)
	{
		if (family == "n4") return node4p;
		if (family == "n6") return node6p;
		TEST_CHECK(false);
		return static_cast&lt;node*&gt;(nullptr);
	};
	std::unique_ptr&lt;dht_storage_interface&gt; dht_storage(dht_default_storage_constructor(sett));
	dht_storage-&gt;update_node_ids({node_id(nullptr)});
	dht::node node4(sock4, &amp;s, sett, node_id(nullptr), &amp;observer, cnt, get_foreign_node, *dht_storage);
	dht::node node6(sock6, &amp;s, sett, node_id(nullptr), &amp;observer, cnt, get_foreign_node, *dht_storage);
	node4p = &amp;node4;
	node6p = &amp;node6;

	// DHT should be running on port 48199 now
	bdecode_node response;
	char error_string[200];
	bool ret;

	node_id id = to_hash("3123456789abcdef01232456789abcdef0123456");
	node4.m_table.node_seen(id, udp::endpoint(addr("4.4.4.4"), 4440), 10);
	node6.m_table.node_seen(id, udp::endpoint(addr("4::4"), 4441), 10);

	// v4 node requesting v6 nodes
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(7)">../test/test_dht.cpp:3207</a></td><td>use dht_test_setup class to simplify the node setup</td></tr><tr id="7" style="display: none;" colspan="3"><td colspan="3"><h2>use dht_test_setup class to simplify the node setup</h2><h4>../test/test_dht.cpp:3207</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
	bdecode_node response;
	send_dht_request(t.dht_node, "ping", t.source, &amp;response);

	dht::key_desc_t const pong_desc[] = {
		{ "y", bdecode_node::string_t, 1, 0 },
		{ "t", bdecode_node::string_t, 2, 0 },
		{ "r", bdecode_node::dict_t, 0, key_desc_t::parse_children },
		{ "id", bdecode_node::string_t, 20, key_desc_t::last_child },
	};
	bdecode_node pong_keys[4];
	bool ret = dht::verify_message(response, pong_desc, pong_keys, t.error_string);
	TEST_CHECK(ret);
	if (!ret) return;

	TEST_EQUAL(node_id(pong_keys[3].string_ptr()), t.dht_node.nid());
}

TORRENT_TEST(read_only_node)
{
<div style="background: #ffff00" width="100%">	dht::dht_settings sett = test_settings();
</div>	sett.read_only = true;
	mock_socket s;
	auto ls = dummy_listen_socket4();
	obs observer;
	counters cnt;

	std::unique_ptr&lt;dht_storage_interface&gt; dht_storage(dht_default_storage_constructor(sett));
	dht_storage-&gt;update_node_ids({node_id(nullptr)});
	dht::node node(ls, &amp;s, sett, node_id(nullptr), &amp;observer, cnt, get_foreign_node_stub, *dht_storage);
	udp::endpoint source(addr("10.0.0.1"), 20);
	bdecode_node response;
	msg_args args;

	// for incoming requests, read_only node won't response.
	send_dht_request(node, "ping", source, &amp;response, args, "10", false);
	TEST_EQUAL(response.type(), bdecode_node::none_t);

	args.target(sha1_hash("01010101010101010101"));
	send_dht_request(node, "get", source, &amp;response, args, "10", false);
	TEST_EQUAL(response.type(), bdecode_node::none_t);

	// also, the sender shouldn't be added to routing table.
	TEST_EQUAL(std::get&lt;0&gt;(node.size()), 0);

	// for outgoing requests, read_only node will add 'ro' key (value == 1)
	// in top-level of request.
	bdecode_node parsed[7];
	char error_string[200];
	udp::endpoint initial_node(addr("4.4.4.4"), 1234);
	dht::node_id const initial_node_id = to_hash("1111111111222222222233333333334444444444");
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(8)">../test/test_dht.cpp:3306</a></td><td>use dht_test_setup class to simplify the node setup</td></tr><tr id="8" style="display: none;" colspan="3"><td colspan="3"><h2>use dht_test_setup class to simplify the node setup</h2><h4>../test/test_dht.cpp:3306</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// both of them shouldn't have a 'ro' key.
	lazy_from_entry(g_sent_packets.front().second, request);
	ret = verify_message(request, get_item_desc_ro, parsed, error_string);

	TEST_CHECK(ret);
	TEST_CHECK(!parsed[3]);

	lazy_from_entry(g_sent_packets.back().second, request);
	ret = verify_message(request, get_item_desc_ro, parsed, error_string);

	TEST_CHECK(ret);
	TEST_CHECK(!parsed[3]);
#endif
}

#ifndef TORRENT_DISABLE_LOGGING
// these tests rely on logging being enabled

TORRENT_TEST(invalid_error_msg)
{
<div style="background: #ffff00" width="100%">	dht::dht_settings sett = test_settings();
</div>	mock_socket s;
	auto ls = dummy_listen_socket4();
	obs observer;
	counters cnt;

	std::unique_ptr&lt;dht_storage_interface&gt; dht_storage(dht_default_storage_constructor(sett));
	dht_storage-&gt;update_node_ids({node_id(nullptr)});
	dht::node node(ls, &amp;s, sett, node_id(nullptr), &amp;observer, cnt, get_foreign_node_stub, *dht_storage);
	udp::endpoint source(addr("10.0.0.1"), 20);

	entry e;
	e["y"] = "e";
	e["e"].string() = "Malformed Error";
	char msg_buf[1500];
	int size = bencode(msg_buf, e);

	bdecode_node decoded;
	error_code ec;
	bdecode(msg_buf, msg_buf + size, decoded, ec);
	if (ec) std::printf("bdecode failed: %s\n", ec.message().c_str());

	dht::msg m(decoded, source);
	node.incoming(node.m_sock, m);

	bool found = false;
	for (auto const&amp; log : observer.m_log)
	{
		if (log.find("INCOMING ERROR") != std::string::npos
			&amp;&amp; log.find("(malformed)") != std::string::npos)
			found = true;
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(9)">../test/test_dht.cpp:3394</a></td><td>use dht_test_setup class to simplify the node setup</td></tr><tr id="9" style="display: none;" colspan="3"><td colspan="3"><h2>use dht_test_setup class to simplify the node setup</h2><h4>../test/test_dht.cpp:3394</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// we should have 10 unsorted nodes now
	TEST_CHECK(algo-&gt;num_sorted_results() == 0);
	auto results = algo-&gt;results();
	TEST_CHECK(results.size() == eps.size());
	for (std::size_t i = 0; i &lt; eps.size(); ++i)
		TEST_CHECK(eps[i] == results[i]-&gt;target_ep());

	// setting the node ID, regardless of what we set it to, should cause this
	// observer to become sorted. i.e. be moved to the beginning of the result
	// list.
	results[5]-&gt;set_id(node_id("abababababababababab"));

	TEST_CHECK(algo-&gt;num_sorted_results() == 1);
	results = algo-&gt;results();
	TEST_CHECK(results.size() == eps.size());
	TEST_CHECK(eps[5] == results[0]-&gt;target_ep());
}

TORRENT_TEST(rpc_invalid_error_msg)
{
<div style="background: #ffff00" width="100%">	dht::dht_settings sett = test_settings();
</div>	mock_socket s;
	auto ls = dummy_listen_socket4();
	obs observer;
	counters cnt;

	dht::routing_table table(node_id(), udp::v4(), 8, sett, &amp;observer);
	dht::rpc_manager rpc(node_id(), sett, table, ls, &amp;s, &amp;observer);
	std::unique_ptr&lt;dht_storage_interface&gt; dht_storage(dht_default_storage_constructor(sett));
	dht_storage-&gt;update_node_ids({node_id(nullptr)});
	dht::node node(ls, &amp;s, sett, node_id(nullptr), &amp;observer, cnt, get_foreign_node_stub, *dht_storage);

	udp::endpoint source(addr("10.0.0.1"), 20);

	// we need this to create an entry for this transaction ID, otherwise the
	// incoming message will just be dropped
	entry req;
	req["y"] = "q";
	req["q"] = "bogus_query";
	req["t"] = "\0\0\0\0";

	g_sent_packets.clear();
	auto algo = std::make_shared&lt;dht::traversal_algorithm&gt;(node, node_id());

	auto o = rpc.allocate_observer&lt;null_observer&gt;(std::move(algo), source, node_id());
#if TORRENT_USE_ASSERTS
	o-&gt;m_in_constructor = false;
#endif
	rpc.invoke(req, source, o);

	// here's the incoming (malformed) error message
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(10)">../src/ut_metadata.cpp:269</a></td><td>use the aux::write_* functions and the span here instead, it will fit better with send_buffer()</td></tr><tr id="10" style="display: none;" colspan="3"><td colspan="3"><h2>use the aux::write_* functions and the span here instead, it
will fit better with send_buffer()</h2><h4>../src/ut_metadata.cpp:269</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			int metadata_piece_size = 0;

			if (m_torrent.valid_metadata())
				e["total_size"] = m_tp.get_metadata_size();

			if (type == 1)
			{
				TORRENT_ASSERT(piece &gt;= 0 &amp;&amp; piece &lt; (m_tp.get_metadata_size() + 16 * 1024 - 1) / (16 * 1024));
				TORRENT_ASSERT(m_pc.associated_torrent().lock()-&gt;valid_metadata());
				TORRENT_ASSERT(m_torrent.valid_metadata());

				int const offset = piece * 16 * 1024;
				metadata = m_tp.metadata().data() + offset;
				metadata_piece_size = std::min(
					m_tp.get_metadata_size() - offset, 16 * 1024);
				TORRENT_ASSERT(metadata_piece_size &gt; 0);
				TORRENT_ASSERT(offset &gt;= 0);
				TORRENT_ASSERT(offset + metadata_piece_size &lt;= m_tp.get_metadata_size());
			}

<div style="background: #ffff00" width="100%">			char msg[200];
</div>			char* header = msg;
			char* p = &amp;msg[6];
			int const len = bencode(p, e);
			int const total_size = 2 + len + metadata_piece_size;
			namespace io = detail;
			io::write_uint32(total_size, header);
			io::write_uint8(bt_peer_connection::msg_extended, header);
			io::write_uint8(m_message_index, header);

			m_pc.send_buffer({msg, len + 6});
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(11)">../src/ConvertUTF.cpp:61</a></td><td>replace this implementation with something maintained and/or robust. Perhaps std::codecvt<></td></tr><tr id="11" style="display: none;" colspan="3"><td colspan="3"><h2>replace this implementation with something maintained and/or robust.
Perhaps std::codecvt<></h2><h4>../src/ConvertUTF.cpp:61</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">// ignore warnings in this file
#include "libtorrent/aux_/disable_warnings_push.hpp"

#include "libtorrent/ConvertUTF.h"
#ifdef CVTUTF_DEBUG
#include &lt;stdio.h&gt;
#endif

static const int halfShift  = 10; /* used for shifting by 10 bits */

static const UTF32 halfBase = 0x0010000UL;
static const UTF32 halfMask = 0x3FFUL;

#define UNI_SUR_HIGH_START  (UTF32)0xD800
#define UNI_SUR_HIGH_END    (UTF32)0xDBFF
#define UNI_SUR_LOW_START   (UTF32)0xDC00
#define UNI_SUR_LOW_END     (UTF32)0xDFFF

/* --------------------------------------------------------------------- */

<div style="background: #ffff00" width="100%">
</div>ConversionResult ConvertUTF32toUTF16 (
	const UTF32** sourceStart, const UTF32* sourceEnd,
	UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {
	ConversionResult result = conversionOK;
	const UTF32* source = *sourceStart;
	UTF16* target = *targetStart;
	while (source &lt; sourceEnd) {
	UTF32 ch;
	if (target &gt;= targetEnd) {
		result = targetExhausted; break;
	}
	ch = *source++;
	if (ch &lt;= UNI_MAX_BMP) { /* Target is a character &lt;= 0xFFFF */
		/* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */
		if (ch &gt;= UNI_SUR_HIGH_START &amp;&amp; ch &lt;= UNI_SUR_LOW_END) {
		if (flags == strictConversion) {
			--source; /* return to the illegal value itself */
			result = sourceIllegal;
			break;
		} else {
			*target++ = UNI_REPLACEMENT_CHAR;
		}
		} else {
		*target++ = (UTF16)ch; /* normal case */
		}
	} else if (ch &gt; UNI_MAX_LEGAL_UTF32) {
		if (flags == strictConversion) {
		result = sourceIllegal;
		} else {
		*target++ = UNI_REPLACEMENT_CHAR;
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(12)">../src/session_handle.cpp:621</a></td><td>expose the sequence_number, public_key, secret_key and signature types to the client</td></tr><tr id="12" style="display: none;" colspan="3"><td colspan="3"><h2>expose the sequence_number, public_key, secret_key and signature
types to the client</h2><h4>../src/session_handle.cpp:621</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	void session_handle::dht_get_item(sha1_hash const&amp; target)
	{
#ifndef TORRENT_DISABLE_DHT
		async_call(&amp;session_impl::dht_get_immutable_item, target);
#else
		TORRENT_UNUSED(target);
#endif
	}

	void session_handle::dht_get_item(std::array&lt;char, 32&gt; key
		, std::string salt)
	{
#ifndef TORRENT_DISABLE_DHT
		async_call(&amp;session_impl::dht_get_mutable_item, key, salt);
#else
		TORRENT_UNUSED(key);
		TORRENT_UNUSED(salt);
#endif
	}

<div style="background: #ffff00" width="100%">	sha1_hash session_handle::dht_put_item(entry data)
</div>	{
		std::vector&lt;char&gt; buf;
		bencode(std::back_inserter(buf), data);
		sha1_hash const ret = hasher(buf).final();

#ifndef TORRENT_DISABLE_DHT
		async_call(&amp;session_impl::dht_put_immutable_item, data, ret);
#endif
		return ret;
	}

	void session_handle::dht_put_item(std::array&lt;char, 32&gt; key
		, std::function&lt;void(entry&amp;, std::array&lt;char,64&gt;&amp;
			, std::int64_t&amp;, std::string const&amp;)&gt; cb
		, std::string salt)
	{
#ifndef TORRENT_DISABLE_DHT
		async_call(&amp;session_impl::dht_put_mutable_item, key, cb, salt);
#else
		TORRENT_UNUSED(key);
		TORRENT_UNUSED(cb);
		TORRENT_UNUSED(salt);
#endif
	}

	void session_handle::dht_get_peers(sha1_hash const&amp; info_hash)
	{
#ifndef TORRENT_DISABLE_DHT
		async_call(&amp;session_impl::dht_get_peers, info_hash);
#else
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(13)">../src/peer_connection.cpp:1891</a></td><td>replace this magic number with something that makes sense</td></tr><tr id="13" style="display: none;" colspan="3"><td colspan="3"><h2>replace this magic number with something that makes sense</h2><h4>../src/peer_connection.cpp:1891</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// if this peer is choked, there's no point in sending suggest messages to
		// it. They would just be out-of-date by the time we unchoke the peer
		// anyway.
		if (m_settings.get_int(settings_pack::suggest_mode) == settings_pack::suggest_read_cache
			&amp;&amp; !is_choked()
			&amp;&amp; std::any_of(m_suggest_pieces.begin(), m_suggest_pieces.end()
				, [=](piece_index_t const idx) { return idx == index; }))
		{
			send_piece_suggestions(2);
		}

#ifndef TORRENT_DISABLE_LOGGING
		peer_log(peer_log_alert::incoming_message, "HAVE", "piece: %d"
			, static_cast&lt;int&gt;(index));
#endif

		if (is_disconnecting()) return;

		if (!t-&gt;valid_metadata() &amp;&amp; index &gt;= m_have_piece.end_index())
		{
<div style="background: #ffff00" width="100%">			if (index &lt; piece_index_t(524288))
</div>			{
				// if we don't have metadata
				// and we might not have received a bitfield
				// extend the bitmask to fit the new
				// have message
				m_have_piece.resize(static_cast&lt;int&gt;(index) + 1, false);
			}
			else
			{
				// unless the index &gt; 64k, in which case
				// we just ignore it
				return;
			}
		}

		// if we got an invalid message, abort
		if (index &gt;= m_have_piece.end_index() || index &lt; piece_index_t(0))
		{
#ifndef TORRENT_DISABLE_LOGGING
			peer_log(peer_log_alert::info, "ERROR", "have-metadata have_piece: %d size: %d"
				, static_cast&lt;int&gt;(index), m_have_piece.size());
#endif
			disconnect(errors::invalid_have, operation_t::bittorrent, peer_error);
			return;
		}

		if (t-&gt;super_seeding() &amp;&amp; !m_settings.get_bool(settings_pack::strict_super_seeding))
		{
			// if we're super-seeding and the peer just told
			// us that it completed the piece we're super-seeding
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(14)">../src/peer_connection.cpp:3000</a></td><td>instead of having to ask the torrent whether it's in graceful pause mode or not, the peers should keep that state (and the torrent should update them when it enters graceful pause). When a peer enters graceful pause mode, it should cancel all outstanding requests and clear its request queue.</td></tr><tr id="14" style="display: none;" colspan="3"><td colspan="3"><h2>instead of having to ask the torrent whether it's in graceful
pause mode or not, the peers should keep that state (and the torrent
should update them when it enters graceful pause). When a peer enters
graceful pause mode, it should cancel all outstanding requests and
clear its request queue.</h2><h4>../src/peer_connection.cpp:3000</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// to disk or are in the disk write cache
		if (picker.is_piece_finished(p.piece) &amp;&amp; !was_finished)
		{
#if TORRENT_USE_INVARIANT_CHECKS
			check_postcondition post_checker2_(t, false);
#endif
			t-&gt;verify_piece(p.piece);
		}

		check_graceful_pause();

		if (is_disconnecting()) return;

		if (request_a_block(*t, *this))
			m_counters.inc_stats_counter(counters::incoming_piece_picks);
		send_block_requests();
	}

	void peer_connection::check_graceful_pause()
	{
<div style="background: #ffff00" width="100%">		std::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
</div>		if (!t || !t-&gt;graceful_pause()) return;

		if (m_outstanding_bytes &gt; 0) return;

#ifndef TORRENT_DISABLE_LOGGING
		peer_log(peer_log_alert::info, "GRACEFUL_PAUSE", "NO MORE DOWNLOAD");
#endif
		disconnect(errors::torrent_paused, operation_t::bittorrent);
	}

	void peer_connection::on_disk_write_complete(storage_error const&amp; error
		, peer_request const&amp; p, std::shared_ptr&lt;torrent&gt; t)
	{
		TORRENT_ASSERT(is_single_thread());
#ifndef TORRENT_DISABLE_LOGGING
		if (should_log(peer_log_alert::info))
		{
			peer_log(peer_log_alert::info, "FILE_ASYNC_WRITE_COMPLETE", "piece: %d s: %x l: %x e: %s"
				, static_cast&lt;int&gt;(p.piece), p.start, p.length, error.ec.message().c_str());
		}
#endif

		m_counters.inc_stats_counter(counters::queued_write_bytes, -p.length);
		m_outstanding_writing_bytes -= p.length;

		TORRENT_ASSERT(m_outstanding_writing_bytes &gt;= 0);

		// every peer is entitled to allocate a disk buffer if it has no writes outstanding
		// see the comment in incoming_piece
		if (m_outstanding_writing_bytes == 0
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(15)">../src/peer_connection.cpp:3887</a></td><td>once peers are properly put in graceful pause mode, they can cancel all outstanding requests and this test can be removed.</td></tr><tr id="15" style="display: none;" colspan="3"><td colspan="3"><h2>once peers are properly put in graceful pause mode, they can
cancel all outstanding requests and this test can be removed.</h2><h4>../src/peer_connection.cpp:3887</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			std::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
			TORRENT_ASSERT(t);
			TORRENT_ASSERT(t-&gt;has_piece_passed(piece));
			TORRENT_ASSERT(piece &lt; t-&gt;torrent_file().end_piece());
		}
#endif

		write_suggest(piece);
	}

	void peer_connection::send_block_requests()
	{
		TORRENT_ASSERT(is_single_thread());
		INVARIANT_CHECK;

		std::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
		TORRENT_ASSERT(t);

		if (m_disconnecting) return;

<div style="background: #ffff00" width="100%">		if (t-&gt;graceful_pause()) return;
</div>
		// we can't download pieces in these states
		if (t-&gt;state() == torrent_status::checking_files
			|| t-&gt;state() == torrent_status::checking_resume_data
			|| t-&gt;state() == torrent_status::downloading_metadata
			|| t-&gt;state() == torrent_status::allocating)
			return;

		if (int(m_download_queue.size()) &gt;= m_desired_queue_size
			|| t-&gt;upload_mode()) return;

		bool const empty_download_queue = m_download_queue.empty();

		while (!m_request_queue.empty()
			&amp;&amp; (int(m_download_queue.size()) &lt; m_desired_queue_size
				|| m_queued_time_critical &gt; 0))
		{
			pending_block block = m_request_queue.front();

			m_request_queue.erase(m_request_queue.begin());
			if (m_queued_time_critical) --m_queued_time_critical;

			// if we're a seed, we don't have a piece picker
			// so we don't have to worry about invariants getting
			// out of sync with it
			if (!t-&gt;has_picker()) continue;

			// this can happen if a block times out, is re-requested and
			// then arrives "unexpectedly"
			if (t-&gt;picker().is_downloaded(block.block))
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(16)">../src/peer_connection.cpp:4568</a></td><td>new_piece should be an optional<piece_index_t>. piece index -1 should not be allowed</td></tr><tr id="16" style="display: none;" colspan="3"><td colspan="3"><h2>new_piece should be an optional<piece_index_t>. piece index -1
should not be allowed</h2><h4>../src/peer_connection.cpp:4568</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		{
			p.progress = 0.f;
			p.progress_ppm = 0;
		}
		else
		{
#if TORRENT_NO_FPU
			p.progress = 0.f;
#else
			p.progress = float(p.pieces.count()) / float(p.pieces.size());
#endif
			p.progress_ppm = int(std::int64_t(p.pieces.count()) * 1000000 / p.pieces.size());
		}

		p.estimated_reciprocation_rate = m_est_reciprocation_rate;

		error_code ec;
		p.local_endpoint = get_socket()-&gt;local_endpoint(ec);
	}

<div style="background: #ffff00" width="100%">	void peer_connection::superseed_piece(piece_index_t const replace_piece
</div>		, piece_index_t const new_piece)
	{
		TORRENT_ASSERT(is_single_thread());

		if (is_connecting()) return;
		if (in_handshake()) return;

		if (new_piece == piece_index_t(-1))
		{
			if (m_superseed_piece[0] == piece_index_t(-1)) return;
			m_superseed_piece[0] = piece_index_t(-1);
			m_superseed_piece[1] = piece_index_t(-1);

#ifndef TORRENT_DISABLE_LOGGING
			peer_log(peer_log_alert::info, "SUPER_SEEDING", "ending");
#endif
			std::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
			TORRENT_ASSERT(t);

			// this will either send a full bitfield or
			// a have-all message, effectively terminating
			// super-seeding, since the peer may pick any piece
			write_bitfield();

			return;
		}

		TORRENT_ASSERT(!has_piece(new_piece));

#ifndef TORRENT_DISABLE_LOGGING
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(17)">../src/upnp.cpp:94</a></td><td>bind the broadcast socket. it would probably have to be changed to a vector of interfaces to bind to, since the broadcast socket opens one socket per local interface by default</td></tr><tr id="17" style="display: none;" colspan="3"><td colspan="3"><h2>bind the broadcast socket. it would probably have to be changed to a vector of interfaces to
bind to, since the broadcast socket opens one socket per local
interface by default</h2><h4>../src/upnp.cpp:94</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	{ return {e, upnp_category()}; }

} // upnp_errors namespace

static error_code ignore_error;

upnp::rootdevice::rootdevice() {}
upnp::rootdevice::~rootdevice()
{
	TORRENT_ASSERT(magic == 1337);
#if TORRENT_USE_ASSERTS
	magic = 0;
#endif
}

upnp::rootdevice::rootdevice(rootdevice const&amp;) = default;
upnp::rootdevice&amp; upnp::rootdevice::operator=(rootdevice const&amp;) = default;
upnp::rootdevice::rootdevice(rootdevice&amp;&amp;) = default;
upnp::rootdevice&amp; upnp::rootdevice::operator=(rootdevice&amp;&amp;) = default;

<div style="background: #ffff00" width="100%">upnp::upnp(io_service&amp; ios
</div>	, std::string const&amp; user_agent
	, aux::portmap_callback&amp; cb
	, bool ignore_nonrouters)
	: m_user_agent(user_agent)
	, m_callback(cb)
	, m_retry_count(0)
	, m_io_service(ios)
	, m_resolver(ios)
	, m_socket(udp::endpoint(make_address_v4("239.255.255.250"
		, ignore_error), 1900))
	, m_broadcast_timer(ios)
	, m_refresh_timer(ios)
	, m_map_timer(ios)
	, m_disabled(false)
	, m_closing(false)
	, m_ignore_non_routers(ignore_nonrouters)
	, m_last_if_update(min_time())
{
}

void upnp::start()
{
	TORRENT_ASSERT(is_single_thread());

	error_code ec;
	m_socket.open(std::bind(&amp;upnp::on_reply, self(), _1, _2)
		, m_refresh_timer.get_io_service(), ec);

	m_mappings.reserve(10);
}
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(18)">../src/session_impl.cpp:898</a></td><td>closing the udp sockets here means that the uTP connections cannot be closed gracefully</td></tr><tr id="18" style="display: none;" colspan="3"><td colspan="3"><h2>closing the udp sockets here means that
the uTP connections cannot be closed gracefully</h2><h4>../src/session_impl.cpp:898</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#ifndef TORRENT_DISABLE_LOGGING
		session_log(" aborting all connections (%d)", int(m_connections.size()));
#endif
		// abort all connections
		for (auto i = m_connections.begin(); i != m_connections.end();)
		{
			peer_connection* p = (*i).get();
			++i;
			p-&gt;disconnect(errors::stopping_torrent, operation_t::bittorrent);
		}

		// close the listen sockets
		for (auto const&amp; l : m_listen_sockets)
		{
			if (l-&gt;sock)
			{
				l-&gt;sock-&gt;close(ec);
				TORRENT_ASSERT(!ec);
			}

<div style="background: #ffff00" width="100%">			if (l-&gt;udp_sock)
</div>			{
				l-&gt;udp_sock-&gt;sock.close();
			}
		}

		m_outgoing_sockets.close();

		// we need to give all the sockets an opportunity to actually have their handlers
		// called and cancelled before we continue the shutdown. This is a bit
		// complicated, if there are no "undead" peers, it's safe to resume the
		// shutdown, but if there are, we have to wait for them to be cleared out
		// first. In session_impl::on_tick() we check them periodically. If we're
		// shutting down and we remove the last one, we'll initiate
		// shutdown_stage2 from there.
		if (m_undead_peers.empty())
		{
			m_io_service.post(make_handler([this] { abort_stage2(); }
				, m_abort_handler_storage, *this));
		}
	}

	void session_impl::abort_stage2() noexcept
	{
		m_download_rate.close();
		m_upload_rate.close();

		// it's OK to detach the threads here. The disk_io_thread
		// has an internal counter and won't release the network
		// thread until they're all dead (via m_work).
		m_disk_thread.abort(false);
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(19)">../src/session_impl.cpp:1354</a></td><td>the logic in this if-block should be factored out into a separate function. At least most of it</td></tr><tr id="19" style="display: none;" colspan="3"><td colspan="3"><h2>the logic in this if-block should be factored out into a
separate function. At least most of it</h2><h4>../src/session_impl.cpp:1354</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#ifndef TORRENT_DISABLE_LOGGING
		if (should_log())
		{
			session_log("attempting to open listen socket to: %s on device: %s ssl: %x"
				, print_endpoint(bind_ep).c_str(), lep.device.c_str(), static_cast&lt;int&gt;(lep.ssl));
		}
#endif

		auto ret = std::make_shared&lt;listen_socket_t&gt;();
		ret-&gt;ssl = lep.ssl;
		ret-&gt;original_port = bind_ep.port();
		ret-&gt;incoming = lep.incoming;
		operation_t last_op = operation_t::unknown;
		socket_type_t const sock_type
			= (lep.ssl == transport::ssl)
			? socket_type_t::tcp_ssl
			: socket_type_t::tcp;

		// if we're in force-proxy mode, don't open TCP listen sockets. We cannot
		// accept connections on our local machine in this case.
<div style="background: #ffff00" width="100%">		if (ret-&gt;incoming == duplex::accept_incoming)
</div>		{
			ret-&gt;sock = std::make_shared&lt;tcp::acceptor&gt;(m_io_service);
			ret-&gt;sock-&gt;open(bind_ep.protocol(), ec);
			last_op = operation_t::sock_open;
			if (ec)
			{
#ifndef TORRENT_DISABLE_LOGGING
				if (should_log())
				{
					session_log("failed to open socket: %s"
						, ec.message().c_str());
				}
#endif

				if (m_alerts.should_post&lt;listen_failed_alert&gt;())
					m_alerts.emplace_alert&lt;listen_failed_alert&gt;(lep.device, bind_ep, last_op
						, ec, sock_type);
				return ret;
			}

#ifdef TORRENT_WINDOWS
			{
				// this is best-effort. ignore errors
				error_code err;
				ret-&gt;sock-&gt;set_option(exclusive_address_use(true), err);
#ifndef TORRENT_DISABLE_LOGGING
				if (err &amp;&amp; should_log())
				{
					session_log("failed enable exclusive address use on listen socket: %s"
						, err.message().c_str());
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(20)">../src/session_impl.cpp:1729</a></td><td>only run this once in the caller</td></tr><tr id="20" style="display: none;" colspan="3"><td colspan="3"><h2>only run this once in the caller</h2><h4>../src/session_impl.cpp:1729</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		m_ip_notifier-&gt;async_wait([this] (error_code const&amp; e)
			{ this-&gt;wrap(&amp;session_impl::on_ip_change, e); });
		reopen_network_sockets({});
	}

	void session_impl::interface_to_endpoints(std::string const&amp; device, int const port
		, transport const ssl, duplex const incoming, std::vector&lt;listen_endpoint_t&gt;&amp; eps)
	{
		// First, check to see if it's an IP address
		error_code err;
		address const adr = make_address(device.c_str(), err);
		if (!err)
		{
			eps.emplace_back(adr, port, std::string(), ssl, incoming);
		}
		else
		{
			// this is the case where device names a network device. We need to
			// enumerate all IPs associated with this device

<div style="background: #ffff00" width="100%">			std::vector&lt;ip_interface&gt; const ifs = enum_net_interfaces(m_io_service, err);
</div>			if (err)
			{
#ifndef TORRENT_DISABLE_LOGGING
				if (should_log())
				{
					session_log("failed to enumerate IPs on device: \"%s\": %s"
						, device.c_str(), err.message().c_str());
				}
#endif
				if (m_alerts.should_post&lt;listen_failed_alert&gt;())
				{
					m_alerts.emplace_alert&lt;listen_failed_alert&gt;(device
						, operation_t::enum_if, err
						, socket_type_t::tcp);
				}
				return;
			}

			for (auto const&amp; ipface : ifs)
			{
				// we're looking for a specific interface, and its address
				// (which must be of the same family as the address we're
				// connecting to)
				if (device != ipface.name) continue;
				eps.emplace_back(ipface.interface_address, port, device, ssl, incoming);
			}
		}
	}

	void session_impl::reopen_listen_sockets(bool const map_ports)
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(21)">../src/session_impl.cpp:2407</a></td><td>it would be neat if the utp socket manager would handle ICMP errors too</td></tr><tr id="21" style="display: none;" colspan="3"><td colspan="3"><h2>it would be neat if the utp socket manager would
handle ICMP errors too</h2><h4>../src/session_impl.cpp:2407</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			ssl == transport::ssl ? m_ssl_utp_socket_manager :
#endif
			m_utp_socket_manager;

		auto listen_socket = ls.lock();
		if (listen_socket)
			listen_socket-&gt;incoming_connection = true;

		for (;;)
		{
			aux::array&lt;udp_socket::packet, 50&gt; p;
			error_code err;
			int const num_packets = s-&gt;sock.read(p, err);

			for (int i = 0; i &lt; num_packets; ++i)
			{
				udp_socket::packet&amp; packet = p[i];

				if (packet.error)
				{
<div style="background: #ffff00" width="100%">
</div>#ifndef TORRENT_DISABLE_DHT
					if (m_dht)
						m_dht-&gt;incoming_error(packet.error, packet.from);
#endif

					m_tracker_manager.incoming_error(packet.error, packet.from);
					continue;
				}

				span&lt;char const&gt; const buf = packet.data;

				// give the uTP socket manager first dibs on the packet. Presumably
				// the majority of packets are uTP packets.
				if (!mgr.incoming_packet(socket, packet.from, buf))
				{
					// if it wasn't a uTP packet, try the other users of the UDP
					// socket
					bool handled = false;
#ifndef TORRENT_DISABLE_DHT
					if (m_dht &amp;&amp; buf.size() &gt; 20
						&amp;&amp; buf.front() == 'd'
						&amp;&amp; buf.back() == 'e'
						&amp;&amp; listen_socket)
					{
						handled = m_dht-&gt;incoming_packet(listen_socket, packet.from, buf);
					}
#endif

					if (!handled)
					{
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(22)">../src/session_impl.cpp:3931</a></td><td>it would probably make sense to have a separate list of peers that are eligible for optimistic unchoke, similar to the torrents perhaps this could even iterate over the pool allocators of torrent_peer objects. It could probably be done in a single pass and collect the n best candidates. maybe just a queue of peers would make even more sense, just pick the next peer in the queue for unchoking. It would be O(1).</td></tr><tr id="22" style="display: none;" colspan="3"><td colspan="3"><h2>it would probably make sense to have a separate list of peers
that are eligible for optimistic unchoke, similar to the torrents
perhaps this could even iterate over the pool allocators of
torrent_peer objects. It could probably be done in a single pass and
collect the n best candidates. maybe just a queue of peers would make
even more sense, just pick the next peer in the queue for unchoking. It
would be O(1).</h2><h4>../src/session_impl.cpp:3931</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				{
					return get_ext_priority(l) &lt; get_ext_priority(r);
				}
			}
		};
	}

	void session_impl::recalculate_optimistic_unchoke_slots()
	{
		INVARIANT_CHECK;

		TORRENT_ASSERT(is_single_thread());
		if (m_stats_counters[counters::num_unchoke_slots] == 0) return;

		std::vector&lt;opt_unchoke_candidate&gt; opt_unchoke;

		// collect the currently optimistically unchoked peers here, so we can
		// choke them when we've found new optimistic unchoke candidates.
		std::vector&lt;torrent_peer*&gt; prev_opt_unchoke;

<div style="background: #ffff00" width="100%">		for (auto&amp; i : m_connections)
</div>		{
			peer_connection* p = i.get();
			TORRENT_ASSERT(p);
			torrent_peer* pi = p-&gt;peer_info_struct();
			if (!pi) continue;
			if (pi-&gt;web_seed) continue;

			if (pi-&gt;optimistically_unchoked)
			{
				prev_opt_unchoke.push_back(pi);
			}

			torrent const* t = p-&gt;associated_torrent().lock().get();
			if (!t) continue;

</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(23)">../src/session_impl.cpp:3954</a></td><td>peers should know whether their torrent is paused or not, instead of having to ask it over and over again</td></tr><tr id="23" style="display: none;" colspan="3"><td colspan="3"><h2>peers should know whether their torrent is paused or not,
instead of having to ask it over and over again</h2><h4>../src/session_impl.cpp:3954</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// collect the currently optimistically unchoked peers here, so we can
		// choke them when we've found new optimistic unchoke candidates.
		std::vector&lt;torrent_peer*&gt; prev_opt_unchoke;

		for (auto&amp; i : m_connections)
		{
			peer_connection* p = i.get();
			TORRENT_ASSERT(p);
			torrent_peer* pi = p-&gt;peer_info_struct();
			if (!pi) continue;
			if (pi-&gt;web_seed) continue;

			if (pi-&gt;optimistically_unchoked)
			{
				prev_opt_unchoke.push_back(pi);
			}

			torrent const* t = p-&gt;associated_torrent().lock().get();
			if (!t) continue;

<div style="background: #ffff00" width="100%">			if (t-&gt;is_paused()) continue;
</div>
			if (!p-&gt;is_connecting()
				&amp;&amp; !p-&gt;is_disconnecting()
				&amp;&amp; p-&gt;is_peer_interested()
				&amp;&amp; t-&gt;free_upload_slots()
				&amp;&amp; (p-&gt;is_choked() || pi-&gt;optimistically_unchoked)
				&amp;&amp; !p-&gt;ignore_unchoke_slots()
				&amp;&amp; t-&gt;valid_metadata())
			{
				opt_unchoke.emplace_back(&amp;i);
			}
		}

		// find the peers that has been waiting the longest to be optimistically
		// unchoked

		int num_opt_unchoke = m_settings.get_int(settings_pack::num_optimistic_unchoke_slots);
		int const allowed_unchoke_slots = int(m_stats_counters[counters::num_unchoke_slots]);
		if (num_opt_unchoke == 0) num_opt_unchoke = std::max(1, allowed_unchoke_slots / 5);
		if (num_opt_unchoke &gt; int(opt_unchoke.size())) num_opt_unchoke =
			int(opt_unchoke.size());

		// find the n best optimistic unchoke candidates
		std::partial_sort(opt_unchoke.begin()
			, opt_unchoke.begin() + num_opt_unchoke
			, opt_unchoke.end()
#ifndef TORRENT_DISABLE_EXTENSIONS
			, last_optimistic_unchoke_cmp(m_ses_extensions[plugins_optimistic_unchoke_idx])
#else
			, last_optimistic_unchoke_cmp()
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(24)">../src/session_impl.cpp:4192</a></td><td>there should be a pre-calculated list of all peers eligible for unchoking</td></tr><tr id="24" style="display: none;" colspan="3"><td colspan="3"><h2>there should be a pre-calculated list of all peers eligible for
unchoking</h2><h4>../src/session_impl.cpp:4192</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			// there are no more torrents that want peers
			if (want_peers_download.empty() &amp;&amp; want_peers_finished.empty()) break;
			// if we have gone a whole loop without
			// handing out a single connection, break
			if (steps_since_last_connect &gt; num_torrents + 1) break;
			// maintain the global limit on number of connections
			if (num_connections() &gt;= m_settings.get_int(settings_pack::connections_limit)) break;
		}
	}

	void session_impl::recalculate_unchoke_slots()
	{
		TORRENT_ASSERT(is_single_thread());

		time_point const now = aux::time_now();
		time_duration const unchoke_interval = now - m_last_choke;
		m_last_choke = now;

		// build list of all peers that are
		// unchokable.
<div style="background: #ffff00" width="100%">		std::vector&lt;peer_connection*&gt; peers;
</div>		for (auto i = m_connections.begin(); i != m_connections.end();)
		{
			std::shared_ptr&lt;peer_connection&gt; p = *i;
			TORRENT_ASSERT(p);
			++i;
			torrent* const t = p-&gt;associated_torrent().lock().get();
			torrent_peer* const pi = p-&gt;peer_info_struct();

			if (p-&gt;ignore_unchoke_slots() || t == nullptr || pi == nullptr
				|| pi-&gt;web_seed || t-&gt;is_paused())
			{
				p-&gt;reset_choke_counters();
				continue;
			}

			if (!p-&gt;is_peer_interested()
				|| p-&gt;is_disconnecting()
				|| p-&gt;is_connecting())
			{
				// this peer is not unchokable. So, if it's unchoked
				// already, make sure to choke it.
				if (p-&gt;is_choked())
				{
					p-&gt;reset_choke_counters();
					continue;
				}
				if (pi &amp;&amp; pi-&gt;optimistically_unchoked)
				{
					m_stats_counters.inc_stats_counter(counters::num_peers_up_unchoked_optimistic, -1);
					pi-&gt;optimistically_unchoked = false;
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(25)">../src/session_impl.cpp:4729</a></td><td>perhaps params could be moved into the torrent object, instead of it being copied by the torrent constructor</td></tr><tr id="25" style="display: none;" colspan="3"><td colspan="3"><h2>perhaps params could be moved into the torrent object, instead
of it being copied by the torrent constructor</h2><h4>../src/session_impl.cpp:4729</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		for (auto&amp; e : m_ses_extensions[plugins_all_idx])
		{
			std::shared_ptr&lt;torrent_plugin&gt; tp(e-&gt;new_torrent(
				torrent_ptr-&gt;get_handle(), userdata));
			if (tp) torrent_ptr-&gt;add_extension(std::move(tp));
		}
	}
#endif

	torrent_handle session_impl::add_torrent(add_torrent_params&amp;&amp; params
		, error_code&amp; ec)
	{
		// params is updated by add_torrent_impl()
		std::shared_ptr&lt;torrent&gt; torrent_ptr;

		// in case there's an error, make sure to abort the torrent before leaving
		// the scope
		auto abort_torrent = aux::scope_end([&amp;]{ if (torrent_ptr) torrent_ptr-&gt;abort(); });

		bool added;
<div style="background: #ffff00" width="100%">		std::tie(torrent_ptr, added) = add_torrent_impl(params, ec);
</div>
		torrent_handle const handle(torrent_ptr);
		m_alerts.emplace_alert&lt;add_torrent_alert&gt;(handle, params, ec);

		if (!torrent_ptr) return handle;

		// params.info_hash should have been initialized by add_torrent_impl()
		TORRENT_ASSERT(params.info_hash != sha1_hash(nullptr));

#ifndef TORRENT_DISABLE_DHT
		if (params.ti)
		{
			for (auto const&amp; n : params.ti-&gt;nodes())
				add_dht_node_name(n);
		}
#endif

#if TORRENT_ABI_VERSION == 1
		if (m_alerts.should_post&lt;torrent_added_alert&gt;())
			m_alerts.emplace_alert&lt;torrent_added_alert&gt;(handle);
#endif

		// if this was an existing torrent, we can't start it again, or add
		// another set of plugins etc. we're done
		if (!added)
		{
			abort_torrent.disarm();
			return handle;
		}

</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(26)">../src/session_impl.cpp:5961</a></td><td>use public_key here instead of std::array</td></tr><tr id="26" style="display: none;" colspan="3"><td colspan="3"><h2>use public_key here instead of std::array</h2><h4>../src/session_impl.cpp:5961</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
	void session_impl::dht_get_immutable_item(sha1_hash const&amp; target)
	{
		if (!m_dht) return;
		m_dht-&gt;get_item(target, std::bind(&amp;session_impl::get_immutable_callback
			, this, target, _1));
	}

	// callback for dht_mutable_get
	void session_impl::get_mutable_callback(dht::item const&amp; i
		, bool const authoritative)
	{
		TORRENT_ASSERT(i.is_mutable());
		m_alerts.emplace_alert&lt;dht_mutable_item_alert&gt;(i.pk().bytes
			, i.sig().bytes, i.seq().value
			, i.salt(), i.value(), authoritative);
	}

	// key is a 32-byte binary string, the public key to look up.
	// the salt is optional
<div style="background: #ffff00" width="100%">	void session_impl::dht_get_mutable_item(std::array&lt;char, 32&gt; key
</div>		, std::string salt)
	{
		if (!m_dht) return;
		m_dht-&gt;get_item(dht::public_key(key.data()), std::bind(&amp;session_impl::get_mutable_callback
			, this, _1, _2), std::move(salt));
	}

	namespace {

		void on_dht_put_immutable_item(alert_manager&amp; alerts, sha1_hash target, int num)
		{
			if (alerts.should_post&lt;dht_put_alert&gt;())
				alerts.emplace_alert&lt;dht_put_alert&gt;(target, num);
		}

		void on_dht_put_mutable_item(alert_manager&amp; alerts, dht::item const&amp; i, int num)
		{
			if (alerts.should_post&lt;dht_put_alert&gt;())
			{
				dht::signature const sig = i.sig();
				dht::public_key const pk = i.pk();
				dht::sequence_number const seq = i.seq();
				std::string salt = i.salt();
				alerts.emplace_alert&lt;dht_put_alert&gt;(pk.bytes, sig.bytes
					, std::move(salt), seq.value, num);
			}
		}

		void put_mutable_callback(dht::item&amp; i
			, std::function&lt;void(entry&amp;, std::array&lt;char, 64&gt;&amp;
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(27)">../src/torrent.cpp:230</a></td><td>we could probably get away with just saving a few fields here</td></tr><tr id="27" style="display: none;" colspan="3"><td colspan="3"><h2>we could probably get away with just saving a few fields here</h2><h4>../src/torrent.cpp:230</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(28)">../src/torrent.cpp:799</a></td><td>assert there are no outstanding async operations on this torrent</td></tr><tr id="28" style="display: none;" colspan="3"><td colspan="3"><h2>assert there are no outstanding async operations on this
torrent</h2><h4>../src/torrent.cpp:799</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// deprecated in 1.2
		// if we don't have the metadata, and we're waiting
		// for a web server to serve it to us, no need to announce
		// because the info-hash is just the URL hash
		if (!m_torrent_file-&gt;is_valid() &amp;&amp; !m_url.empty()) return false;
#endif

		// don't announce private torrents
		if (m_torrent_file-&gt;is_valid() &amp;&amp; m_torrent_file-&gt;priv()) return false;
		if (m_trackers.empty()) return true;
		if (!settings().get_bool(settings_pack::use_dht_as_fallback)) return true;

		return std::none_of(m_trackers.begin(), m_trackers.end()
			, [](announce_entry const&amp; tr) { return bool(tr.verified); });
	}

#endif

	torrent::~torrent()
	{
<div style="background: #ffff00" width="100%">
</div>#if TORRENT_USE_ASSERTS
		for (torrent_list_index_t i{}; i != m_links.end_index(); ++i)
		{
			if (!m_links[i].in_list()) continue;
			m_links[i].unlink(m_ses.torrent_list(i), i);
		}
#endif

		// The invariant can't be maintained here, since the torrent
		// is being destructed, all weak references to it have been
		// reset, which means that all its peers already have an
		// invalidated torrent pointer (so it cannot be verified to be correct)

		// i.e. the invariant can only be maintained if all connections have
		// been closed by the time the torrent is destructed. And they are
		// supposed to be closed. So we can still do the invariant check.

		// however, the torrent object may be destructed from the main
		// thread when shutting down, if the disk cache has references to it.
		// this means that the invariant check that this is called from the
		// network thread cannot be maintained

		TORRENT_ASSERT(m_peer_class == peer_class_t{0});
		TORRENT_ASSERT(m_connections.empty());
		// just in case, make sure the session accounting is kept right
		for (auto p : m_connections)
			m_ses.close_connection(p);
	}

	void torrent::read_piece(piece_index_t const piece)
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(29)">../src/torrent.cpp:1301</a></td><td>there's some duplication between this function and peer_connection::incoming_piece(). is there a way to merge something?</td></tr><tr id="29" style="display: none;" colspan="3"><td colspan="3"><h2>there's some duplication between this function and
peer_connection::incoming_piece(). is there a way to merge something?</h2><h4>../src/torrent.cpp:1301</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		piece_refcount(piece_picker&amp; p, piece_index_t piece)
			: m_picker(p)
			, m_piece(piece)
		{
			m_picker.inc_refcount(m_piece, nullptr);
		}

		piece_refcount(piece_refcount const&amp;) = delete;
		piece_refcount&amp; operator=(piece_refcount const&amp;) = delete;

		~piece_refcount()
		{
			m_picker.dec_refcount(m_piece, nullptr);
		}

	private:
		piece_picker&amp; m_picker;
		piece_index_t m_piece;
	};

<div style="background: #ffff00" width="100%">	void torrent::add_piece(piece_index_t const piece, char const* data
</div>		, add_piece_flags_t const flags)
	{
		TORRENT_ASSERT(is_single_thread());
		int const piece_size = m_torrent_file-&gt;piece_size(piece);
		int const blocks_in_piece = (piece_size + block_size() - 1) / block_size();

		if (m_deleted) return;

		// avoid crash trying to access the picker when there is none
		if (m_have_all &amp;&amp; !has_picker()) return;

		need_picker();

		if (picker().have_piece(piece)
			&amp;&amp; !(flags &amp; torrent_handle::overwrite_existing))
			return;

		peer_request p;
		p.piece = piece;
		p.start = 0;
		piece_refcount refcount{picker(), piece};
		for (int i = 0; i &lt; blocks_in_piece; ++i, p.start += block_size())
		{
			piece_block const block(piece, i);
			if (!(flags &amp; torrent_handle::overwrite_existing)
				&amp;&amp; picker().is_finished(block))
				continue;

			p.length = std::min(piece_size - p.start, block_size());

</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(30)">../src/torrent.cpp:3580</a></td><td>this could probably be pulled out into a free function</td></tr><tr id="30" style="display: none;" colspan="3"><td colspan="3"><h2>this could probably be pulled out into a free function</h2><h4>../src/torrent.cpp:3580</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	{
		// it's an impossible combination to have 0 pieces, but still have one of them be the last piece
		TORRENT_ASSERT(!(pc.num_pieces == 0 &amp;&amp; pc.last_piece == true));

		// if we have 0 pieces, we can't have any pad blocks either
		TORRENT_ASSERT(!(pc.num_pieces == 0 &amp;&amp; pc.pad_blocks &gt; 0));

		// if we have all pieces, we must also have the last one
		TORRENT_ASSERT(!(pc.num_pieces == fs.num_pieces() &amp;&amp; pc.last_piece == false));
		int const block_size = std::min(default_block_size, fs.piece_length());

		// every block should not be a pad block
		TORRENT_ASSERT(pc.pad_blocks &lt;= std::int64_t(pc.num_pieces) * fs.piece_length() / block_size);

		return std::int64_t(pc.num_pieces) * fs.piece_length()
			- (pc.last_piece ? fs.piece_length() - fs.piece_size(fs.last_piece()) : 0)
			- std::int64_t(pc.pad_blocks) * block_size;
	}

	// fills in total_wanted, total_wanted_done and total_done
<div style="background: #ffff00" width="100%">	void torrent::bytes_done(torrent_status&amp; st, status_flags_t const flags) const
</div>	{
		INVARIANT_CHECK;

		st.total_done = 0;
		st.total_wanted_done = 0;
		st.total_wanted = m_torrent_file-&gt;total_size();

		TORRENT_ASSERT(st.total_wanted &gt;= m_padding_blocks * default_block_size);
		TORRENT_ASSERT(st.total_wanted &gt;= 0);

		TORRENT_ASSERT(!valid_metadata() || m_torrent_file-&gt;num_pieces() &gt; 0);
		if (!valid_metadata()) return;

		TORRENT_ASSERT(st.total_wanted &gt;= std::int64_t(m_torrent_file-&gt;piece_length())
			* (m_torrent_file-&gt;num_pieces() - 1));

		// if any piece hash fails, we'll be taken out of seed mode
		// and m_seed_mode will be false
		if (m_seed_mode || is_seed())
		{
			st.total_done = m_torrent_file-&gt;total_size()
				- m_padding_blocks * default_block_size;
			st.total_wanted_done = st.total_done;
			st.total_wanted = st.total_done;
			return;
		}
		else if (!has_picker())
		{
			st.total_done = 0;
			st.total_wanted_done = 0;
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(31)">../src/torrent.cpp:4316</a></td><td>should this alert have an error code in it?</td></tr><tr id="31" style="display: none;" colspan="3"><td colspan="3"><h2>should this alert have an error code in it?</h2><h4>../src/torrent.cpp:4316</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		on_remove_peers();
		TORRENT_ASSERT(m_connections.empty());

		// post a message to the main thread to destruct
		// the torrent object from there
		if (m_storage)
		{
			try {
				m_ses.disk_thread().async_stop_torrent(m_storage
					, std::bind(&amp;torrent::on_torrent_aborted, shared_from_this()));
			}
			catch (std::exception const&amp; e)
			{
				TORRENT_UNUSED(e);
				m_storage.reset();
#ifndef TORRENT_DISABLE_LOGGING
				debug_log("Failed to flush disk cache: %s", e.what());
#endif
				// clients may rely on this alert to be posted, so it's probably a
				// good idea to post it here, even though we failed
<div style="background: #ffff00" width="100%">				if (alerts().should_post&lt;cache_flushed_alert&gt;())
</div>					alerts().emplace_alert&lt;cache_flushed_alert&gt;(get_handle());
			}
		}
		else
		{
			if (alerts().should_post&lt;cache_flushed_alert&gt;())
				alerts().emplace_alert&lt;cache_flushed_alert&gt;(get_handle());
		}

</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(32)">../src/torrent.cpp:4382</a></td><td>this should return optional<>. piece index -1 should not be allowed</td></tr><tr id="32" style="display: none;" colspan="3"><td colspan="3"><h2>this should return optional<>. piece index -1 should not be
allowed</h2><h4>../src/torrent.cpp:4382</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		m_num_connecting_seeds = 0;
	}

	void torrent::set_super_seeding(bool on)
	{
		if (on == m_super_seeding) return;

		m_super_seeding = on;
		set_need_save_resume();
		state_updated();

		if (m_super_seeding) return;

		// disable super seeding for all peers
		for (auto pc : *this)
		{
			pc-&gt;superseed_piece(piece_index_t(-1), piece_index_t(-1));
		}
	}

<div style="background: #ffff00" width="100%">	piece_index_t torrent::get_piece_to_super_seed(typed_bitfield&lt;piece_index_t&gt; const&amp; bits)
</div>	{
		// return a piece with low availability that is not in
		// the bitfield and that is not currently being super
		// seeded by any peer
		TORRENT_ASSERT(m_super_seeding);

		// do a linear search from the first piece
		int min_availability = 9999;
		std::vector&lt;piece_index_t&gt; avail_vec;
		for (auto const i : m_torrent_file-&gt;piece_range())
		{
			if (bits[i]) continue;

			int availability = 0;
			for (auto pc : *this)
			{
				if (pc-&gt;super_seeded_piece(i))
				{
					// avoid super-seeding the same piece to more than one
					// peer if we can avoid it. Do this by artificially
					// increase the availability
					availability = 999;
					break;
				}
				if (pc-&gt;has_piece(i)) ++availability;
			}
			if (availability &gt; min_availability) continue;
			if (availability == min_availability)
			{
				avail_vec.push_back(i);
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(33)">../src/path.cpp:328</a></td><td>find out what error code is reported when the filesystem does not support hard links.</td></tr><tr id="33" style="display: none;" colspan="3"><td colspan="3"><h2>find out what error code is reported when the filesystem
does not support hard links.</h2><h4>../src/path.cpp:328</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		int ret = ::mkdir(n.c_str(), S_IRWXU | S_IRWXG | S_IRWXO);
		if (ret &lt; 0 &amp;&amp; errno != EEXIST)
			ec.assign(errno, system_category());
#endif
	}

	void hard_link(std::string const&amp; file, std::string const&amp; link
		, error_code&amp; ec)
	{
		native_path_string n_exist = convert_to_native_path_string(file);
		native_path_string n_link = convert_to_native_path_string(link);
#ifdef TORRENT_WINDOWS

		BOOL ret = CreateHardLinkW(n_link.c_str(), n_exist.c_str(), nullptr);
		if (ret)
		{
			ec.clear();
			return;
		}
		// something failed. Does the filesystem not support hard links?
<div style="background: #ffff00" width="100%">		DWORD const error = GetLastError();
</div>		if (error != ERROR_NOT_SUPPORTED &amp;&amp; error != ERROR_ACCESS_DENIED)
		{
			// it's possible CreateHardLink will copy the file internally too,
			// if the filesystem does not support it.
			ec.assign(GetLastError(), system_category());
			return;
		}

		// fall back to making a copy

#else
		// assume posix's link() function exists
		int ret = ::link(n_exist.c_str(), n_link.c_str());

		if (ret == 0)
		{
			ec.clear();
			return;
		}

		// most errors are passed through, except for the ones that indicate that
		// hard links are not supported and require a copy.
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(34)">../src/web_peer_connection.cpp:168</a></td><td>this should be an optional<piece_index_t>, piece index -1 should not be allowed</td></tr><tr id="34" style="display: none;" colspan="3"><td colspan="3"><h2>this should be an optional<piece_index_t>, piece index -1 should
not be allowed</h2><h4>../src/web_peer_connection.cpp:168</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// it's important to include pieces that may overlap many files, as long
		// as we have all those files, so instead of starting with a clear bitfield
		// and setting the pieces corresponding to files we have, we do it the
		// other way around. Start with assuming we have all files, and clear
		// pieces overlapping with files we *don't* have.
		typed_bitfield&lt;piece_index_t&gt; have;
		file_storage const&amp; fs = t-&gt;torrent_file().files();
		have.resize(fs.num_pieces(), true);
		for (auto const i : fs.file_range())
		{
			// if we have the file, no need to do anything
			if (m_web-&gt;have_files.get_bit(i) || fs.pad_file_at(i)) continue;

			auto const range = aux::file_piece_range_inclusive(fs, i);
			for (piece_index_t k = std::get&lt;0&gt;(range); k &lt; std::get&lt;1&gt;(range); ++k)
				have.clear_bit(k);
		}
		incoming_bitfield(have);
	}

<div style="background: #ffff00" width="100%">	if (m_web-&gt;restart_request.piece != piece_index_t(-1))
</div>	{
		// increase the chances of requesting the block
		// we have partial data for already, to finish it
		incoming_suggest(m_web-&gt;restart_request.piece);
	}
	web_connection_base::on_connected();
}

void web_peer_connection::disconnect(error_code const&amp; ec
	, operation_t op, disconnect_severity_t const error)
{
	if (is_disconnecting()) return;

	if (op == operation_t::sock_write &amp;&amp; ec == boost::system::errc::broken_pipe)
	{
#ifndef TORRENT_DISABLE_LOGGING
		// a write operation failed with broken-pipe. This typically happens
		// with HTTP 1.0 servers that close their incoming channel of the TCP
		// stream whenever they're done reading one full request. Instead of
		// us bailing out and failing the entire request just because our
		// write-end was closed, ignore it and keep reading until the read-end
		// also is closed.
		peer_log(peer_log_alert::info, "WRITE_DIRECTION", "CLOSED");
#endif

		// prevent the peer from trying to send anything more
		m_send_buffer.clear();

		// when the web server closed our write-end of the socket (i.e. its
		// read-end), if it's an HTTP 1.0 server. we will stop sending more
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(35)">../src/web_peer_connection.cpp:359</a></td><td>do we really need a special case here? wouldn't the multi-file case handle single file torrents correctly too?</td></tr><tr id="35" style="display: none;" colspan="3"><td colspan="3"><h2>do we really need a special case here? wouldn't the multi-file
case handle single file torrents correctly too?</h2><h4>../src/web_peer_connection.cpp:359</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			m_web-&gt;restart_request.piece = piece_index_t(-1);
		}

#if 0
			std::cerr &lt;&lt; this &lt;&lt; " REQ: p: " &lt;&lt; pr.piece &lt;&lt; " " &lt;&lt; pr.start &lt;&lt; std::endl;
#endif
		size -= pr.length;
	}

	bool const single_file_request = t-&gt;torrent_file().num_files() == 1;
	int const proxy_type = m_settings.get_int(settings_pack::proxy_type);
	bool const using_proxy = (proxy_type == settings_pack::http
		|| proxy_type == settings_pack::http_pw) &amp;&amp; !m_ssl;

	// the number of pad files that have been "requested". In case we _only_
	// request padfiles, we can't rely on handling them in the on_receive()
	// callback (because we won't receive anything), instead we have to post a
	// pretend read callback where we can deliver the zeroes for the partfile
	int num_pad_files = 0;

<div style="background: #ffff00" width="100%">	if (single_file_request)
</div>	{
		file_request_t file_req;
		file_req.file_index = file_index_t(0);
		file_req.start = std::int64_t(static_cast&lt;int&gt;(req.piece)) * info.piece_length()
			+ req.start;
		file_req.length = req.length;

		request += "GET ";
		// do not encode single file paths, they are
		// assumed to be encoded in the torrent file
		request += using_proxy ? m_url : m_path;
		request += " HTTP/1.1\r\n";
		add_headers(request, m_settings, using_proxy);
		request += "\r\nRange: bytes=";
		request += to_string(file_req.start).data();
		request += "-";
		request += to_string(file_req.start + file_req.length - 1).data();
		request += "\r\n\r\n";
		m_first_request = false;

		m_file_requests.push_back(file_req);
	}
	else
	{
		std::vector&lt;file_slice&gt; files = info.orig_files().map_block(req.piece, req.start
			, req.length);

		for (auto const &amp;f : files)
		{
			file_request_t file_req;
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(36)">../src/web_peer_connection.cpp:447</a></td><td>file_index_t should not allow negative values</td></tr><tr id="36" style="display: none;" colspan="3"><td colspan="3"><h2>file_index_t should not allow negative values</h2><h4>../src/web_peer_connection.cpp:447</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">					// with the correct slashes. Don't encode it again
					request += m_path;
				}

				request += escape_file_path(info.orig_files(), f.file_index);
			}
			request += " HTTP/1.1\r\n";
			add_headers(request, m_settings, using_proxy);
			request += "\r\nRange: bytes=";
			request += to_string(f.offset).data();
			request += "-";
			request += to_string(f.offset + f.size - 1).data();
			request += "\r\n\r\n";
			m_first_request = false;

#if 0
			std::cerr &lt;&lt; this &lt;&lt; " SEND-REQUEST: f: " &lt;&lt; f.file_index
				&lt;&lt; " s: " &lt;&lt; f.offset
				&lt;&lt; " e: " &lt;&lt; (f.offset + f.size - 1) &lt;&lt; std::endl;
#endif
<div style="background: #ffff00" width="100%">			TORRENT_ASSERT(f.file_index &gt;= file_index_t(0));
</div>
			m_file_requests.push_back(file_req);
		}
	}

	if (num_pad_files == int(m_file_requests.size()))
	{
		get_io_service().post(std::bind(
			&amp;web_peer_connection::on_receive_padfile,
			std::static_pointer_cast&lt;web_peer_connection&gt;(self())));
		return;
	}

#ifndef TORRENT_DISABLE_LOGGING
	peer_log(peer_log_alert::outgoing_message, "REQUEST", "%s", request.c_str());
#endif

	send_buffer(request, message_type_request);
}

namespace {

	std::string get_peer_name(http_parser const&amp; p, std::string const&amp; host)
	{
		std::string ret = "URL seed @ ";
		ret += host;

		std::string const&amp; server_version = p.header("server");
		if (!server_version.empty())
		{
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(37)">../src/web_peer_connection.cpp:627</a></td><td>this could be made more efficient for the case when we use an HTTP proxy. Then we wouldn't need to add new web seeds to the torrent, we could just make the redirect table contain full URLs.</td></tr><tr id="37" style="display: none;" colspan="3"><td colspan="3"><h2>this could be made more efficient for the case when we use an
HTTP proxy. Then we wouldn't need to add new web seeds to the torrent,
we could just make the redirect table contain full URLs.</h2><h4>../src/web_peer_connection.cpp:627</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// we should not try this server again.
		t-&gt;remove_web_seed_conn(this, errors::missing_location, operation_t::bittorrent, peer_error);
		m_web = nullptr;
		TORRENT_ASSERT(is_disconnecting());
		return;
	}

	bool const single_file_request = !m_path.empty()
		&amp;&amp; m_path[m_path.size() - 1] != '/';

	// add the redirected url and remove the current one
	if (!single_file_request)
	{
		TORRENT_ASSERT(!m_file_requests.empty());
		file_index_t const file_index = m_file_requests.front().file_index;

		location = resolve_redirect_location(m_url, location);
#ifndef TORRENT_DISABLE_LOGGING
		peer_log(peer_log_alert::info, "LOCATION", "%s", location.c_str());
#endif
<div style="background: #ffff00" width="100%">		std::string redirect_base;
</div>		std::string redirect_path;
		error_code ec;
		std::tie(redirect_base, redirect_path) = split_url(location, ec);

		if (ec)
		{
			// we should not try this server again.
			disconnect(errors::missing_location, operation_t::bittorrent, failure);
			return;
		}

		// add_web_seed won't add duplicates. If we have already added an entry
		// with this URL, we'll get back the existing entry

		// "ephemeral" flag should be set to avoid "web_seed_t" saving in resume data.
		// E.g. original "web_seed_t" request url points to "http://example1.com/file1" and
		// web server responses with redirect location "http://example2.com/subpath/file2".
		// "handle_redirect" process this location to create new "web_seed_t"
		// with base url=="http://example2.com/" and redirects[0]=="/subpath/file2").
		// If we try to load resume with such "web_seed_t" then "web_peer_connection" will send
		// request with wrong path "http://example2.com/file1" (cause "redirects" map is not serialized in resume)
		web_seed_t* web = t-&gt;add_web_seed(redirect_base, web_seed_entry::url_seed
			, m_external_auth, m_extra_headers, torrent::ephemeral);
		web-&gt;have_files.resize(t-&gt;torrent_file().num_files(), false);

		// the new web seed we're adding only has this file for now
		// we may add more files later
		web-&gt;redirects[file_index] = redirect_path;
		if (web-&gt;have_files.get_bit(file_index) == false)
		{
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(38)">../src/kademlia/rpc_manager.cpp:65</a></td><td>move this into it's own .cpp file</td></tr><tr id="38" style="display: none;" colspan="3"><td colspan="3"><h2>move this into it's own .cpp file</h2><h4>../src/kademlia/rpc_manager.cpp:65</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#include &lt;libtorrent/kademlia/get_item.hpp&gt;
#include &lt;libtorrent/kademlia/sample_infohashes.hpp&gt;
#include &lt;libtorrent/kademlia/dht_settings.hpp&gt;

#include &lt;libtorrent/socket_io.hpp&gt; // for print_endpoint
#include &lt;libtorrent/aux_/time.hpp&gt; // for aux::time_now
#include &lt;libtorrent/aux_/aligned_union.hpp&gt;
#include &lt;libtorrent/broadcast_socket.hpp&gt; // for is_v6

#include &lt;type_traits&gt;
#include &lt;functional&gt;

#ifndef TORRENT_DISABLE_LOGGING
#include &lt;cinttypes&gt; // for PRId64 et.al.
#endif

using namespace std::placeholders;

namespace libtorrent { namespace dht {

<div style="background: #ffff00" width="100%">
</div>constexpr observer_flags_t observer::flag_queried;
constexpr observer_flags_t observer::flag_initial;
constexpr observer_flags_t observer::flag_no_id;
constexpr observer_flags_t observer::flag_short_timeout;
constexpr observer_flags_t observer::flag_failed;
constexpr observer_flags_t observer::flag_ipv6_address;
constexpr observer_flags_t observer::flag_alive;
constexpr observer_flags_t observer::flag_done;

dht_observer* observer::get_observer() const
{
	return m_algorithm-&gt;get_node().observer();
}

void observer::set_target(udp::endpoint const&amp; ep)
{
	m_sent = clock_type::now();

	m_port = ep.port();
	if (is_v6(ep))
	{
		flags |= flag_ipv6_address;
		m_addr.v6 = ep.address().to_v6().to_bytes();
	}
	else
	{
		flags &amp;= ~flag_ipv6_address;
		m_addr.v4 = ep.address().to_v4().to_bytes();
	}
}
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(39)">../include/libtorrent/utf8.hpp:79</a></td><td>take a string_view here</td></tr><tr id="39" style="display: none;" colspan="3"><td colspan="3"><h2>take a string_view here</h2><h4>../include/libtorrent/utf8.hpp:79</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
			// source sequence is illegal/malformed
			source_illegal
		};

		// hidden
		TORRENT_EXPORT error_code make_error_code(error_code_enum e);
	}

	TORRENT_EXPORT boost::system::error_category const&amp; utf8_category();

	// ``utf8_wchar`` converts a UTF-8 string (``utf8``) to a wide character
	// string (``wide``). ``wchar_utf8`` converts a wide character string
	// (``wide``) to a UTF-8 string (``utf8``). The return value is one of
	// the enumeration values from utf8_conv_result_t.
	TORRENT_EXTRA_EXPORT std::wstring utf8_wchar(string_view utf8, error_code&amp; ec);
	TORRENT_EXTRA_EXPORT std::wstring utf8_wchar(string_view utf8);
	TORRENT_EXTRA_EXPORT std::string wchar_utf8(wstring_view wide, error_code&amp; ec);
	TORRENT_EXTRA_EXPORT std::string wchar_utf8(wstring_view wide);

<div style="background: #ffff00" width="100%">	TORRENT_EXTRA_EXPORT std::pair&lt;std::int32_t, int&gt;
</div>		parse_utf8_codepoint(string_view str);
}

#endif
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(40)">../include/libtorrent/enum_net.hpp:112</a></td><td>use string_view for device_name</td></tr><tr id="40" style="display: none;" colspan="3"><td colspan="3"><h2>use string_view for device_name</h2><h4>../include/libtorrent/enum_net.hpp:112</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// returns true if the specified address is on the same
	// local network as us
	TORRENT_EXTRA_EXPORT bool in_local_network(io_service&amp; ios, address const&amp; addr
		, error_code&amp; ec);
	TORRENT_EXTRA_EXPORT bool in_local_network(std::vector&lt;ip_interface&gt; const&amp; net
		, address const&amp; addr);

	TORRENT_EXTRA_EXPORT boost::optional&lt;ip_route&gt; get_default_route(io_service&amp; ios
		, string_view device, bool v6, error_code&amp; ec);

	// returns the first default gateway found if device is empty
	TORRENT_EXTRA_EXPORT address get_default_gateway(io_service&amp; ios
		, string_view device, bool v6, error_code&amp; ec);

	// attempt to bind socket to the device with the specified name. For systems
	// that don't support SO_BINDTODEVICE the socket will be bound to one of the
	// IP addresses of the specified device. In this case it is necessary to
	// verify the local endpoint of the socket once the connection is established.
	// the returned address is the ip the socket was bound to (or address_v4::any()
	// in case SO_BINDTODEVICE succeeded and we don't need to verify it).
<div style="background: #ffff00" width="100%">	template &lt;class Socket&gt;
</div>	address bind_socket_to_device(io_service&amp; ios, Socket&amp; sock
		, tcp const&amp; protocol
		, char const* device_name, int port, error_code&amp; ec)
	{
		tcp::endpoint bind_ep(address_v4::any(), std::uint16_t(port));

		address ip = make_address(device_name, ec);
		if (!ec)
		{
			// this is to cover the case where "0.0.0.0" is considered any IPv4 or
			// IPv6 address. If we're asking to be bound to an IPv6 address and
			// providing 0.0.0.0 as the device, turn it into "::"
			if (ip == address_v4::any() &amp;&amp; protocol == boost::asio::ip::tcp::v6())
				ip = address_v6::any();
			bind_ep.address(ip);
			// it appears to be an IP. Just bind to that address
			sock.bind(bind_ep, ec);
			return bind_ep.address();
		}

		ec.clear();

#if TORRENT_HAS_BINDTODEVICE
		// try to use SO_BINDTODEVICE here, if that exists. If it fails,
		// fall back to the mechanism we have below
		sock.set_option(aux::bind_to_device(device_name), ec);
		if (ec)
#endif
		{
			ec.clear();
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(41)">../include/libtorrent/stat.hpp:255</a></td><td>everything but payload counters and rates could probably be removed from here</td></tr><tr id="41" style="display: none;" colspan="3"><td colspan="3"><h2>everything but payload counters and rates could probably be
removed from here</h2><h4>../include/libtorrent/stat.hpp:255</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// peer_connection is opened and have some previous
		// transfers from earlier connections.
		void add_stat(std::int64_t downloaded, std::int64_t uploaded)
		{
			m_stat[download_payload].offset(downloaded);
			m_stat[upload_payload].offset(uploaded);
		}

		int last_payload_downloaded() const
		{ return m_stat[download_payload].counter(); }
		int last_payload_uploaded() const
		{ return m_stat[upload_payload].counter(); }
		int last_protocol_downloaded() const
		{ return m_stat[download_protocol].counter(); }
		int last_protocol_uploaded() const
		{ return m_stat[upload_protocol].counter(); }

		// these are the channels we keep stats for
		enum
		{
<div style="background: #ffff00" width="100%">			upload_payload,
</div>			upload_protocol,
			download_payload,
			download_protocol,
			upload_ip_protocol,
			download_ip_protocol,
			num_channels
		};

		void clear()
		{
			for (int i = 0; i &lt; num_channels; ++i)
				m_stat[i].clear();
		}

		stat_channel const&amp; operator[](int i) const
		{
			TORRENT_ASSERT(i &gt;= 0 &amp;&amp; i &lt; num_channels);
			return m_stat[i];
		}

	private:

		stat_channel m_stat[num_channels];
	};

}

#endif // TORRENT_STAT_HPP_INCLUDED
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(42)">../include/libtorrent/torrent_handle.hpp:481</a></td><td>unify url_seed and http_seed with just web_seed, using the web_seed_entry.</td></tr><tr id="42" style="display: none;" colspan="3"><td colspan="3"><h2>unify url_seed and http_seed with just web_seed, using the
web_seed_entry.</h2><h4>../include/libtorrent/torrent_handle.hpp:481</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// announce url for the tracker as well as an int ``tier``, which is
		// specifies the order in which this tracker is tried. If you want
		// libtorrent to use another list of trackers for this torrent, you can
		// use ``replace_trackers()`` which takes a list of the same form as the
		// one returned from ``trackers()`` and will replace it. If you want an
		// immediate effect, you have to call force_reannounce(). See
		// announce_entry.
		//
		// ``add_tracker()`` will look if the specified tracker is already in the
		// set. If it is, it doesn't do anything. If it's not in the current set
		// of trackers, it will insert it in the tier specified in the
		// announce_entry.
		//
		// The updated set of trackers will be saved in the resume data, and when
		// a torrent is started with resume data, the trackers from the resume
		// data will replace the original ones.
		std::vector&lt;announce_entry&gt; trackers() const;
		void replace_trackers(std::vector&lt;announce_entry&gt; const&amp;) const;
		void add_tracker(announce_entry const&amp;) const;

<div style="background: #ffff00" width="100%">
</div>		// ``add_url_seed()`` adds another url to the torrent's list of url
		// seeds. If the given url already exists in that list, the call has no
		// effect. The torrent will connect to the server and try to download
		// pieces from it, unless it's paused, queued, checking or seeding.
		// ``remove_url_seed()`` removes the given url if it exists already.
		// ``url_seeds()`` return a set of the url seeds currently in this
		// torrent. Note that URLs that fails may be removed automatically from
		// the list.
		//
		// See http-seeding_ for more information.
		void add_url_seed(std::string const&amp; url) const;
		void remove_url_seed(std::string const&amp; url) const;
		std::set&lt;std::string&gt; url_seeds() const;

		// These functions are identical as the ``*_url_seed()`` variants, but
		// they operate on `BEP 17`_ web seeds instead of `BEP 19`_.
		//
		// See http-seeding_ for more information.
		void add_http_seed(std::string const&amp; url) const;
		void remove_http_seed(std::string const&amp; url) const;
		std::set&lt;std::string&gt; http_seeds() const;

		// add the specified extension to this torrent. The ``ext`` argument is
		// a function that will be called from within libtorrent's context
		// passing in the internal torrent object and the specified userdata
		// pointer. The function is expected to return a shared pointer to
		// a torrent_plugin instance.
		void add_extension(
			std::function&lt;std::shared_ptr&lt;torrent_plugin&gt;(torrent_handle const&amp;, void*)&gt; const&amp; ext
			, void* userdata = nullptr);
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(43)">../include/libtorrent/tracker_manager.hpp:384</a></td><td>make sure the udp_socket supports passing on string-hostnames too, and that this function is used</td></tr><tr id="43" style="display: none;" colspan="3"><td colspan="3"><h2>make sure the udp_socket supports passing on string-hostnames
too, and that this function is used</h2><h4>../include/libtorrent/tracker_manager.hpp:384</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		void queue_request(
			io_service&amp; ios
			, tracker_request const&amp; r
			, std::weak_ptr&lt;request_callback&gt; c
				= std::weak_ptr&lt;request_callback&gt;()) = delete;
		void abort_all_requests(bool all = false);

		void remove_request(http_tracker_connection const* c);
		void remove_request(udp_tracker_connection const* c);
		bool empty() const;
		int num_requests() const;

		void sent_bytes(int bytes);
		void received_bytes(int bytes);

		void incoming_error(error_code const&amp; ec, udp::endpoint const&amp; ep);
		bool incoming_packet(udp::endpoint const&amp; ep, span&lt;char const&gt; buf);

		// this is only used for SOCKS packets, since
		// they may be addressed to hostname
<div style="background: #ffff00" width="100%">		bool incoming_packet(char const* hostname, span&lt;char const&gt; buf);
</div>
		void update_transaction_id(
			std::shared_ptr&lt;udp_tracker_connection&gt; c
			, std::uint32_t tid);

		aux::session_settings const&amp; settings() const { return m_settings; }
		resolver_interface&amp; host_resolver() { return m_host_resolver; }

		void send_hostname(aux::listen_socket_handle const&amp; sock
			, char const* hostname, int port, span&lt;char const&gt; p
			, error_code&amp; ec, udp_send_flags_t flags = {});

		void send(aux::listen_socket_handle const&amp; sock
			, udp::endpoint const&amp; ep, span&lt;char const&gt; p
			, error_code&amp; ec, udp_send_flags_t flags = {});

	private:

		// maps transactionid to the udp_tracker_connection
		// These must use shared_ptr to avoid a dangling reference
		// if a connection is erased while a timeout event is in the queue
		std::unordered_map&lt;std::uint32_t, std::shared_ptr&lt;udp_tracker_connection&gt;&gt; m_udp_conns;

		std::vector&lt;std::shared_ptr&lt;http_tracker_connection&gt;&gt; m_http_conns;

		send_fun_t m_send_fun;
		send_fun_hostname_t m_send_fun_hostname;
		resolver_interface&amp; m_host_resolver;
		aux::session_settings const&amp; m_settings;
		counters&amp; m_stats_counters;
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(44)">../include/libtorrent/pe_crypto.hpp:71</a></td><td>dh_key_exchange should probably move into its own file</td></tr><tr id="44" style="display: none;" colspan="3"><td colspan="3"><h2>dh_key_exchange should probably move into its own file</h2><h4>../include/libtorrent/pe_crypto.hpp:71</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
#include &lt;list&gt;
#include &lt;array&gt;
#include &lt;cstdint&gt;

namespace libtorrent {

	namespace mp = boost::multiprecision;

	using key_t = mp::number&lt;mp::cpp_int_backend&lt;768, 768, mp::unsigned_magnitude, mp::unchecked, void&gt;&gt;;

	TORRENT_EXTRA_EXPORT std::array&lt;char, 96&gt; export_key(key_t const&amp; k);

	// RC4 state from libtomcrypt
	struct rc4 {
		int x;
		int y;
		aux::array&lt;std::uint8_t, 256&gt; buf;
	};

<div style="background: #ffff00" width="100%">	class TORRENT_EXTRA_EXPORT dh_key_exchange
</div>	{
	public:
		dh_key_exchange();
		bool good() const { return true; }

		// Get local public key
		key_t const&amp; get_local_key() const { return m_dh_local_key; }

		// read remote_pubkey, generate and store shared secret in
		// m_dh_shared_secret.
		void compute_secret(std::uint8_t const* remote_pubkey);
		void compute_secret(key_t const&amp; remote_pubkey);

		key_t const&amp; get_secret() const { return m_dh_shared_secret; }

		sha1_hash const&amp; get_hash_xor_mask() const { return m_xor_mask; }

	private:

		key_t m_dh_local_key;
		key_t m_dh_local_secret;
		key_t m_dh_shared_secret;
		sha1_hash m_xor_mask;
	};

	struct TORRENT_EXTRA_EXPORT encryption_handler
	{
		std::tuple&lt;int, span&lt;span&lt;char const&gt;&gt;&gt;
		encrypt(span&lt;span&lt;char&gt;&gt; iovec);

</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(45)">../include/libtorrent/torrent.hpp:1317</a></td><td>factor out predictive pieces and all operations on it into a separate class (to use as memeber here instead)</td></tr><tr id="45" style="display: none;" colspan="3"><td colspan="3"><h2>factor out predictive pieces and all operations on it into a
separate class (to use as memeber here instead)</h2><h4>../include/libtorrent/torrent.hpp:1317</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// the torrent file
		std::string m_url;

		// if this was added from an RSS feed, this is the unique
		// identifier in the feed.
		std::string m_uuid;

		// if this torrent was added by an RSS feed, this is the
		// URL to that feed
		std::string m_source_feed_url;
#endif

		// this is a list of all pieces that we have announced
		// as having, without actually having yet. If we receive
		// a request for a piece in this list, we need to hold off
		// on responding until we have completed the piece and
		// verified its hash. If the hash fails, send reject to
		// peers with outstanding requests, and dont_have to other
		// peers. This vector is ordered, to make lookups fast.

<div style="background: #ffff00" width="100%">		std::vector&lt;piece_index_t&gt; m_predictive_pieces;
</div>
		// the performance counters of this session
		counters&amp; m_stats_counters;

		// each bit represents a piece. a set bit means
		// the piece has had its hash verified. This
		// is only used in seed mode (when m_seed_mode
		// is true)
		typed_bitfield&lt;piece_index_t&gt; m_verified;

		// this means there is an outstanding, async, operation
		// to verify each piece that has a 1
		typed_bitfield&lt;piece_index_t&gt; m_verifying;

		// set if there's an error on this torrent
		error_code m_error;

		// used if there is any resume data. Some of the information from the
		// add_torrent_params struct are needed later in the torrent object's life
		// cycle, and not in the constructor. So we need to save if away here
		std::unique_ptr&lt;add_torrent_params&gt; m_add_torrent_params;

		// if the torrent is started without metadata, it may
		// still be given a name until the metadata is received
		// once the metadata is received this field will no
		// longer be used and will be reset
		std::unique_ptr&lt;std::string&gt; m_name;

		storage_constructor_type m_storage_constructor;

</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(46)">../include/libtorrent/torrent.hpp:1375</a></td><td>factor out the links (as well as update_list() to a separate class that torrent can inherit)</td></tr><tr id="46" style="display: none;" colspan="3"><td colspan="3"><h2>factor out the links (as well as update_list() to a separate
class that torrent can inherit)</h2><h4>../include/libtorrent/torrent.hpp:1375</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// this was the last time _we_ saw a seed in this swarm
		std::time_t m_last_seen_complete = 0;

		// this is the time last any of our peers saw a seed
		// in this swarm
		std::time_t m_swarm_last_seen_complete = 0;

		// keep a copy if the info-hash here, so it can be accessed from multiple
		// threads, and be cheap to access from the client
		sha1_hash m_info_hash;

	public:
		// these are the lists this torrent belongs to. For more
		// details about each list, see session_impl.hpp. Each list
		// represents a group this torrent belongs to and makes it
		// efficient to enumerate only torrents belonging to a specific
		// group. Such as torrents that want peer connections or want
		// to be ticked etc.

<div style="background: #ffff00" width="100%">		aux::array&lt;link, aux::session_interface::num_torrent_lists, torrent_list_index_t&gt;
</div>			m_links;

	private:

		// m_num_verified = m_verified.count()
		std::uint32_t m_num_verified = 0;

		// if this torrent is running, this was the time
		// when it was started. This is used to have a
		// bias towards keeping seeding torrents that
		// recently was started, to avoid oscillation
		// this is specified at a second granularity
		// in session-time. see session_impl for details.
		// the reference point is stepped forward every 4
		// hours to keep the timestamps fit in 16 bits
		time_point32 m_started = aux::time_now32();

		// if we're a seed, this is the session time
		// timestamp of when we became one
		time_point32 m_became_seed = aux::time_now32();

		// if we're finished, this is the session time
		// timestamp of when we finished
		time_point32 m_became_finished = aux::time_now32();

		// when checking, this is the first piece we have not
		// issued a hash job for
		piece_index_t m_checking_piece{0};

		// the number of pieces we completed the check of
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(47)">../include/libtorrent/web_peer_connection.hpp:117</a></td><td>if we make this be a disk_buffer_holder instead we would save a copy use allocate_disk_receive_buffer and release_disk_receive_buffer</td></tr><tr id="47" style="display: none;" colspan="3"><td colspan="3"><h2>if we make this be a disk_buffer_holder instead
we would save a copy
use allocate_disk_receive_buffer and release_disk_receive_buffer</h2><h4>../include/libtorrent/web_peer_connection.hpp:117</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		piece_block_progress downloading_piece_progress() const override;

		void handle_padfile();

		// this has one entry per http-request
		// (might be more than the bt requests)
		struct file_request_t
		{
			file_index_t file_index;
			int length;
			std::int64_t start;
		};
		std::deque&lt;file_request_t&gt; m_file_requests;

		std::string m_url;

		web_seed_t* m_web;

		// this is used for intermediate storage of pieces to be delivered to the
		// bittorrent engine
<div style="background: #ffff00" width="100%">		aux::vector&lt;char&gt; m_piece;
</div>
		// the number of bytes we've forwarded to the incoming_payload() function
		// in the current HTTP response. used to know where in the buffer the
		// next response starts
		int m_received_body;

		// this is the offset inside the current receive
		// buffer where the next chunk header will be.
		// this is updated for each chunk header that's
		// parsed. It does not necessarily point to a valid
		// offset in the receive buffer, if we haven't received
		// it yet. This offset never includes the HTTP header
		int m_chunk_pos;

		// this is the number of bytes we've already received
		// from the next chunk header we're waiting for
		int m_partial_chunk_header;

		// the number of responses we've received so far on
		// this connection
		int m_num_responses;
	};
}

#endif // TORRENT_WEB_PEER_CONNECTION_HPP_INCLUDED
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(48)">../include/libtorrent/kademlia/routing_table.hpp:121</a></td><td>to improve memory locality and scanning performance, turn the routing table into a single vector with boundaries for the nodes instead. Perhaps replacement nodes should be in a separate vector.</td></tr><tr id="48" style="display: none;" colspan="3"><td colspan="3"><h2>to improve memory locality and scanning performance, turn the
routing table into a single vector with boundaries for the nodes instead.
Perhaps replacement nodes should be in a separate vector.</h2><h4>../include/libtorrent/kademlia/routing_table.hpp:121</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// entries for a single IP when restrict_routing_ips is set to false
	std::unordered_multiset&lt;address_v4::bytes_type, ipv4_hash&gt; m_ip4s;
	std::unordered_multiset&lt;address_v6::bytes_type, ipv6_hash&gt; m_ip6s;
};

// differences in the implementation from the description in
// the paper:
//
// * Nodes are not marked as being stale, they keep a counter
// 	that tells how many times in a row they have failed. When
// 	a new node is to be inserted, the node that has failed
// 	the most times is replaced. If none of the nodes in the
// 	bucket has failed, then it is put in the replacement
// 	cache (just like in the paper).

TORRENT_EXTRA_EXPORT bool compare_ip_cidr(address const&amp; lhs, address const&amp; rhs);

class TORRENT_EXTRA_EXPORT routing_table
{
public:
<div style="background: #ffff00" width="100%">	using table_t = aux::vector&lt;routing_table_node&gt;;
</div>
	routing_table(node_id const&amp; id, udp proto
		, int bucket_size
		, dht_settings const&amp; settings
		, dht_logger* log);

	routing_table(routing_table const&amp;) = delete;
	routing_table&amp; operator=(routing_table const&amp;) = delete;

#if TORRENT_ABI_VERSION == 1
	void status(session_status&amp; s) const;
#endif

	void status(std::vector&lt;dht_routing_bucket&gt;&amp; s) const;

	void node_failed(node_id const&amp; id, udp::endpoint const&amp; ep);

	// adds an endpoint that will never be added to
	// the routing table
	void add_router_node(udp::endpoint const&amp; router);

	// iterates over the router nodes added
	using router_iterator = std::set&lt;udp::endpoint&gt;::const_iterator;
	router_iterator begin() const { return m_router_nodes.begin(); }
	router_iterator end() const { return m_router_nodes.end(); }

	enum add_node_status_t {
		failed_to_add = 0,
		node_added,
		need_bucket_split
</pre></td></tr><tr style="background: #fcc"><td>relevance&nbsp;3</td><td><a href="javascript:expand(49)">../include/libtorrent/aux_/storage_utils.hpp:52</a></td><td>remove this typedef, and use span<char const> for disk write operations</td></tr><tr id="49" style="display: none;" colspan="3"><td colspan="3"><h2>remove this typedef, and use span<char const> for disk write
operations</h2><h4>../include/libtorrent/aux_/storage_utils.hpp:52</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
#ifndef TORRENT_STORAGE_UTILS_HPP_INCLUDE
#define TORRENT_STORAGE_UTILS_HPP_INCLUDE

#include &lt;cstdint&gt;
#include &lt;string&gt;

#include "libtorrent/config.hpp"
#include "libtorrent/fwd.hpp"
#include "libtorrent/span.hpp"
#include "libtorrent/span.hpp"
#include "libtorrent/units.hpp"
#include "libtorrent/storage_defs.hpp" // for status_t
#include "libtorrent/session_types.hpp"

namespace libtorrent {

	struct part_file;
	struct stat_cache;

<div style="background: #ffff00" width="100%">	using iovec_t = span&lt;char&gt;;
</div>
namespace aux {

	TORRENT_EXTRA_EXPORT int copy_bufs(span&lt;iovec_t const&gt; bufs
		, int bytes, span&lt;iovec_t&gt; target);
	TORRENT_EXTRA_EXPORT span&lt;iovec_t&gt; advance_bufs(span&lt;iovec_t&gt; bufs, int bytes);
	TORRENT_EXTRA_EXPORT void clear_bufs(span&lt;iovec_t const&gt; bufs);

	// this is a read or write operation so that readwritev() knows
	// what to do when it's actually touching the file
	using fileop = std::function&lt;int(file_index_t, std::int64_t, span&lt;iovec_t const&gt;, storage_error&amp;)&gt;;

	// this function is responsible for turning read and write operations in the
	// torrent space (pieces) into read and write operations in the filesystem
	// space (files on disk).
	TORRENT_EXTRA_EXPORT int readwritev(file_storage const&amp; files
		, span&lt;iovec_t const&gt; bufs, piece_index_t piece, int offset
		, storage_error&amp; ec, fileop op);

	// moves the files in file_storage f from ``save_path`` to
	// ``destination_save_path`` according to the rules defined by ``flags``.
	// returns the status code and the new save_path.
	TORRENT_EXTRA_EXPORT std::pair&lt;status_t, std::string&gt;
	move_storage(file_storage const&amp; f
		, std::string const&amp; save_path
		, std::string const&amp; destination_save_path
		, part_file* pf
		, move_flags_t flags, storage_error&amp; ec);

	// deletes the files on fs from save_path according to options. Options may
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(50)">../test/test_piece_picker.cpp:2149</a></td><td>test picking with partial pieces and other peers present so that both backup_pieces and backup_pieces2 are used</td></tr><tr id="50" style="display: none;" colspan="3"><td colspan="3"><h2>test picking with partial pieces and other peers present so that both
backup_pieces and backup_pieces2 are used</h2><h4>../test/test_piece_picker.cpp:2149</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(51)">../test/test_storage.cpp:533</a></td><td>split this test up into smaller parts</td></tr><tr id="51" style="display: none;" colspan="3"><td colspan="3"><h2>split this test up into smaller parts</h2><h4>../test/test_storage.cpp:533</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	aux::vector&lt;std::string, file_index_t&gt; links;
	io.async_check_files(st, &amp;frd, links
		, std::bind(&amp;on_check_resume_data, _1, _2, &amp;done));
	io.submit_jobs();
	ios.reset();
	run_until(ios, done);

	for (auto const i : info-&gt;piece_range())
	{
		done = false;
		io.async_hash(st, i, disk_interface::sequential_access | disk_interface::volatile_read
			, std::bind(&amp;on_piece_checked, _1, _2, _3, &amp;done));
		io.submit_jobs();
		ios.reset();
		run_until(ios, done);
	}

	io.abort(true);
}

<div style="background: #ffff00" width="100%">void run_test(bool unbuffered)
</div>{
	std::string test_path = current_working_directory();
	std::cout &lt;&lt; "\n=== " &lt;&lt; test_path &lt;&lt; " ===\n" &lt;&lt; std::endl;

	std::shared_ptr&lt;torrent_info&gt; info;

	std::vector&lt;char&gt; piece0 = new_piece(piece_size);
	std::vector&lt;char&gt; piece1 = new_piece(piece_size);
	std::vector&lt;char&gt; piece2 = new_piece(piece_size);
	std::vector&lt;char&gt; piece3 = new_piece(piece_size);

	{
	error_code ec;
	remove_all(combine_path(test_path, "temp_storage"), ec);
	if (ec &amp;&amp; ec != boost::system::errc::no_such_file_or_directory)
		std::cout &lt;&lt; "remove_all '" &lt;&lt; combine_path(test_path, "temp_storage")
		&lt;&lt; "': " &lt;&lt; ec.message() &lt;&lt; std::endl;
	file_storage fs;
	fs.add_file("temp_storage/test1.tmp", 17);
	fs.add_file("temp_storage/test2.tmp", 612);
	fs.add_file("temp_storage/test3.tmp", 0);
	fs.add_file("temp_storage/test4.tmp", 0);
	fs.add_file("temp_storage/test5.tmp", 3253);
	fs.add_file("temp_storage/test6.tmp", 841);
	int const last_file_size = 4 * int(piece_size) - int(fs.total_size());
	fs.add_file("temp_storage/test7.tmp", last_file_size);

	// File layout
	// +-+--+++-------+-------+----------------------------------------------------------------------------------------+
	// |1| 2||| file5 | file6 | file7                                                                                  |
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(52)">../test/test_dht.cpp:1702</a></td><td>test num_global_nodes</td></tr><tr id="52" style="display: none;" colspan="3"><td colspan="3"><h2>test num_global_nodes</h2><h4>../test/test_dht.cpp:1702</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(53)">../test/test_dht.cpp:1703</a></td><td>test need_refresh</td></tr><tr id="53" style="display: none;" colspan="3"><td colspan="3"><h2>test need_refresh</h2><h4>../test/test_dht.cpp:1703</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	table.find_node(id, nodes, 0, 10);
	TEST_EQUAL(table.bucket_size(0), 0);
	TEST_EQUAL(nodes.size(), 0);

	s.restrict_routing_ips = false;

	init_rand_address();

	add_and_replace(tmp, diff);
	table.node_seen(id, rand_udp_ep(rand_addr), 10);

	nodes.clear();
	for (int i = 0; i &lt; 7000; ++i)
	{
		table.node_seen(tmp, rand_udp_ep(rand_addr), 20 + (tmp[19] &amp; 0xff));
		add_and_replace(tmp, diff);
	}
	std::printf("active buckets: %d\n", table.num_active_buckets());
	TEST_EQUAL(table.num_active_buckets(), 10);
	TEST_CHECK(std::get&lt;0&gt;(table.size()) &gt;= 10 * 10);
<div style="background: #ffff00" width="100%">
</div>	print_state(std::cout, table);

	table.for_each_node(std::bind(node_push_back, &amp;nodes, _1), nullptr);

	std::printf("nodes: %d\n", int(nodes.size()));

	std::vector&lt;node_entry&gt; temp;

	std::generate(tmp.begin(), tmp.end(), random_byte);
	table.find_node(tmp, temp, 0, int(nodes.size()) * 2);
	std::printf("returned-all: %d\n", int(temp.size()));
	TEST_EQUAL(temp.size(), nodes.size());

	// This makes sure enough of the nodes returned are actually
	// part of the closest nodes
	std::set&lt;node_id&gt; duplicates;

	const int reps = 50;

	for (int r = 0; r &lt; reps; ++r)
	{
		std::generate(tmp.begin(), tmp.end(), random_byte);
		table.find_node(tmp, temp, 0, bucket_size * 2);
		std::printf("returned: %d\n", int(temp.size()));
		TEST_EQUAL(int(temp.size()), std::min(bucket_size * 2, int(nodes.size())));

		std::sort(nodes.begin(), nodes.end(), std::bind(&amp;compare_ref
				, std::bind(&amp;node_entry::id, _1)
				, std::bind(&amp;node_entry::id, _2), tmp));

</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(54)">../test/test_dht.cpp:2890</a></td><td>split this up into smaller test cases</td></tr><tr id="54" style="display: none;" colspan="3"><td colspan="3"><h2>split this up into smaller test cases</h2><h4>../test/test_dht.cpp:2890</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
	TEST_EQUAL(aux::to_hex(sig.bytes)
		, "6834284b6b24c3204eb2fea824d82f88883a3d95e8b4a21b8c0ded553d17d17d"
		"df9a8a7104b1258f30bed3787e6cb896fca78c58f8e03b5f18f14951a87d9a08");

	sha1_hash target_id = item_target_id(test_salt, pk);
	TEST_EQUAL(aux::to_hex(target_id), "411eba73b6f087ca51a3795d9c8c938d365e32c1");
}

TORRENT_TEST(signing_test3)
{
	// test vector 3

	// test content
	span&lt;char const&gt; test_content("12:Hello World!", 15);

	sha1_hash target_id = item_target_id(test_content);
	TEST_EQUAL(aux::to_hex(target_id), "e5f96f6f38320f0f33959cb4d3d656452117aadb");
}

<div style="background: #ffff00" width="100%">TORRENT_TEST(verify_message)
</div>{
	char error_string[200];

	// test verify_message
	static const key_desc_t msg_desc[] = {
		{"A", bdecode_node::string_t, 4, 0},
		{"B", bdecode_node::dict_t, 0, key_desc_t::optional | key_desc_t::parse_children},
			{"B1", bdecode_node::string_t, 0, 0},
			{"B2", bdecode_node::string_t, 0, key_desc_t::last_child},
		{"C", bdecode_node::dict_t, 0, key_desc_t::optional | key_desc_t::parse_children},
			{"C1", bdecode_node::string_t, 0, 0},
			{"C2", bdecode_node::string_t, 0, key_desc_t::last_child},
	};

	bdecode_node msg_keys[7];

	bdecode_node ent;

	error_code ec;
	char const test_msg[] = "d1:A4:test1:Bd2:B15:test22:B25:test3ee";
	bdecode(test_msg, test_msg + sizeof(test_msg)-1, ent, ec);
	std::printf("%s\n", print_entry(ent).c_str());

	bool ret = verify_message(ent, msg_desc, msg_keys, error_string);
	TEST_CHECK(ret);
	TEST_CHECK(msg_keys[0]);
	if (msg_keys[0]) TEST_EQUAL(msg_keys[0].string_value(), "test");
	TEST_CHECK(msg_keys[1]);
	TEST_CHECK(msg_keys[2]);
	if (msg_keys[2]) TEST_EQUAL(msg_keys[2].string_value(), "test2");
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(55)">../src/ut_metadata.cpp:100</a></td><td>if we were to initialize m_metadata_size lazily instead, we would probably be more efficient initialize m_metadata_size</td></tr><tr id="55" style="display: none;" colspan="3"><td colspan="3"><h2>if we were to initialize m_metadata_size lazily instead,
we would probably be more efficient
initialize m_metadata_size</h2><h4>../src/ut_metadata.cpp:100</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
	int div_round_up(int numerator, int denominator)
	{
		return (numerator + denominator - 1) / denominator;
	}

	struct ut_metadata_peer_plugin;

	struct ut_metadata_plugin final
		: torrent_plugin
	{
		explicit ut_metadata_plugin(torrent&amp; t) : m_torrent(t)
		{
			// initialize m_metadata_size
			if (m_torrent.valid_metadata())
				metadata();
		}

		void on_files_checked() override
		{
<div style="background: #ffff00" width="100%">			metadata();
</div>		}

		std::shared_ptr&lt;peer_plugin&gt; new_connection(
			peer_connection_handle const&amp; pc) override;

		int get_metadata_size() const
		{
			TORRENT_ASSERT(m_metadata_size &gt; 0);
			return m_metadata_size;
		}

		span&lt;char const&gt; metadata() const
		{
			TORRENT_ASSERT(m_torrent.valid_metadata());
			if (!m_metadata)
			{
				m_metadata = m_torrent.torrent_file().metadata();
				m_metadata_size = m_torrent.torrent_file().metadata_size();
				TORRENT_ASSERT(hasher(m_metadata.get(), m_metadata_size).final()
					== m_torrent.torrent_file().info_hash());
			}
			return {m_metadata.get(), m_metadata_size};
		}

		bool received_metadata(ut_metadata_peer_plugin&amp; source
			, span&lt;char const&gt; buf, int piece, int total_size);

		// returns a piece of the metadata that
		// we should request.
		// returns -1 if we should hold off the request
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(56)">../src/instantiate_connection.cpp:40</a></td><td>peer_connection and tracker_connection should probably be flags</td></tr><tr id="56" style="display: none;" colspan="3"><td colspan="3"><h2>peer_connection and tracker_connection should probably be flags</h2><h4>../src/instantiate_connection.cpp:40</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

*/

#include "libtorrent/socket.hpp"
#include "libtorrent/aux_/socket_type.hpp"
#include "libtorrent/utp_socket_manager.hpp"
#include "libtorrent/aux_/instantiate_connection.hpp"

namespace libtorrent { namespace aux {

<div style="background: #ffff00" width="100%">	bool instantiate_connection(io_service&amp; ios
</div>		, aux::proxy_settings const&amp; ps, aux::socket_type&amp; s
		, void* ssl_context
		, utp_socket_manager* sm
		, bool peer_connection
		, bool tracker_connection)
	{
#ifndef TORRENT_USE_OPENSSL
		TORRENT_UNUSED(ssl_context);
#endif

		if (sm)
		{
			utp_stream* str;
#ifdef TORRENT_USE_OPENSSL
			if (ssl_context)
			{
				s.instantiate&lt;ssl_stream&lt;utp_stream&gt;&gt;(ios, ssl_context);
				str = &amp;s.get&lt;ssl_stream&lt;utp_stream&gt;&gt;()-&gt;next_layer();
			}
			else
#endif
			{
				s.instantiate&lt;utp_stream&gt;(ios);
				str = s.get&lt;utp_stream&gt;();
			}
			str-&gt;set_impl(sm-&gt;new_utp_socket(str));
		}
#if TORRENT_USE_I2P
		else if (ps.type == settings_pack::i2p_proxy)
		{
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(57)">../src/bdecode.cpp:765</a></td><td>attempt to simplify this implementation by embracing the span</td></tr><tr id="57" style="display: none;" colspan="3"><td colspan="3"><h2>attempt to simplify this implementation by embracing the span</h2><h4>../src/bdecode.cpp:765</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	}

	bdecode_node bdecode(span&lt;char const&gt; buffer
		, error_code&amp; ec, int* error_pos, int depth_limit, int token_limit)
	{
		bdecode_node ret;
		ec.clear();

		if (buffer.size() &gt; bdecode_token::max_offset)
		{
			if (error_pos) *error_pos = 0;
			ec = bdecode_errors::limit_exceeded;
			return ret;
		}

		// this is the stack of bdecode_token indices, into m_tokens.
		// sp is the stack pointer, as index into the array, stack
		int sp = 0;
		TORRENT_ALLOCA(stack, stack_frame, depth_limit);

<div style="background: #ffff00" width="100%">		char const* start = buffer.data();
</div>		char const* end = start + buffer.size();
		char const* const orig_start = start;

		if (start == end)
			TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);

		while (start &lt;= end)
		{
			if (start &gt;= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);

			if (sp &gt;= depth_limit)
				TORRENT_FAIL_BDECODE(bdecode_errors::depth_exceeded);

			--token_limit;
			if (token_limit &lt; 0)
				TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);

			// look for a new token
			char const t = *start;

			int const current_frame = sp;

			// if we're currently parsing a dictionary, assert that
			// every other node is a string.
			if (current_frame &gt; 0
				&amp;&amp; ret.m_tokens[stack[current_frame - 1].token].type == bdecode_token::dict)
			{
				if (stack[current_frame - 1].state == 0)
				{
					// the current parent is a dict and we are parsing a key.
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(58)">../src/peer_connection.cpp:2442</a></td><td>this should probably be based on time instead of number of request messages. For a very high throughput connection, 300 may be a legitimate number of requests to have in flight when getting choked</td></tr><tr id="58" style="display: none;" colspan="3"><td colspan="3"><h2>this should probably be based on time instead of number
of request messages. For a very high throughput connection, 300
may be a legitimate number of requests to have in flight when
getting choked</h2><h4>../src/peer_connection.cpp:2442</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				, "piece: %d s: %d l: %d invalid request"
				, static_cast&lt;int&gt;(r.piece), r.start , r.length);
#endif

			write_reject_request(r);
			++m_num_invalid_requests;

			if (t-&gt;alerts().should_post&lt;invalid_request_alert&gt;())
			{
				// msvc 12 appears to deduce the rvalue reference template
				// incorrectly for bool temporaries. So, create a dummy instance
				bool const peer_interested = bool(m_peer_interested);
				t-&gt;alerts().emplace_alert&lt;invalid_request_alert&gt;(
					t-&gt;get_handle(), m_remote, m_peer_id, r
					, t-&gt;has_piece_passed(r.piece), peer_interested, false);
			}

			// every ten invalid request, remind the peer that it's choked
			if (!m_peer_interested &amp;&amp; m_num_invalid_requests % 10 == 0 &amp;&amp; m_choked)
			{
<div style="background: #ffff00" width="100%">				if (m_num_invalid_requests &gt; 300 &amp;&amp; !m_peer_choked
</div>					&amp;&amp; can_disconnect(errors::too_many_requests_when_choked))
				{
					disconnect(errors::too_many_requests_when_choked, operation_t::bittorrent, peer_error);
					return;
				}
#ifndef TORRENT_DISABLE_LOGGING
				peer_log(peer_log_alert::outgoing_message, "CHOKE");
#endif
				write_choke();
			}

			return;
		}

		// if we have choked the client
		// ignore the request
		int const blocks_per_piece =
			(ti.piece_length() + t-&gt;block_size() - 1) / t-&gt;block_size();

		// disconnect peers that downloads more than foo times an allowed
		// fast piece
		if (m_choked &amp;&amp; fast_idx != -1 &amp;&amp; m_accept_fast_piece_cnt[fast_idx] &gt;= 3 * blocks_per_piece
			&amp;&amp; can_disconnect(errors::too_many_requests_when_choked))
		{
			disconnect(errors::too_many_requests_when_choked, operation_t::bittorrent, peer_error);
			return;
		}

		if (m_choked &amp;&amp; fast_idx == -1)
		{
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(59)">../src/peer_connection.cpp:3177</a></td><td>since we throw away the queue entry once we issue the disk job, this may happen. Instead, we should keep the queue entry around, mark it as having been requested from disk and once the disk job comes back, discard it if it has been cancelled. Maybe even be able to cancel disk jobs?</td></tr><tr id="59" style="display: none;" colspan="3"><td colspan="3"><h2>since we throw away the queue entry once we issue
the disk job, this may happen. Instead, we should keep the
queue entry around, mark it as having been requested from
disk and once the disk job comes back, discard it if it has
been cancelled. Maybe even be able to cancel disk jobs?</h2><h4>../src/peer_connection.cpp:3177</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#endif

		auto const i = std::find(m_requests.begin(), m_requests.end(), r);

		if (i != m_requests.end())
		{
			m_counters.inc_stats_counter(counters::cancelled_piece_requests);
			m_requests.erase(i);

			if (m_requests.empty())
				m_counters.inc_stats_counter(counters::num_peers_up_requests, -1);

#ifndef TORRENT_DISABLE_LOGGING
			peer_log(peer_log_alert::outgoing_message, "REJECT_PIECE", "piece: %d s: %x l: %x cancelled"
				, static_cast&lt;int&gt;(r.piece), r.start , r.length);
#endif
			write_reject_request(r);
		}
		else
		{
<div style="background: #ffff00" width="100%">#ifndef TORRENT_DISABLE_LOGGING
</div>			peer_log(peer_log_alert::info, "INVALID_CANCEL", "got cancel not in the queue");
#endif
		}
	}

	// -----------------------------
	// --------- DHT PORT ----------
	// -----------------------------

	void peer_connection::incoming_dht_port(int const listen_port)
	{
		TORRENT_ASSERT(is_single_thread());
		INVARIANT_CHECK;

#ifndef TORRENT_DISABLE_LOGGING
		peer_log(peer_log_alert::incoming_message, "DHT_PORT", "p: %d", listen_port);
#endif
#ifndef TORRENT_DISABLE_DHT
		m_ses.add_dht_node({m_remote.address(), std::uint16_t(listen_port)});
#else
		TORRENT_UNUSED(listen_port);
#endif
	}

	// -----------------------------
	// --------- HAVE ALL ----------
	// -----------------------------

	void peer_connection::incoming_have_all()
	{
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(60)">../src/peer_connection.cpp:4807</a></td><td>use a deadline_timer for timeouts. Don't rely on second_tick()! Hook this up to connect timeout as well. This would improve performance because of less work in second_tick(), and might let use remove ticking entirely eventually</td></tr><tr id="60" style="display: none;" colspan="3"><td colspan="3"><h2>use a deadline_timer for timeouts. Don't rely on second_tick()!
Hook this up to connect timeout as well. This would improve performance
because of less work in second_tick(), and might let use remove ticking
entirely eventually</h2><h4>../src/peer_connection.cpp:4807</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				connect_timeout += 20;
#endif

			if (d &gt; seconds(connect_timeout)
				&amp;&amp; can_disconnect(errors::timed_out))
			{
#ifndef TORRENT_DISABLE_LOGGING
				peer_log(peer_log_alert::info, "CONNECT_FAILED", "waited %d seconds"
					, int(total_seconds(d)));
#endif
				connect_failed(errors::timed_out);
				return;
			}
		}

		// if we can't read, it means we're blocked on the rate-limiter
		// or the disk, not the peer itself. In this case, don't blame
		// the peer and disconnect it
		bool const may_timeout = bool(m_channel_state[download_channel] &amp; peer_info::bw_network);

<div style="background: #ffff00" width="100%">		if (may_timeout &amp;&amp; d &gt; seconds(timeout()) &amp;&amp; !m_connecting &amp;&amp; m_reading_bytes == 0
</div>			&amp;&amp; can_disconnect(errors::timed_out_inactivity))
		{
#ifndef TORRENT_DISABLE_LOGGING
			peer_log(peer_log_alert::info, "LAST_ACTIVITY", "%d seconds ago"
				, int(total_seconds(d)));
#endif
			disconnect(errors::timed_out_inactivity, operation_t::bittorrent);
			return;
		}

		// do not stall waiting for a handshake
		int timeout = m_settings.get_int (settings_pack::handshake_timeout);
#if TORRENT_USE_I2P
		timeout *= is_i2p(*m_socket) ? 4 : 1;
#endif
		if (may_timeout
			&amp;&amp; !m_connecting
			&amp;&amp; in_handshake()
			&amp;&amp; d &gt; seconds(timeout))
		{
#ifndef TORRENT_DISABLE_LOGGING
			peer_log(peer_log_alert::info, "NO_HANDSHAKE", "waited %d seconds"
				, int(total_seconds(d)));
#endif
			disconnect(errors::timed_out_no_handshake, operation_t::bittorrent);
			return;
		}

		// disconnect peers that we unchoked, but they didn't send a request in
		// the last 60 seconds, and we haven't been working on servicing a request
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(61)">../src/http_tracker_connection.cpp:378</a></td><td>returning a bool here is redundant. Instead this function should return the peer_entry</td></tr><tr id="61" style="display: none;" colspan="3"><td colspan="3"><h2>returning a bool here is redundant. Instead this function should
return the peer_entry</h2><h4>../src/http_tracker_connection.cpp:378</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		{
			cb-&gt;tracker_scrape_response(tracker_req(), resp.complete
				, resp.incomplete, resp.downloaded, resp.downloaders);
		}
		else
		{
			std::list&lt;address&gt; ip_list;
			if (m_tracker_connection)
			{
				for (auto const&amp; endp : m_tracker_connection-&gt;endpoints())
				{
					ip_list.push_back(endp.address());
				}
			}

			cb-&gt;tracker_response(tracker_req(), m_tracker_ip, ip_list, resp);
		}
		close();
	}

<div style="background: #ffff00" width="100%">	bool extract_peer_info(bdecode_node const&amp; info, peer_entry&amp; ret, error_code&amp; ec)
</div>	{
		// extract peer id (if any)
		if (info.type() != bdecode_node::dict_t)
		{
			ec = errors::invalid_peer_dict;
			return false;
		}
		bdecode_node i = info.dict_find_string("peer id");
		if (i &amp;&amp; i.string_length() == 20)
		{
			std::copy(i.string_ptr(), i.string_ptr() + 20, ret.pid.begin());
		}
		else
		{
			// if there's no peer_id, just initialize it to a bunch of zeroes
			ret.pid.clear();
		}

		// extract ip
		i = info.dict_find_string("ip");
		if (!i)
		{
			ec = errors::invalid_tracker_response;
			return false;
		}
		ret.hostname = i.string_value().to_string();

		// extract port
		i = info.dict_find_int("port");
		if (!i)
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(62)">../src/session_impl.cpp:475</a></td><td>is there a reason not to move all of this into init()? and just post it to the io_service?</td></tr><tr id="62" style="display: none;" colspan="3"><td colspan="3"><h2>is there a reason not to move all of this into init()? and just
post it to the io_service?</h2><h4>../src/session_impl.cpp:475</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	try
#endif
	{
		(this-&gt;*f)(std::forward&lt;Args&gt;(a)...);
	}
#ifndef BOOST_NO_EXCEPTIONS
	catch (system_error const&amp; e) {
		alerts().emplace_alert&lt;session_error_alert&gt;(e.code(), e.what());
		pause();
	} catch (std::exception const&amp; e) {
		alerts().emplace_alert&lt;session_error_alert&gt;(error_code(), e.what());
		pause();
	} catch (...) {
		alerts().emplace_alert&lt;session_error_alert&gt;(error_code(), "unknown error");
		pause();
	}
#endif

	// This function is called by the creating thread, not in the message loop's
	// io_service thread.
<div style="background: #ffff00" width="100%">	void session_impl::start_session()
</div>	{
#ifndef TORRENT_DISABLE_LOGGING
		session_log("start session");
#endif

#ifdef TORRENT_USE_OPENSSL
		error_code ec;
		m_ssl_ctx.set_verify_mode(boost::asio::ssl::context::verify_none, ec);
#if OPENSSL_VERSION_NUMBER &gt;= 0x90812f
		aux::openssl_set_tlsext_servername_callback(m_ssl_ctx.native_handle()
			, servername_callback);
		aux::openssl_set_tlsext_servername_arg(m_ssl_ctx.native_handle(), this);
#endif // OPENSSL_VERSION_NUMBER
#endif

#ifndef TORRENT_DISABLE_DHT
		m_next_dht_torrent = m_torrents.begin();
#endif
		m_next_lsd_torrent = m_torrents.begin();

		m_global_class = m_classes.new_peer_class("global");
		m_tcp_peer_class = m_classes.new_peer_class("tcp");
		m_local_peer_class = m_classes.new_peer_class("local");
		// local peers are always unchoked
		m_classes.at(m_local_peer_class)-&gt;ignore_unchoke_slots = true;
		// local peers are allowed to exceed the normal connection
		// limit by 50%
		m_classes.at(m_local_peer_class)-&gt;connection_limit_factor = 150;

		TORRENT_ASSERT(m_global_class == session::global_peer_class_id);
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(63)">../src/session_impl.cpp:3662</a></td><td>make a list for torrents that want to be announced on the DHT so we don't have to loop over all torrents, just to find the ones that want to announce</td></tr><tr id="63" style="display: none;" colspan="3"><td colspan="3"><h2>make a list for torrents that want to be announced on the DHT so we
don't have to loop over all torrents, just to find the ones that want to announce</h2><h4>../src/session_impl.cpp:3662</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		if (!m_dht_torrents.empty())
		{
			std::shared_ptr&lt;torrent&gt; t;
			do
			{
				t = m_dht_torrents.front().lock();
				m_dht_torrents.pop_front();
			} while (!t &amp;&amp; !m_dht_torrents.empty());

			if (t)
			{
				t-&gt;dht_announce();
				return;
			}
		}
		if (m_torrents.empty()) return;

		if (m_next_dht_torrent == m_torrents.end())
			m_next_dht_torrent = m_torrents.begin();
		m_next_dht_torrent-&gt;second-&gt;dht_announce();
<div style="background: #ffff00" width="100%">		++m_next_dht_torrent;
</div>		if (m_next_dht_torrent == m_torrents.end())
			m_next_dht_torrent = m_torrents.begin();
	}
#endif

	void session_impl::on_lsd_announce(error_code const&amp; e)
	{
		COMPLETE_ASYNC("session_impl::on_lsd_announce");
		m_stats_counters.inc_stats_counter(counters::on_lsd_counter);
		TORRENT_ASSERT(is_single_thread());
		if (e) return;

		if (m_abort) return;

		ADD_OUTSTANDING_ASYNC("session_impl::on_lsd_announce");
		// announce on local network every 5 minutes
		int const delay = std::max(m_settings.get_int(settings_pack::local_service_announce_interval)
			/ std::max(int(m_torrents.size()), 1), 1);
		error_code ec;
		m_lsd_announce_timer.expires_from_now(seconds(delay), ec);
		m_lsd_announce_timer.async_wait([this](error_code const&amp; err) {
			this-&gt;wrap(&amp;session_impl::on_lsd_announce, err); });

		if (m_torrents.empty()) return;

		if (m_next_lsd_torrent == m_torrents.end())
			m_next_lsd_torrent = m_torrents.begin();
		m_next_lsd_torrent-&gt;second-&gt;lsd_announce();
		++m_next_lsd_torrent;
		if (m_next_lsd_torrent == m_torrents.end())
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(64)">../src/session_impl.cpp:5372</a></td><td>this function should be removed and users need to deal with the more generic case of having multiple listen ports</td></tr><tr id="64" style="display: none;" colspan="3"><td colspan="3"><h2>this function should be removed and users need to deal with the
more generic case of having multiple listen ports</h2><h4>../src/session_impl.cpp:5372</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#ifndef TORRENT_DISABLE_LOGGING
		if (!node_list.empty() &amp;&amp; nodes.empty())
		{
			session_log("ERROR: failed to parse DHT bootstrap list: %s", node_list.c_str());
		}
#endif
		for (auto const&amp; n : nodes)
			add_dht_router(n);
#endif
	}

	void session_impl::update_count_slow()
	{
		error_code ec;
		for (auto const&amp; tp : m_torrents)
		{
			tp.second-&gt;on_inactivity_tick(ec);
		}
	}

<div style="background: #ffff00" width="100%">	std::uint16_t session_impl::listen_port() const
</div>	{
		return listen_port(nullptr);
	}

	std::uint16_t session_impl::listen_port(listen_socket_t* sock) const
	{
		if (m_listen_sockets.empty()) return 0;
		if (sock)
		{
			// if we're using a proxy, we won't be able to accept any TCP
			// connections. We may be able to accept uTP connections though, so
			// announce the UDP port instead
			if (m_settings.get_int(settings_pack::proxy_type) != settings_pack::none)
				return std::uint16_t(sock-&gt;udp_external_port);
			else
				return std::uint16_t(sock-&gt;tcp_external_port);
		}

#ifdef TORRENT_USE_OPENSSL
		for (auto const&amp; s : m_listen_sockets)
		{
			if (s-&gt;ssl == transport::plaintext)
			{
				if (m_settings.get_int(settings_pack::proxy_type) != settings_pack::none)
					return std::uint16_t(s-&gt;udp_external_port);
				else
					return std::uint16_t(s-&gt;tcp_external_port);
			}
		}
		return 0;
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(65)">../src/session_impl.cpp:5410</a></td><td>this function should be removed and users need to deal with the more generic case of having multiple ssl ports</td></tr><tr id="65" style="display: none;" colspan="3"><td colspan="3"><h2>this function should be removed and users need to deal with the
more generic case of having multiple ssl ports</h2><h4>../src/session_impl.cpp:5410</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				return std::uint16_t(sock-&gt;tcp_external_port);
		}

#ifdef TORRENT_USE_OPENSSL
		for (auto const&amp; s : m_listen_sockets)
		{
			if (s-&gt;ssl == transport::plaintext)
			{
				if (m_settings.get_int(settings_pack::proxy_type) != settings_pack::none)
					return std::uint16_t(s-&gt;udp_external_port);
				else
					return std::uint16_t(s-&gt;tcp_external_port);
			}
		}
		return 0;
#else
		return std::uint16_t(m_listen_sockets.front()-&gt;tcp_external_port);
#endif
	}

<div style="background: #ffff00" width="100%">	std::uint16_t session_impl::ssl_listen_port() const
</div>	{
		return ssl_listen_port(nullptr);
	}

	std::uint16_t session_impl::ssl_listen_port(listen_socket_t* sock) const
	{
#ifdef TORRENT_USE_OPENSSL

		if (sock)
		{
			// if we're using a proxy, we won't be able to accept any TCP
			// connections. We may be able to accept uTP connections though, so
			// announce the UDP port instead
			if (m_settings.get_int(settings_pack::proxy_type) != settings_pack::none)
				return std::uint16_t(sock-&gt;udp_external_port);
			else
				return std::uint16_t(sock-&gt;tcp_external_port);
		}

		if (m_settings.get_int(settings_pack::proxy_type) != settings_pack::none)
			return 0;

		for (auto const&amp; s : m_listen_sockets)
		{
			if (s-&gt;ssl == transport::ssl)
			{
				if (m_settings.get_int(settings_pack::proxy_type) != settings_pack::none)
					return std::uint16_t(s-&gt;udp_external_port);
				else
					return std::uint16_t(s-&gt;tcp_external_port);
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(66)">../src/session_impl.cpp:6230</a></td><td>this should be factored into the udp socket, so we only have the code once</td></tr><tr id="66" style="display: none;" colspan="3"><td colspan="3"><h2>this should be factored into the udp socket, so we only have the
code once</h2><h4>../src/session_impl.cpp:6230</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	int session_impl::download_rate_limit_depr() const
	{
		return download_rate_limit(m_global_class);
	}
#endif // DEPRECATE


	namespace {
		template &lt;typename Socket&gt;
		void set_tos(Socket&amp; s, int v, error_code&amp; ec)
		{
#if defined IPV6_TCLASS
			if (is_v6(s.local_endpoint(ec)))
				s.set_option(traffic_class(char(v)), ec);
			else if (!ec)
#endif
				s.set_option(type_of_service(char(v)), ec);
		}
	}

<div style="background: #ffff00" width="100%">	void session_impl::update_peer_tos()
</div>	{
		int const tos = m_settings.get_int(settings_pack::peer_tos);
		for (auto const&amp; l : m_listen_sockets)
		{
			if (l-&gt;sock)
			{
				error_code ec;
				set_tos(*l-&gt;sock, tos, ec);

#ifndef TORRENT_DISABLE_LOGGING
				if (should_log())
				{
					session_log("&gt;&gt;&gt; SET_TOS [ tcp (%s %d) tos: %x e: %s ]"
						, l-&gt;sock-&gt;local_endpoint().address().to_string().c_str()
						, l-&gt;sock-&gt;local_endpoint().port(), tos, ec.message().c_str());
				}
#endif
			}

			if (l-&gt;udp_sock)
			{
				error_code ec;
				set_tos(l-&gt;udp_sock-&gt;sock, tos, ec);

#ifndef TORRENT_DISABLE_LOGGING
				if (should_log())
				{
					session_log("&gt;&gt;&gt; SET_TOS [ udp (%s %d) tos: %x e: %s ]"
						, l-&gt;udp_sock-&gt;sock.local_endpoint().address().to_string().c_str()
						, l-&gt;udp_sock-&gt;sock.local_port()
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(67)">../src/torrent.cpp:231</a></td><td>p should probably be moved in here</td></tr><tr id="67" style="display: none;" colspan="3"><td colspan="3"><h2>p should probably be moved in here</h2><h4>../src/torrent.cpp:231</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		, m_magnet_link(false)
		, m_apply_ip_filter(p.flags &amp; torrent_flags::apply_ip_filter)
		, m_pending_active_change(false)
		, m_connect_boost_counter(static_cast&lt;std::uint8_t&gt;(settings().get_int(settings_pack::torrent_connect_boost)))
		, m_incomplete(0xffffff)
		, m_announce_to_dht(!(p.flags &amp; torrent_flags::paused))
		, m_ssl_torrent(false)
		, m_deleted(false)
		, m_last_download(seconds32(p.last_download))
		, m_last_upload(seconds32(p.last_upload))
		, m_auto_managed(p.flags &amp; torrent_flags::auto_managed)
		, m_current_gauge_state(static_cast&lt;std::uint32_t&gt;(no_gauge_state))
		, m_moving_storage(false)
		, m_inactive(false)
		, m_downloaded(0xffffff)
		, m_progress_ppm(0)
	{
		// we cannot log in the constructor, because it relies on shared_from_this
		// being initialized, which happens after the constructor returns.

<div style="background: #ffff00" width="100%">		m_add_torrent_params.reset(new add_torrent_params(p));
</div>
#if TORRENT_USE_UNC_PATHS
		m_save_path = canonicalize_path(m_save_path);
#endif

		if (!m_apply_ip_filter)
		{
			inc_stats_counter(counters::non_filter_torrents);
		}

		if (!p.ti || !p.ti-&gt;is_valid())
		{
			// we don't have metadata for this torrent. We'll download
			// it either through the URL passed in, or through a metadata
			// extension. Make sure that when we save resume data for this
			// torrent, we also save the metadata
			m_magnet_link = true;
		}

		if (!m_torrent_file)
			m_torrent_file = (p.ti ? p.ti : std::make_shared&lt;torrent_info&gt;(m_info_hash));

		// --- WEB SEEDS ---

		// if override web seed flag is set, don't load any web seeds from the
		// torrent file.
		std::vector&lt;web_seed_t&gt; ws;
		if (!(p.flags &amp; torrent_flags::override_web_seeds))
		{
			for (auto const&amp; e : m_torrent_file-&gt;web_seeds())
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(68)">../src/torrent.cpp:325</a></td><td>set_merkle_tree should probably take the vector as &&</td></tr><tr id="68" style="display: none;" colspan="3"><td colspan="3"><h2>set_merkle_tree should probably take the vector as &&</h2><h4>../src/torrent.cpp:325</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			if (!find_tracker(e.url))
			{
				m_trackers.push_back(e);
			}
		}

		std::sort(m_trackers.begin(), m_trackers.end()
			, [] (announce_entry const&amp; lhs, announce_entry const&amp; rhs)
			{ return lhs.tier &lt; rhs.tier; });

		if (settings().get_bool(settings_pack::prefer_udp_trackers))
			prioritize_udp_trackers();

		// --- MERKLE TREE ---

		if (m_torrent_file-&gt;is_valid()
			&amp;&amp; m_torrent_file-&gt;is_merkle_torrent())
		{
			if (p.merkle_tree.size() == m_torrent_file-&gt;merkle_tree().size())
			{
<div style="background: #ffff00" width="100%">				std::vector&lt;sha1_hash&gt; tree(p.merkle_tree);
</div>				m_torrent_file-&gt;set_merkle_tree(tree);
			}
			else
			{
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(69)">../src/torrent.cpp:566</a></td><td>post alert</td></tr><tr id="69" style="display: none;" colspan="3"><td colspan="3"><h2>post alert</h2><h4>../src/torrent.cpp:566</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		if (m_current_gauge_state != no_gauge_state)
			inc_stats_counter(m_current_gauge_state + counters::num_checking_torrents, -1);
		if (new_gauge_state != no_gauge_state)
			inc_stats_counter(new_gauge_state + counters::num_checking_torrents, 1);

		TORRENT_ASSERT(new_gauge_state &gt;= 0);
		TORRENT_ASSERT(new_gauge_state &lt;= no_gauge_state);
		m_current_gauge_state = static_cast&lt;std::uint32_t&gt;(new_gauge_state);
	}

	void torrent::leave_seed_mode(seed_mode_t const checking)
	{
		if (!m_seed_mode) return;

		if (checking == seed_mode_t::check_files)
		{
			// this means the user promised we had all the
			// files, but it turned out we didn't. This is
			// an error.

<div style="background: #ffff00" width="100%">
</div>#ifndef TORRENT_DISABLE_LOGGING
			debug_log("*** FAILED SEED MODE, rechecking");
#endif
		}

#ifndef TORRENT_DISABLE_LOGGING
		debug_log("*** LEAVING SEED MODE (%s)"
			, checking == seed_mode_t::skip_checking ? "as seed" : "as non-seed");
#endif
		m_seed_mode = false;
		// seed is false if we turned out not
		// to be a seed after all
		if (checking == seed_mode_t::check_files
			&amp;&amp; state() != torrent_status::checking_resume_data)
		{
			m_have_all = false;
			set_state(torrent_status::downloading);
			force_recheck();
		}
		m_num_verified = 0;
		m_verified.clear();
		m_verifying.clear();

		set_need_save_resume();
	}

	void torrent::verified(piece_index_t const piece)
	{
		TORRENT_ASSERT(!m_verified.get_bit(piece));
		++m_num_verified;
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(70)">../src/torrent.cpp:1766</a></td><td>add a unit test where we don't have metadata, connect to a peer that sends a bitfield that's too large, then we get the metadata</td></tr><tr id="70" style="display: none;" colspan="3"><td colspan="3"><h2>add a unit test where we don't have metadata, connect to a peer
that sends a bitfield that's too large, then we get the metadata</h2><h4>../src/torrent.cpp:1766</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		if (m_add_torrent_params)
		{
			for (auto const&amp; f : m_add_torrent_params-&gt;renamed_files)
			{
				if (f.first &lt; file_index_t(0) || f.first &gt;= fs.end_file()) continue;
				m_torrent_file-&gt;rename_file(file_index_t(f.first), f.second);
			}
		}

		construct_storage();

		if (m_share_mode &amp;&amp; valid_metadata())
		{
			// in share mode, all pieces have their priorities initialized to 0
			m_file_priority.clear();
			m_file_priority.resize(m_torrent_file-&gt;num_files(), dont_download);
		}

		// it's important to initialize the peers early, because this is what will
		// fix up their have-bitmasks to have the correct size
<div style="background: #ffff00" width="100%">		if (!m_connections_initialized)
</div>		{
			m_connections_initialized = true;
			// all peer connections have to initialize themselves now that the metadata
			// is available
			// copy the peer list since peers may disconnect and invalidate
			// m_connections as we initialize them
			for (auto c : m_connections)
			{
				auto pc = c-&gt;self();
				if (pc-&gt;is_disconnecting()) continue;
				pc-&gt;on_metadata_impl();
				if (pc-&gt;is_disconnecting()) continue;
				pc-&gt;init();
			}
		}

		// in case file priorities were passed in via the add_torrent_params
		// and also in the case of share mode, we need to update the priorities
		// this has to be applied before piece priority
		if (!m_file_priority.empty()) update_piece_priorities(m_file_priority);

		if (m_add_torrent_params)
		{
			piece_index_t idx(0);
			for (auto prio : m_add_torrent_params-&gt;piece_priorities)
			{
				if (has_picker() || prio != default_priority)
				{
					need_picker();
					m_picker-&gt;set_piece_priority(idx, prio);
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(71)">../src/torrent.cpp:3934</a></td><td>use chrono type for time duration</td></tr><tr id="71" style="display: none;" colspan="3"><td colspan="3"><h2>use chrono type for time duration</h2><h4>../src/torrent.cpp:3934</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			}
		}
		// announcing a piece may invalidate the torrent_peer pointers
		// so we can't use them anymore

		downloaders.clear();
		peers.clear();

		// make the disk cache flush the piece to disk
		if (m_storage)
			m_ses.disk_thread().async_flush_piece(m_storage, index);
		m_picker-&gt;piece_passed(index);
		update_gauge();
		we_have(index);
	}

	// we believe we will complete this piece very soon
	// announce it to peers ahead of time to eliminate the
	// round-trip times involved in announcing it, requesting it
	// and sending it
<div style="background: #ffff00" width="100%">	void torrent::predicted_have_piece(piece_index_t const index, int const milliseconds)
</div>	{
		auto const i = std::lower_bound(m_predictive_pieces.begin()
			, m_predictive_pieces.end(), index);
		if (i != m_predictive_pieces.end() &amp;&amp; *i == index) return;

		for (auto p : m_connections)
		{
			TORRENT_INCREMENT(m_iterating_connections);
#ifndef TORRENT_DISABLE_LOGGING
			p-&gt;peer_log(peer_log_alert::outgoing, "PREDICTIVE_HAVE", "piece: %d expected in %d ms"
				, static_cast&lt;int&gt;(index), milliseconds);
#else
			TORRENT_UNUSED(milliseconds);
#endif
			p-&gt;announce_piece(index);
		}

		m_predictive_pieces.insert(i, index);
	}

	void torrent::piece_failed(piece_index_t const index)
	{
		// if the last piece fails the peer connection will still
		// think that it has received all of it until this function
		// resets the download queue. So, we cannot do the
		// invariant check here since it assumes:
		// (total_done == m_torrent_file-&gt;total_size()) =&gt; is_seed()
		INVARIANT_CHECK;
		TORRENT_ASSERT(is_single_thread());

</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(72)">../src/torrent.cpp:4327</a></td><td>abort lookups this torrent has made via the session host resolver interface</td></tr><tr id="72" style="display: none;" colspan="3"><td colspan="3"><h2>abort lookups this torrent has made via the
session host resolver interface</h2><h4>../src/torrent.cpp:4327</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			}
			catch (std::exception const&amp; e)
			{
				TORRENT_UNUSED(e);
				m_storage.reset();
#ifndef TORRENT_DISABLE_LOGGING
				debug_log("Failed to flush disk cache: %s", e.what());
#endif
				// clients may rely on this alert to be posted, so it's probably a
				// good idea to post it here, even though we failed
				if (alerts().should_post&lt;cache_flushed_alert&gt;())
					alerts().emplace_alert&lt;cache_flushed_alert&gt;(get_handle());
			}
		}
		else
		{
			if (alerts().should_post&lt;cache_flushed_alert&gt;())
				alerts().emplace_alert&lt;cache_flushed_alert&gt;(get_handle());
		}

<div style="background: #ffff00" width="100%">
</div>		if (!m_apply_ip_filter)
		{
			inc_stats_counter(counters::non_filter_torrents, -1);
			m_apply_ip_filter = true;
		}

		m_paused = false;
		m_auto_managed = false;
		update_state_list();
		for (torrent_list_index_t i{}; i != m_links.end_index(); ++i)
		{
			if (!m_links[i].in_list()) continue;
			m_links[i].unlink(m_ses.torrent_list(i), i);
		}
		// don't re-add this torrent to the state-update list
		m_state_subscription = false;
	}

	// this is called when we're destructing non-gracefully. i.e. we're _just_
	// destructing everything.
	void torrent::panic()
	{
		m_storage.reset();
		// if there are any other peers allocated still, we need to clear them
		// now. They can't be cleared later because the allocator will already
		// have been destructed
		if (m_peer_list) m_peer_list-&gt;clear();
		m_connections.clear();
		m_outgoing_pids.clear();
		m_peers_to_disconnect.clear();
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(73)">../src/torrent.cpp:6915</a></td><td>if peer is a really good peer, maybe we shouldn't disconnect it perhaps this logic should be disabled if we have too many idle peers (with some definition of idle)</td></tr><tr id="73" style="display: none;" colspan="3"><td colspan="3"><h2>if peer is a really good peer, maybe we shouldn't disconnect it
perhaps this logic should be disabled if we have too many idle peers
(with some definition of idle)</h2><h4>../src/torrent.cpp:6915</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		m_peers_to_disconnect.reserve(m_connections.size() + 1);
		m_connections.reserve(m_connections.size() + 1);

#if TORRENT_USE_ASSERTS
		error_code ec;
		TORRENT_ASSERT(p-&gt;remote() == p-&gt;get_socket()-&gt;remote_endpoint(ec) || ec);
#endif

		TORRENT_ASSERT(p-&gt;peer_info_struct() != nullptr);

		// we need to do this after we've added the peer to the peer_list
		// since that's when the peer is assigned its peer_info object,
		// which holds the rank
		if (maybe_replace_peer)
		{
			// now, find the lowest rank peer and disconnect that
			// if it's lower rank than the incoming connection
			peer_connection* peer = find_lowest_ranking_peer();

<div style="background: #ffff00" width="100%">			if (peer != nullptr &amp;&amp; peer-&gt;peer_rank() &lt; p-&gt;peer_rank())
</div>			{
#ifndef TORRENT_DISABLE_LOGGING
				if (should_log())
				{
					debug_log("CLOSING CONNECTION \"%s\" peer list full (low peer rank) "
						"connections: %d limit: %d"
						, print_endpoint(peer-&gt;remote()).c_str()
						, num_peers()
						, m_max_connections);
				}
#endif
				peer-&gt;disconnect(errors::too_many_connections, operation_t::bittorrent);
				p-&gt;peer_disconnected_other();
			}
			else
			{
#ifndef TORRENT_DISABLE_LOGGING
				if (should_log())
				{
					debug_log("CLOSING CONNECTION \"%s\" peer list full (low peer rank) "
						"connections: %d limit: %d"
						, print_endpoint(p-&gt;remote()).c_str()
						, num_peers()
						, m_max_connections);
				}
#endif
				p-&gt;disconnect(errors::too_many_connections, operation_t::bittorrent);
				// we have to do this here because from the peer's point of view
				// it wasn't really attached to the torrent, but we do need
				// to let peer_list know we're removing it
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(74)">../src/utp_stream.cpp:303</a></td><td>it would be nice if not everything would have to be public here</td></tr><tr id="74" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice if not everything would have to be public here</h2><h4>../src/utp_stream.cpp:303</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	void do_ledbat(int acked_bytes, int delay, int in_flight);
	int packet_timeout() const;
	bool test_socket_state();
	void maybe_trigger_receive_callback();
	void maybe_trigger_send_callback();
	bool cancel_handlers(error_code const&amp; ec, bool shutdown);
	bool consume_incoming_data(
		utp_header const* ph, std::uint8_t const* ptr, int payload_size, time_point now);
	void update_mtu_limits();
	void experienced_loss(std::uint32_t seq_nr, time_point now);

	void set_state(int s);

	packet_ptr acquire_packet(int const allocate) { return m_sm.acquire_packet(allocate); }
	void release_packet(packet_ptr p) { m_sm.release_packet(std::move(p)); }

	// non-copyable
	utp_socket_impl(utp_socket_impl const&amp;) = delete;
	utp_socket_impl const&amp; operator=(utp_socket_impl const&amp;) = delete;

<div style="background: #ffff00" width="100%">
</div>#if TORRENT_USE_INVARIANT_CHECKS
	void check_receive_buffers() const;
	void check_invariant() const;
#endif

	utp_socket_manager&amp; m_sm;
	std::weak_ptr&lt;utp_socket_interface&gt; m_sock;

	// userdata pointer passed along
	// with any callback. This is initialized to 0
	// then set to point to the utp_stream when
	// hooked up, and then reset to 0 once the utp_stream
	// detaches. This is used to know whether or not
	// the socket impl is still attached to a utp_stream
	// object. When it isn't, we'll never be able to
	// signal anything back to the client, and in case
	// of errors, we just have to delete ourselves
	// i.e. transition to the UTP_STATE_DELETED state
	void* m_userdata;

	// This is a platform-independent replacement
	// for the regular iovec type in posix. Since
	// it's not used in any system call, we might as
	// well define our own type instead of wrapping
	// the system's type.
	struct iovec_t
	{
		iovec_t(void* b, std::size_t l): buf(b), len(l) {}
		void* buf;
		std::size_t len;
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(75)">../src/udp_tracker_connection.cpp:76</a></td><td>support authentication here. tracker_req().auth</td></tr><tr id="75" style="display: none;" colspan="3"><td colspan="3"><h2>support authentication here. tracker_req().auth</h2><h4>../src/udp_tracker_connection.cpp:76</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		udp_tracker_connection::m_connection_cache;

	std::mutex udp_tracker_connection::m_cache_mutex;

	udp_tracker_connection::udp_tracker_connection(
		io_service&amp; ios
		, tracker_manager&amp; man
		, tracker_request const&amp; req
		, std::weak_ptr&lt;request_callback&gt; c)
		: tracker_connection(man, req, ios, std::move(c))
		, m_transaction_id(0)
		, m_attempts(0)
		, m_state(action_t::error)
		, m_abort(false)
	{
		update_transaction_id();
	}

	void udp_tracker_connection::start()
	{
<div style="background: #ffff00" width="100%">		std::string hostname;
</div>		std::string protocol;
		int port;
		error_code ec;

		std::tie(protocol, std::ignore, hostname, port, std::ignore)
			= parse_url_components(tracker_req().url, ec);
		if (port == -1) port = protocol == "http" ? 80 : 443;

		if (ec)
		{
			tracker_connection::fail(ec);
			return;
		}

		aux::session_settings const&amp; settings = m_man.settings();

		int const proxy_type = settings.get_int(settings_pack::proxy_type);

		if (settings.get_bool(settings_pack::proxy_hostnames)
			&amp;&amp; (proxy_type == settings_pack::socks5
				|| proxy_type == settings_pack::socks5_pw))
		{
			m_hostname = hostname;
			m_target.port(std::uint16_t(port));
			start_announce();
		}
		else
		{
			using namespace std::placeholders;
			ADD_OUTSTANDING_ASYNC("udp_tracker_connection::name_lookup");
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(76)">../src/alert_manager.cpp:75</a></td><td>keep a count of the number of threads waiting. Only if it's > 0 notify them</td></tr><tr id="76" style="display: none;" colspan="3"><td colspan="3"><h2>keep a count of the number of threads waiting. Only if it's
> 0 notify them</h2><h4>../src/alert_manager.cpp:75</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			return m_alerts[m_generation].front();

		// this call can be interrupted prematurely by other signals
		m_condition.wait_for(lock, max_wait);
		if (!m_alerts[m_generation].empty())
			return m_alerts[m_generation].front();

		return nullptr;
	}

	void alert_manager::maybe_notify(alert* a)
	{
		if (m_alerts[m_generation].size() == 1)
		{
			// we just posted to an empty queue. If anyone is waiting for
			// alerts, we need to notify them. Also (potentially) call the
			// user supplied m_notify callback to let the client wake up its
			// message loop to poll for alerts.
			if (m_notify) m_notify();

<div style="background: #ffff00" width="100%">			m_condition.notify_all();
</div>		}

#ifndef TORRENT_DISABLE_EXTENSIONS
		for (auto&amp; e : m_ses_extensions)
			e-&gt;on_alert(a);
#else
		TORRENT_UNUSED(a);
#endif
	}

	void alert_manager::set_notify_function(std::function&lt;void()&gt; const&amp; fun)
	{
		std::unique_lock&lt;std::recursive_mutex&gt; lock(m_mutex);
		m_notify = fun;
		if (!m_alerts[m_generation].empty())
		{
			if (m_notify) m_notify();
		}
	}

#ifndef TORRENT_DISABLE_EXTENSIONS
	void alert_manager::add_extension(std::shared_ptr&lt;plugin&gt; ext)
	{
		m_ses_extensions.push_back(ext);
	}
#endif

	void alert_manager::get_all(std::vector&lt;alert*&gt;&amp; alerts)
	{
		std::lock_guard&lt;std::recursive_mutex&gt; lock(m_mutex);
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(77)">../src/path.cpp:353</a></td><td>test this on a FAT volume to see what error we get!</td></tr><tr id="77" style="display: none;" colspan="3"><td colspan="3"><h2>test this on a FAT volume to see what error we get!</h2><h4>../src/path.cpp:353</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			// it's possible CreateHardLink will copy the file internally too,
			// if the filesystem does not support it.
			ec.assign(GetLastError(), system_category());
			return;
		}

		// fall back to making a copy

#else
		// assume posix's link() function exists
		int ret = ::link(n_exist.c_str(), n_link.c_str());

		if (ret == 0)
		{
			ec.clear();
			return;
		}

		// most errors are passed through, except for the ones that indicate that
		// hard links are not supported and require a copy.
<div style="background: #ffff00" width="100%">		if (errno != EMLINK &amp;&amp; errno != EXDEV)
</div>		{
			// some error happened, report up to the caller
			ec.assign(errno, system_category());
			return;
		}

		// fall back to making a copy

#endif

		// if we get here, we should copy the file
		copy_file(file, link, ec);
	}

	bool is_directory(std::string const&amp; f, error_code&amp; ec)
	{
		ec.clear();
		error_code e;
		file_status s;
		stat_file(f, &amp;s, e);
		if (!e &amp;&amp; s.mode &amp; file_status::directory) return true;
		ec = e;
		return false;
	}

	void recursive_copy(std::string const&amp; old_path, std::string const&amp; new_path, error_code&amp; ec)
	{
		TORRENT_ASSERT(!ec);
		if (is_directory(old_path, ec))
		{
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(78)">../src/peer_list.cpp:467</a></td><td>it would be nice if there was a way to iterate over these torrent_peer objects in the order they are allocated in the pool instead. It would probably be more efficient</td></tr><tr id="78" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice if there was a way to iterate over these
torrent_peer objects in the order they are allocated in the pool
instead. It would probably be more efficient</h2><h4>../src/peer_list.cpp:467</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		, int session_time, torrent_state* state)
	{
		TORRENT_ASSERT(is_single_thread());
		INVARIANT_CHECK;

		const int candidate_count = 10;
		peers.reserve(candidate_count);

		int erase_candidate = -1;

		if (bool(m_finished) != state-&gt;is_finished)
			recalculate_connect_candidates(state);

		external_ip const&amp; external = state-&gt;ip;
		int external_port = state-&gt;port;

		if (m_round_robin &gt;= int(m_peers.size())) m_round_robin = 0;

		int max_peerlist_size = state-&gt;max_peerlist_size;

<div style="background: #ffff00" width="100%">		for (int iterations = std::min(int(m_peers.size()), 300);
</div>			iterations &gt; 0; --iterations)
		{
			++state-&gt;loop_counter;

			if (m_round_robin &gt;= int(m_peers.size())) m_round_robin = 0;

			torrent_peer&amp; pe = *m_peers[m_round_robin];
			TORRENT_ASSERT(pe.in_use);
			int current = m_round_robin;

			// if the number of peers is growing large
			// we need to start weeding.

			if (int(m_peers.size()) &gt;= max_peerlist_size * 0.95
				&amp;&amp; max_peerlist_size &gt; 0)
			{
				if (is_erase_candidate(pe)
					&amp;&amp; (erase_candidate == -1
						|| !compare_peer_erase(*m_peers[erase_candidate], pe)))
				{
					if (should_erase_immediately(pe))
					{
						if (erase_candidate &gt; current) --erase_candidate;
						erase_peer(m_peers.begin() + current, state);
						continue;
					}
					else
					{
						erase_candidate = current;
					}
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(79)">../src/piece_picker.cpp:1906</a></td><td>make the 2048 limit configurable</td></tr><tr id="79" style="display: none;" colspan="3"><td colspan="3"><h2>make the 2048 limit configurable</h2><h4>../src/piece_picker.cpp:1906</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// indicating which path thought the picker we took to arrive at the
	// returned block picks.
	picker_flags_t piece_picker::pick_pieces(typed_bitfield&lt;piece_index_t&gt; const&amp; pieces
		, std::vector&lt;piece_block&gt;&amp; interesting_blocks, int num_blocks
		, int prefer_contiguous_blocks, torrent_peer* peer
		, picker_options_t options, std::vector&lt;piece_index_t&gt; const&amp; suggested_pieces
		, int num_peers
		, counters&amp; pc
		) const
	{
		TORRENT_ASSERT(peer == nullptr || peer-&gt;in_use);
		picker_flags_t ret;

		// prevent the number of partial pieces to grow indefinitely
		// make this scale by the number of peers we have. For large
		// scale clients, we would have more peers, and allow a higher
		// threshold for the number of partials
		// the second condition is to make sure we cap the number of partial
		// _bytes_. The larger the pieces are, the fewer partial pieces we want.
		// 2048 corresponds to 32 MiB
<div style="background: #ffff00" width="100%">		const int num_partials = int(m_downloads[piece_pos::piece_downloading].size());
</div>		if (num_partials &gt; num_peers * 3 / 2
			|| num_partials * m_blocks_per_piece &gt; 2048)
		{
			// if we have too many partial pieces, prioritize completing
			// them. In order for this to have an affect, also disable
			// prefer whole pieces (otherwise partial pieces would be de-prioritized)
			options |= prioritize_partials;
			prefer_contiguous_blocks = 0;

			ret |= picker_log_alert::partial_ratio;
		}

		if (prefer_contiguous_blocks) ret |= picker_log_alert::prefer_contiguous;

		// only one of rarest_first and sequential can be set.
		TORRENT_ASSERT(((options &amp; rarest_first) ? 1 : 0)
			+ ((options &amp; sequential) ? 1 : 0) &lt;= 1);
#ifdef TORRENT_EXPENSIVE_INVARIANT_CHECKS
		INVARIANT_CHECK;
#endif
		TORRENT_ASSERT(num_blocks &gt; 0);
		TORRENT_ASSERT(pieces.size() == int(m_piece_map.size()));

		TORRENT_ASSERT(!m_priority_boundaries.empty() || m_dirty);

		// this will be filled with blocks that we should not request
		// unless we can't find num_blocks among the other ones.
		std::vector&lt;piece_block&gt; backup_blocks;
		std::vector&lt;piece_block&gt; backup_blocks2;
		static const std::vector&lt;piece_index_t&gt; empty_vector;
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(80)">../src/piece_picker.cpp:2514</a></td><td>the first_block returned here is the largest free range, not the first-fit range, which would be better</td></tr><tr id="80" style="display: none;" colspan="3"><td colspan="3"><h2>the first_block returned here is the largest free range, not
the first-fit range, which would be better</h2><h4>../src/piece_picker.cpp:2514</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	{
		for (auto const&amp; b : m_block_info)
		{
			TORRENT_ASSERT(b.peer == nullptr || static_cast&lt;torrent_peer*&gt;(b.peer)-&gt;in_use);
		}
	}
#endif

	void piece_picker::clear_peer(torrent_peer* peer)
	{
		for (auto&amp; b : m_block_info)
		{
			if (b.peer == peer) b.peer = nullptr;
		}
	}

	// the first bool is true if this is the only peer that has requested and downloaded
	// blocks from this piece.
	// the second bool is true if this is the only active peer that is requesting
	// and downloading blocks from this piece. Active means having a connection.
<div style="background: #ffff00" width="100%">	std::tuple&lt;bool, bool, int, int&gt; piece_picker::requested_from(
</div>		piece_picker::downloading_piece const&amp; p
		, int const num_blocks_in_piece, torrent_peer* peer) const
	{
		bool exclusive = true;
		bool exclusive_active = true;
		int contiguous_blocks = 0;
		int max_contiguous = 0;
		int first_block = 0;
		int idx = -1;
		for (auto const&amp; info : blocks_for_piece(p))
		{
			++idx;
			TORRENT_ASSERT(info.peer == nullptr || info.peer-&gt;in_use);
			TORRENT_ASSERT(info.piece_index == p.index);
			if (info.state == piece_picker::block_info::state_none)
			{
				++contiguous_blocks;
				continue;
			}
			if (contiguous_blocks &gt; max_contiguous)
			{
				max_contiguous = contiguous_blocks;
				first_block = idx - contiguous_blocks;
			}
			contiguous_blocks = 0;
			if (info.peer != peer)
			{
				exclusive = false;
				if (info.state == piece_picker::block_info::state_requested
					&amp;&amp; info.peer != nullptr)
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(81)">../src/piece_picker.cpp:3259</a></td><td>it would be nice if this could be folded into lock_piece() the main distinction is that this also maintains the m_num_passed counter and the passed_hash_check member Is there ever a case where we call write filed without also locking the piece? Perhaps write_failed() should imply locking it.</td></tr><tr id="81" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice if this could be folded into lock_piece()
the main distinction is that this also maintains the m_num_passed
counter and the passed_hash_check member
Is there ever a case where we call write filed without also locking
the piece? Perhaps write_failed() should imply locking it.</h2><h4>../src/piece_picker.cpp:3259</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		auto const state = m_piece_map[piece].download_queue();
		if (state == piece_pos::piece_open) return;
		auto const i = find_dl_piece(state, piece);
		if (i == m_downloads[state].end()) return;

		TORRENT_ASSERT(i-&gt;passed_hash_check == false);
		if (i-&gt;passed_hash_check)
		{
			// it's not clear why this would happen,
			// but it seems reasonable to not break the
			// accounting over it.
			i-&gt;passed_hash_check = false;
			TORRENT_ASSERT(m_num_passed &gt; 0);
			--m_num_passed;
		}

		// prevent this piece from being picked until it's restored
		i-&gt;locked = true;
	}

<div style="background: #ffff00" width="100%">	void piece_picker::write_failed(piece_block const block)
</div>	{
		INVARIANT_CHECK;

#if TORRENT_USE_INVARIANT_CHECKS
		check_piece_state();
#endif

#ifdef TORRENT_PICKER_LOG
		std::cerr &lt;&lt; "[" &lt;&lt; this &lt;&lt; "] " &lt;&lt; "write_failed( {" &lt;&lt; block.piece_index &lt;&lt; ", " &lt;&lt; block.block_index &lt;&lt; "} )" &lt;&lt; std::endl;
#endif

		auto const state = m_piece_map[block.piece_index].download_queue();
		if (state == piece_pos::piece_open) return;
		auto i = find_dl_piece(state, block.piece_index);
		if (i == m_downloads[state].end()) return;

		auto const binfo = mutable_blocks_for_piece(*i);
		block_info&amp; info = binfo[block.block_index];
		TORRENT_ASSERT(&amp;info &gt;= &amp;m_block_info[0]);
		TORRENT_ASSERT(&amp;info &lt; &amp;m_block_info[0] + m_block_info.size());
		TORRENT_ASSERT(info.piece_index == block.piece_index);
		TORRENT_ASSERT(info.state == block_info::state_writing);
		TORRENT_ASSERT(info.num_peers == 0);

		TORRENT_ASSERT(i-&gt;writing &gt; 0);
		TORRENT_ASSERT(info.state == block_info::state_writing);

		if (info.state == block_info::state_finished) return;
		if (info.state == block_info::state_writing) --i-&gt;writing;

</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(82)">../src/storage_utils.cpp:350</a></td><td>technically, this is where the transaction of moving the files is completed. This is where the new save_path should be committed. If there is an error in the code below, that should not prevent the new save path to be set. Maybe it would make sense to make the save_path an in-out parameter</td></tr><tr id="82" style="display: none;" colspan="3"><td colspan="3"><h2>technically, this is where the transaction of moving the files
is completed. This is where the new save_path should be committed. If
there is an error in the code below, that should not prevent the new
save path to be set. Maybe it would make sense to make the save_path
an in-out parameter</h2><h4>../src/storage_utils.cpp:350</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			while (--file_index &gt;= file_index_t(0))
			{
				// files moved out to absolute paths are not moved
				if (f.file_absolute_path(file_index)) continue;

				// if we ended up copying the file, don't do anything during
				// roll-back
				if (copied_files[file_index]) continue;

				std::string const old_path = combine_path(save_path, f.file_path(file_index));
				std::string const new_path = combine_path(new_save_path, f.file_path(file_index));

				// ignore errors when rolling back
				error_code ignore;
				move_file(new_path, old_path, ignore);
			}

			return { status_t::fatal_disk_error, save_path };
		}

<div style="background: #ffff00" width="100%">
</div>		std::set&lt;std::string&gt; subdirs;
		for (auto const i : f.file_range())
		{
			// files moved out to absolute paths are not moved
			if (f.file_absolute_path(i)) continue;

			if (has_parent_path(f.file_path(i)))
				subdirs.insert(parent_path(f.file_path(i)));

			// if we ended up renaming the file instead of moving it, there's no
			// need to delete the source.
			if (copied_files[i] == false) continue;

			std::string const old_path = combine_path(save_path, f.file_path(i));

			// we may still have some files in old save_path
			// eg. if (flags == dont_replace &amp;&amp; exists(new_path))
			// ignore errors when removing
			error_code ignore;
			remove(old_path, ignore);
		}

		for (std::string const&amp; s : subdirs)
		{
			error_code err;
			std::string subdir = combine_path(save_path, s);

			while (!compare_path(subdir, save_path) &amp;&amp; !err)
			{
				remove(subdir, err);
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(83)">../src/storage_utils.cpp:495</a></td><td>is this risky? The upper layer will assume we have the whole file. Perhaps we should verify that at least the size of the file is correct</td></tr><tr id="83" style="display: none;" colspan="3"><td colspan="3"><h2>is this risky? The upper layer will assume we have the
whole file. Perhaps we should verify that at least the size
of the file is correct</h2><h4>../src/storage_utils.cpp:495</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		if (!links.empty())
		{
			TORRENT_ASSERT(int(links.size()) == fs.num_files());
			// if this is a mutable torrent, and we need to pick up some files
			// from other torrents, do that now. Note that there is an inherent
			// race condition here. We checked if the files existed on a different
			// thread a while ago. These files may no longer exist or may have been
			// moved. If so, we just fail. The user is responsible to not touch
			// other torrents until a new mutable torrent has been completely
			// added.
			for (auto const idx : fs.file_range())
			{
				std::string const&amp; s = links[idx];
				if (s.empty()) continue;

				error_code err;
				std::string file_path = fs.file_path(idx, save_path);
				hard_link(s, file_path, err);

				// if the file already exists, that's not an error
<div style="background: #ffff00" width="100%">				if (!err || err == boost::system::errc::file_exists)
</div>					continue;

				ec.ec = err;
				ec.file(idx);
				ec.operation = operation_t::file_hard_link;
				return false;
			}
		}
#endif // TORRENT_DISABLE_MUTABLE_TORRENTS

		bool const seed = rd.have_pieces.all_set()
			&amp;&amp; rd.have_pieces.size() &gt;= fs.num_pieces();

		// parse have bitmask. Verify that the files we expect to have
		// actually do exist
		for (piece_index_t i(0); i &lt; piece_index_t(rd.have_pieces.size()); ++i)
		{
			if (rd.have_pieces.get_bit(i) == false) continue;

			std::vector&lt;file_slice&gt; f = fs.map_block(i, 0, 1);
			TORRENT_ASSERT(!f.empty());

			file_index_t const file_index = f[0].file_index;

			// files with priority zero may not have been saved to disk at their
			// expected location, but is likely to be in a partfile. Just exempt it
			// from checking
			if (file_index &lt; file_priority.end_index()
				&amp;&amp; file_priority[file_index] == dont_download)
				continue;
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(84)">../src/web_peer_connection.cpp:576</a></td><td>just make this peer not have the pieces associated with the file we just requested. Only when it doesn't have any of the file do the following pad files will make it complicated</td></tr><tr id="84" style="display: none;" colspan="3"><td colspan="3"><h2>just make this peer not have the pieces
associated with the file we just requested. Only
when it doesn't have any of the file do the following
pad files will make it complicated</h2><h4>../src/web_peer_connection.cpp:576</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
	peer_connection::received_invalid_data(index, single_peer);

	// if we don't think we have any of the files, allow banning the web seed
	if (num_have_pieces() == 0) return true;

	// don't disconnect, we won't request anything from this file again
	return false;
}

void web_peer_connection::on_receive_padfile()
{
	handle_padfile();
}

void web_peer_connection::handle_error(int const bytes_left)
{
	std::shared_ptr&lt;torrent&gt; t = associated_torrent().lock();
	TORRENT_ASSERT(t);

<div style="background: #ffff00" width="100%">	auto const retry_time = value_or(m_parser.header_duration("retry-after")
</div>		, seconds32(m_settings.get_int(settings_pack::urlseed_wait_retry)));
	// temporarily unavailable, retry later
	t-&gt;retry_web_seed(this, retry_time);
	if (t-&gt;alerts().should_post&lt;url_seed_alert&gt;())
	{
		std::string const error_msg = to_string(m_parser.status_code()).data()
			+ (" " + m_parser.message());
		t-&gt;alerts().emplace_alert&lt;url_seed_alert&gt;(t-&gt;get_handle(), m_url
			, error_msg);
	}
	received_bytes(0, bytes_left);
	disconnect(error_code(m_parser.status_code(), http_category()), operation_t::bittorrent, failure);
}

void web_peer_connection::handle_redirect(int const bytes_left)
{
	// this means we got a redirection request
	// look for the location header
	std::string location = m_parser.header("location");
	received_bytes(0, bytes_left);

	std::shared_ptr&lt;torrent&gt; t = associated_torrent().lock();
	TORRENT_ASSERT(t);

	if (location.empty())
	{
		// we should not try this server again.
		t-&gt;remove_web_seed_conn(this, errors::missing_location, operation_t::bittorrent, peer_error);
		m_web = nullptr;
		TORRENT_ASSERT(is_disconnecting());
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(85)">../src/escape_string.cpp:199</a></td><td>this should probably be moved into string_util.cpp</td></tr><tr id="85" style="display: none;" colspan="3"><td colspan="3"><h2>this should probably be moved into string_util.cpp</h2><h4>../src/escape_string.cpp:199</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		{
			if (std::strchr(unreserved_chars, *str) == nullptr || *str == 0)
				return true;
			++str;
		}
		return false;
	}

	void convert_path_to_posix(std::string&amp; path)
	{
		std::replace(path.begin(), path.end(), '\\', '/');
	}

#ifdef TORRENT_WINDOWS
	void convert_path_to_windows(std::string&amp; path)
	{
		std::replace(path.begin(), path.end(), '/', '\\');
	}
#endif

<div style="background: #ffff00" width="100%">	std::string read_until(char const*&amp; str, char const delim, char const* end)
</div>	{
		TORRENT_ASSERT(str &lt;= end);

		std::string ret;
		while (str != end &amp;&amp; *str != delim)
		{
			ret += *str;
			++str;
		}
		// skip the delimiter as well
		while (str != end &amp;&amp; *str == delim) ++str;
		return ret;
	}

	std::string maybe_url_encode(std::string const&amp; url)
	{
		std::string protocol, host, auth, path;
		int port;
		error_code ec;
		std::tie(protocol, auth, host, port, path) = parse_url_components(url, ec);
		if (ec) return url;

		// first figure out if this url contains unencoded characters
		if (!need_encoding(path.c_str(), int(path.size())))
			return url;

		std::string msg;
		std::string escaped_path { escape_path(path) };
		// reserve enough space so further append will
		// only copy values to existing location
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(86)">../src/tracker_manager.cpp:349</a></td><td>implement</td></tr><tr id="86" style="display: none;" colspan="3"><td colspan="3"><h2>implement</h2><h4>../src/tracker_manager.cpp:349</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#ifndef TORRENT_DISABLE_LOGGING
			if (m_ses.should_log())
			{
				m_ses.session_log("incoming UDP tracker packet from %s has invalid "
					"transaction ID (%x)", print_endpoint(ep).c_str()
					, transaction);
			}
#endif
			return false;
		}

		std::shared_ptr&lt;udp_tracker_connection&gt; const p = i-&gt;second;
		// on_receive() may remove the tracker connection from the list
		return p-&gt;on_receive(ep, buf);
	}

	void tracker_manager::incoming_error(error_code const&amp;
		, udp::endpoint const&amp;)
	{
		TORRENT_ASSERT(is_single_thread());
<div style="background: #ffff00" width="100%">	}
</div>
	bool tracker_manager::incoming_packet(char const* hostname
		, span&lt;char const&gt; const buf)
	{
		TORRENT_ASSERT(is_single_thread());
		// ignore packets smaller than 8 bytes
		if (buf.size() &lt; 16) return false;

		// the first word is the action, if it's not [0, 3]
		// it's not a valid udp tracker response
		span&lt;const char&gt; ptr = buf;
		std::uint32_t const action = aux::read_uint32(ptr);
		if (action &gt; 3) return false;

		std::uint32_t const transaction = aux::read_uint32(ptr);
		auto const i = m_udp_conns.find(transaction);

		if (i == m_udp_conns.end())
		{
#ifndef TORRENT_DISABLE_LOGGING
			// now, this may not have been meant to be a tracker response,
			// but chances are pretty good, so it's probably worth logging
			m_ses.session_log("incoming UDP tracker packet from %s has invalid "
				"transaction ID (%x)", hostname, int(transaction));
#endif
			return false;
		}

		std::shared_ptr&lt;udp_tracker_connection&gt; const p = i-&gt;second;
		// on_receive() may remove the tracker connection from the list
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(87)">../src/alert.cpp:1681</a></td><td>the salt here is allocated on the heap. It would be nice to allocate in in the stack_allocator</td></tr><tr id="87" style="display: none;" colspan="3"><td colspan="3"><h2>the salt here is allocated on the heap. It would be nice to
allocate in in the stack_allocator</h2><h4>../src/alert.cpp:1681</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			, operation_name(op)
			, error.value()
			, convert_from_native(error.message()).c_str());
		return msg;
	}

	dht_immutable_item_alert::dht_immutable_item_alert(aux::stack_allocator&amp;
		, sha1_hash const&amp; t, entry const&amp; i)
		: target(t), item(i)
	{}

	std::string dht_immutable_item_alert::message() const
	{
		char msg[1050];
		std::snprintf(msg, sizeof(msg), "DHT immutable item %s [ %s ]"
			, aux::to_hex(target).c_str()
			, item.to_string().c_str());
		return msg;
	}

<div style="background: #ffff00" width="100%">	dht_mutable_item_alert::dht_mutable_item_alert(aux::stack_allocator&amp;
</div>		, std::array&lt;char, 32&gt; const&amp; k
		, std::array&lt;char, 64&gt; const&amp; sig
		, std::int64_t sequence
		, string_view s
		, entry const&amp; i
		, bool a)
		: key(k), signature(sig), seq(sequence), salt(s), item(i), authoritative(a)
	{}

	std::string dht_mutable_item_alert::message() const
	{
		char msg[1050];
		std::snprintf(msg, sizeof(msg), "DHT mutable item (key=%s salt=%s seq=%" PRId64 " %s) [ %s ]"
			, aux::to_hex(key).c_str()
			, salt.c_str()
			, seq
			, authoritative ? "auth" : "non-auth"
			, item.to_string().c_str());
		return msg;
	}

	dht_put_alert::dht_put_alert(aux::stack_allocator&amp;, sha1_hash const&amp; t, int n)
		: target(t)
		, public_key()
		, signature()
		, salt()
		, seq(0)
		, num_success(n)
	{}

</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(88)">../src/block_cache.cpp:1614</a></td><td>turn these return values into enums returns -1: block not in cache -2: out of memory</td></tr><tr id="88" style="display: none;" colspan="3"><td colspan="3"><h2>turn these return values into enums
returns
-1: block not in cache
-2: out of memory</h2><h4>../src/block_cache.cpp:1614</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			else
			{
				TORRENT_PIECE_ASSERT(!p.blocks[k].dirty, &amp;p);
				TORRENT_PIECE_ASSERT(!p.blocks[k].pending, &amp;p);
				TORRENT_PIECE_ASSERT(p.blocks[k].refcount == 0, &amp;p);
			}
			num_refcount += p.blocks[k].refcount;
		}
		TORRENT_PIECE_ASSERT(num_blocks == p.num_blocks, &amp;p);
		TORRENT_PIECE_ASSERT(num_pending &lt;= p.refcount, &amp;p);
		TORRENT_PIECE_ASSERT(num_refcount == p.refcount, &amp;p);
		TORRENT_PIECE_ASSERT(num_dirty == p.num_dirty, &amp;p);
	}
	TORRENT_ASSERT(m_read_cache_size == cached_read_blocks);
	TORRENT_ASSERT(m_write_cache_size == cached_write_blocks);
	TORRENT_ASSERT(m_pinned_blocks == num_pinned);
	TORRENT_ASSERT(m_write_cache_size + m_read_cache_size &lt;= in_use());
}
#endif

<div style="background: #ffff00" width="100%">
</div>int block_cache::copy_from_piece(cached_piece_entry* const pe
	, disk_io_job* const j, buffer_allocator_interface&amp; allocator
	, bool const expect_no_fail)
{
	INVARIANT_CHECK;
	TORRENT_UNUSED(expect_no_fail);

	TORRENT_PIECE_ASSERT(pe-&gt;in_use, pe);

	// copy from the cache and update the last use timestamp
	int block = j-&gt;d.io.offset / default_block_size;
	int block_offset = j-&gt;d.io.offset &amp; (default_block_size - 1);
	int buffer_offset = 0;
	int size = j-&gt;d.io.buffer_size;
	int const blocks_to_read = block_offset &gt; 0 &amp;&amp; (size &gt; default_block_size - block_offset) ? 2 : 1;
	TORRENT_PIECE_ASSERT(size &lt;= default_block_size, pe);
	int const start_block = block;

#if TORRENT_USE_ASSERTS
	int const piece_size = j-&gt;storage-&gt;files().piece_size(j-&gt;piece);
	int const blocks_in_piece = (piece_size + default_block_size - 1) / default_block_size;
	TORRENT_PIECE_ASSERT(start_block &lt; blocks_in_piece, pe);
#endif

	// if there's no buffer, we don't have this block in
	// the cache, and we're not currently reading it in either
	// since it's not pending

	if (inc_block_refcount(pe, start_block, ref_reading) == false)
	{
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(89)">../src/kademlia/node.cpp:675</a></td><td>it would be nice to have a bias towards node-id prefixes that are missing in the bucket</td></tr><tr id="89" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to have a bias towards node-id prefixes that
are missing in the bucket</h2><h4>../src/kademlia/node.cpp:675</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	node_entry const* ne = m_table.next_refresh();
	if (ne == nullptr) return;

	// this shouldn't happen
	TORRENT_ASSERT(m_id != ne-&gt;id);
	if (ne-&gt;id == m_id) return;

	int const bucket = 159 - distance_exp(m_id, ne-&gt;id);
	TORRENT_ASSERT(bucket &lt; 160);
	send_single_refresh(ne-&gt;ep(), bucket, ne-&gt;id);
}

void node::send_single_refresh(udp::endpoint const&amp; ep, int const bucket
	, node_id const&amp; id)
{
	TORRENT_ASSERT(id != m_id);
	TORRENT_ASSERT(bucket &gt;= 0);
	TORRENT_ASSERT(bucket &lt;= 159);

	// generate a random node_id within the given bucket
<div style="background: #ffff00" width="100%">	node_id mask = generate_prefix_mask(bucket + 1);
</div>	node_id target = generate_secret_id() &amp; ~mask;
	target |= m_id &amp; mask;

	// create a dummy traversal_algorithm
	auto algo = std::make_shared&lt;traversal_algorithm&gt;(*this, node_id());
	auto o = m_rpc.allocate_observer&lt;ping_observer&gt;(std::move(algo), ep, id);
	if (!o) return;
#if TORRENT_USE_ASSERTS
	o-&gt;m_in_constructor = false;
#endif
	entry e;
	e["y"] = "q";

	if (m_table.is_full(bucket))
	{
		// current bucket is full, just ping it.
		e["q"] = "ping";
		m_counters.inc_stats_counter(counters::dht_ping_out);
	}
	else
	{
		// use get_peers instead of find_node. We'll get nodes in the response
		// either way.
		e["q"] = "get_peers";
		e["a"]["info_hash"] = target.to_string();
		m_counters.inc_stats_counter(counters::dht_get_peers_out);
	}

	m_rpc.invoke(e, ep, o);
}
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(90)">../src/kademlia/node.cpp:744</a></td><td>use the non deprecated function instead of this one</td></tr><tr id="90" style="display: none;" colspan="3"><td colspan="3"><h2>use the non deprecated function instead of this one</h2><h4>../src/kademlia/node.cpp:744</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	std::lock_guard&lt;std::mutex&gt; l(m_mutex);

	m_table.status(table);

	for (auto const&amp; r : m_running_requests)
	{
		requests.emplace_back();
		dht_lookup&amp; lookup = requests.back();
		r-&gt;status(lookup);
	}
}

std::tuple&lt;int, int, int&gt; node::get_stats_counters() const
{
	int nodes, replacements;
	std::tie(nodes, replacements, std::ignore) = size();
	return std::make_tuple(nodes, replacements, m_rpc.num_allocated_observers());
}

#if TORRENT_ABI_VERSION == 1
<div style="background: #ffff00" width="100%">void node::status(session_status&amp; s)
</div>{
	std::lock_guard&lt;std::mutex&gt; l(m_mutex);

	m_table.status(s);
	s.dht_total_allocations += m_rpc.num_allocated_observers();
	for (auto&amp; r : m_running_requests)
	{
		s.active_requests.emplace_back();
		dht_lookup&amp; lookup = s.active_requests.back();
		r-&gt;status(lookup);
	}
}
#endif

bool node::lookup_peers(sha1_hash const&amp; info_hash, entry&amp; reply
	, bool noseed, bool scrape, address const&amp; requester) const
{
	if (m_observer)
		m_observer-&gt;get_peers(info_hash);

	return m_storage.get_peers(info_hash, noseed, scrape, requester, reply);
}

entry write_nodes_entry(std::vector&lt;node_entry&gt; const&amp; nodes)
{
	entry r;
	std::back_insert_iterator&lt;std::string&gt; out(r.string());
	for (auto const&amp; n : nodes)
	{
		std::copy(n.id.begin(), n.id.end(), out);
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(91)">../src/kademlia/routing_table.cpp:143</a></td><td>use the non deprecated function instead of this one</td></tr><tr id="91" style="display: none;" colspan="3"><td colspan="3"><h2>use the non deprecated function instead of this one</h2><h4>../src/kademlia/routing_table.cpp:143</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	if (!m_settings.extended_routing_table) return m_bucket_size;

	static const aux::array&lt;int, 4&gt; size_exceptions{{{16, 8, 4, 2}}};
	if (bucket &lt; size_exceptions.end_index())
		return m_bucket_size * size_exceptions[bucket];
	return m_bucket_size;
}

void routing_table::status(std::vector&lt;dht_routing_bucket&gt;&amp; s) const
{
	for (auto const&amp; i : m_buckets)
	{
		dht_routing_bucket b;
		b.num_nodes = int(i.live_nodes.size());
		b.num_replacements = int(i.replacements.size());
		s.push_back(b);
	}
}

#if TORRENT_ABI_VERSION == 1
<div style="background: #ffff00" width="100%">void routing_table::status(session_status&amp; s) const
</div>{
	int dht_nodes;
	int dht_node_cache;
	int ignore;
	std::tie(dht_nodes, dht_node_cache, ignore) = size();
	s.dht_nodes += dht_nodes;
	s.dht_node_cache += dht_node_cache;
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(92)">../src/kademlia/routing_table.cpp:875</a></td><td>move the lowest priority nodes to the replacement bucket</td></tr><tr id="92" style="display: none;" colspan="3"><td colspan="3"><h2>move the lowest priority nodes to the replacement bucket</h2><h4>../src/kademlia/routing_table.cpp:875</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	bucket_t&amp; rb = m_buckets[bucket_index].replacements;

	// move any node whose (160 - distance_exp(m_id, id)) &gt;= (i - m_buckets.begin())
	// to the new bucket
	int const new_bucket_size = bucket_limit(bucket_index + 1);
	for (auto j = b.begin(); j != b.end();)
	{
		int const d = distance_exp(m_id, j-&gt;id);
		if (d &gt;= 159 - bucket_index)
		{
			++j;
			continue;
		}
		// this entry belongs in the new bucket
		new_bucket.push_back(*j);
		j = b.erase(j);
	}

	if (int(b.size()) &gt; bucket_size_limit)
	{
<div style="background: #ffff00" width="100%">		for (auto i = b.begin() + bucket_size_limit
</div>			, end(b.end()); i != end; ++i)
		{
			rb.push_back(*i);
		}

		b.resize(bucket_size_limit);
	}

	// split the replacement bucket as well. If the live bucket
	// is not full anymore, also move the replacement entries
	// into the main bucket
	for (auto j = rb.begin(); j != rb.end();)
	{
		if (distance_exp(m_id, j-&gt;id) &gt;= 159 - bucket_index)
		{
			if (!j-&gt;pinged() || int(b.size()) &gt;= bucket_size_limit)
			{
				++j;
				continue;
			}
			b.push_back(*j);
		}
		else
		{
			// this entry belongs in the new bucket
			if (j-&gt;pinged() &amp;&amp; int(new_bucket.size()) &lt; new_bucket_size)
				new_bucket.push_back(*j);
			else
				new_replacement_bucket.push_back(*j);
		}
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(93)">../src/kademlia/dht_storage.cpp:82</a></td><td>make this configurable in dht_settings</td></tr><tr id="93" style="display: none;" colspan="3"><td colspan="3"><h2>make this configurable in dht_settings</h2><h4>../src/kademlia/dht_storage.cpp:82</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		tcp::endpoint addr;
		bool seed = 0;
	};

	// internal
	bool operator&lt;(peer_entry const&amp; lhs, peer_entry const&amp; rhs)
	{
		return lhs.addr.address() == rhs.addr.address()
			? lhs.addr.port() &lt; rhs.addr.port()
			: lhs.addr.address() &lt; rhs.addr.address();
	}

	// this is a group. It contains a set of group members
	struct torrent_entry
	{
		std::string name;
		std::vector&lt;peer_entry&gt; peers4;
		std::vector&lt;peer_entry&gt; peers6;
	};

<div style="background: #ffff00" width="100%">	constexpr time_duration announce_interval = minutes(30);
</div>
	struct dht_immutable_item
	{
		// the actual value
		std::unique_ptr&lt;char[]&gt; value;
		// this counts the number of IPs we have seen
		// announcing this item, this is used to determine
		// popularity if we reach the limit of items to store
		bloom_filter&lt;128&gt; ips;
		// the last time we heard about this item
		// the correct interpretation of this field
		// requires a time reference
		time_point last_seen;
		// number of IPs in the bloom filter
		int num_announcers = 0;
		// size of malloced space pointed to by value
		int size = 0;
	};

	struct dht_mutable_item : dht_immutable_item
	{
		signature sig{};
		sequence_number seq{};
		public_key key{};
		std::string salt;
	};

	void set_value(dht_immutable_item&amp; item, span&lt;char const&gt; buf)
	{
		int const size = int(buf.size());
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(94)">../include/libtorrent/chained_buffer.hpp:59</a></td><td>this type should probably be renamed to send_buffer</td></tr><tr id="94" style="display: none;" colspan="3"><td colspan="3"><h2>this type should probably be renamed to send_buffer</h2><h4>../include/libtorrent/chained_buffer.hpp:59</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#include "libtorrent/debug.hpp"
#include "libtorrent/buffer.hpp"

#include &lt;deque&gt;
#include &lt;vector&gt;

#include "libtorrent/aux_/disable_warnings_push.hpp"
#include &lt;boost/asio/buffer.hpp&gt;
#include "libtorrent/aux_/disable_warnings_pop.hpp"

#ifdef _MSC_VER
// visual studio requires the value in a deque to be copyable. C++11
// has looser requirements depending on which functions are actually used.
#define TORRENT_CPP98_DEQUE 1
#else
#define TORRENT_CPP98_DEQUE 0
#endif

namespace libtorrent {

<div style="background: #ffff00" width="100%">	struct TORRENT_EXTRA_EXPORT chained_buffer : private single_threaded
</div>	{
		chained_buffer(): m_bytes(0), m_capacity(0)
		{
			thread_started();
#if TORRENT_USE_ASSERTS
			m_destructed = false;
#endif
		}

	private:

		// destructs/frees the holder object
		using destruct_holder_fun = void (*)(void*);
		using move_construct_holder_fun = void (*)(void*, void*);

		struct buffer_t
		{
			buffer_t() {}
#if TORRENT_CPP98_DEQUE
			buffer_t(buffer_t&amp;&amp; rhs) noexcept
			{
				destruct_holder = rhs.destruct_holder;
				move_holder = rhs.move_holder;
				buf = rhs.buf;
				size = rhs.size;
				used_size = rhs.used_size;
				move_holder(&amp;holder, &amp;rhs.holder);
			}
			buffer_t&amp; operator=(buffer_t&amp;&amp; rhs) &amp; noexcept
			{
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(95)">../include/libtorrent/peer_connection.hpp:950</a></td><td>this should really be a circular buffer</td></tr><tr id="95" style="display: none;" colspan="3"><td colspan="3"><h2>this should really be a circular buffer</h2><h4>../include/libtorrent/peer_connection.hpp:950</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// it just serves as a queue to remember what we've sent, to avoid
		// re-sending suggests for the same piece
		// i.e. outgoing suggest pieces
		aux::vector&lt;piece_index_t&gt; m_suggest_pieces;

		// the pieces we will send to the peer
		// if requested (regardless of choke state)
		std::vector&lt;piece_index_t&gt; m_accept_fast;

		// a sent-piece counter for the allowed fast set
		// to avoid exploitation. Each slot is a counter
		// for one of the pieces from the allowed-fast set
		aux::vector&lt;std::uint16_t&gt; m_accept_fast_piece_cnt;

		// the pieces the peer will send us if
		// requested (regardless of choke state)
		std::vector&lt;piece_index_t&gt; m_allowed_fast;

		// pieces that has been suggested to be downloaded from this peer
		// i.e. incoming suggestions
<div style="background: #ffff00" width="100%">		aux::vector&lt;piece_index_t&gt; m_suggested_pieces;
</div>
		// the time when this peer last saw a complete copy
		// of this torrent
		time_t m_last_seen_complete = 0;

		// the block we're currently receiving. Or
		// (-1, -1) if we're not receiving one
		piece_block m_receiving_block = piece_block::invalid;

		// the local endpoint for this peer, i.e. our address
		// and our port. If this is set for outgoing connections
		// before the connection completes, it means we want to
		// force the connection to be bound to the specified interface.
		// if it ends up being bound to a different local IP, the connection
		// is closed.
		tcp::endpoint m_local;

		// remote peer's id
		peer_id m_peer_id;

	protected:

		template &lt;typename Fun, typename... Args&gt;
		void wrap(Fun f, Args&amp;&amp;... a);

		// statistics about upload and download speeds
		// and total amount of uploads and downloads for
		// this peer
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(96)">../include/libtorrent/peer_connection.hpp:1044</a></td><td>rename this target queue size</td></tr><tr id="96" style="display: none;" colspan="3"><td colspan="3"><h2>rename this target queue size</h2><h4>../include/libtorrent/peer_connection.hpp:1044</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// the number of bytes send to the disk-io
		// thread that hasn't yet been completely written.
		int m_outstanding_writing_bytes = 0;

		// max transfer rates seen on this peer
		int m_download_rate_peak = 0;
		int m_upload_rate_peak = 0;

		// when using the BitTyrant choker, this is our
		// estimated reciprocation rate. i.e. the rate
		// we need to send to this peer for it to unchoke
		// us
		int m_est_reciprocation_rate;

		// stop sending data after this many bytes, INT_MAX = inf
		int m_send_barrier = INT_MAX;

		// the number of request we should queue up
		// at the remote end.
<div style="background: #ffff00" width="100%">		std::uint16_t m_desired_queue_size = 4;
</div>
		// if set to non-zero, this peer will always prefer
		// to request entire n pieces, rather than blocks.
		// where n is the value of this variable.
		// if it is 0, the download rate limit setting
		// will be used to determine if whole pieces
		// are preferred.
		int m_prefer_contiguous_blocks = 0;

		// this is the number of times this peer has had
		// a request rejected because of a disk I/O failure.
		// once this reaches a certain threshold, the
		// peer is disconnected in order to avoid infinite
		// loops of consistent failures
		std::uint8_t m_disk_read_failures = 0;

		// this is used in seed mode whenever we trigger a hash check
		// for a piece, before we read it. It's used to throttle
		// the hash checks to just a few per peer at a time.
		std::uint8_t m_outstanding_piece_verification:3;

		// is true if it was we that connected to the peer
		// and false if we got an incoming connection
		// could be considered: true = local, false = remote
		bool m_outgoing:1;

		// is true if we learn the incoming connections listening
		// during the extended handshake
		bool m_received_listen_port:1;

</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(97)">../include/libtorrent/piece_picker.hpp:576</a></td><td>having 8 priority levels is probably excessive. It should probably be changed to 3 levels + dont-download</td></tr><tr id="97" style="display: none;" colspan="3"><td colspan="3"><h2>having 8 priority levels is probably excessive. It should
probably be changed to 3 levels + dont-download</h2><h4>../include/libtorrent/piece_picker.hpp:576</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				else if (state() == piece_full)
						state(piece_full_reverse);
			}

			// the number of peers that has this piece
			// (availability)
			std::uint32_t peer_count : 26;

			// one of the enums from state_t. This indicates whether this piece
			// is currently being downloaded or not, and what state it's in if
			// it is. Specifically, as an optimization, pieces that have all blocks
			// requested from them are separated out into separate lists to make
			// lookups quicker. The main oddity is that whether a downloading piece
			// has only been requested from peers that are reverse, that's
			// recorded as piece_downloading_reverse, which really means the same
			// as piece_downloading, it just saves space to also indicate that it
			// has a bit lower priority. The reverse bit is only relevant if the
			// state is piece_downloading.
			std::uint32_t download_state : 3;

<div style="background: #ffff00" width="100%">
</div>			// is 0 if the piece is filtered (not to be downloaded)
			// 1 is low priority
			// 2 is low priority
			// 3 is mid priority
			// 4 is default priority
			// 5 is mid priority
			// 6 is high priority
			// 7 is high priority
			std::uint32_t piece_priority : 3;

			// index in to the piece_info vector
			prio_index_t index;

#ifdef TORRENT_DEBUG_REFCOUNTS
			// all the peers that have this piece
			std::set&lt;const torrent_peer*&gt; have_peers;
#endif

			// index is set to this to indicate that we have the
			// piece. There is no entry for the piece in the
			// buckets if this is the case.
			static constexpr prio_index_t we_have_index{-1};

			// the priority value that means the piece is filtered
			static constexpr std::uint32_t filter_priority = 0;

			// the max number the peer count can hold
			static constexpr std::uint32_t max_peer_count = 0xffff;

			bool have() const { return index == we_have_index; }
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(98)">../include/libtorrent/session_handle.hpp:105</a></td><td>the ip filter should probably be saved here too loads and saves all session settings, including dht_settings, encryption settings and proxy settings. ``save_state`` writes all keys to the ``entry`` that's passed in, which needs to either not be initialized, or initialized as a dictionary.  ``load_state`` expects a bdecode_node which can be built from a bencoded buffer with bdecode().  The ``flags`` argument is used to filter which parts of the session state to save or load. By default, all state is saved/restored (except for the individual torrents).  When saving settings, there are two fields that are *not* loaded. ``peer_fingerprint`` and ``user_agent``. Those are left as configured by the ``session_settings`` passed to the session constructor or subsequently set via apply_settings().</td></tr><tr id="98" style="display: none;" colspan="3"><td colspan="3"><h2>the ip filter should probably be saved here too
loads and saves all session settings, including dht_settings,
encryption settings and proxy settings. ``save_state`` writes all keys
to the ``entry`` that's passed in, which needs to either not be
initialized, or initialized as a dictionary.

``load_state`` expects a bdecode_node which can be built from a bencoded
buffer with bdecode().

The ``flags`` argument is used to filter which parts of the session
state to save or load. By default, all state is saved/restored (except
for the individual torrents).

When saving settings, there are two fields that are *not* loaded.
``peer_fingerprint`` and ``user_agent``. Those are left as configured
by the ``session_settings`` passed to the session constructor or
subsequently set via apply_settings().</h2><h4>../include/libtorrent/session_handle.hpp:105</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// saves dht_settings
		static constexpr save_state_flags_t save_dht_settings = 1_bit;

		// saves dht state such as nodes and node-id, possibly accelerating
		// joining the DHT if provided at next session startup.
		static constexpr save_state_flags_t save_dht_state = 2_bit;

#if TORRENT_ABI_VERSION == 1
		// save pe_settings
		static constexpr save_state_flags_t TORRENT_DEPRECATED_MEMBER save_encryption_settings = 3_bit;
		static constexpr save_state_flags_t TORRENT_DEPRECATED_MEMBER save_as_map = 4_bit;
		static constexpr save_state_flags_t TORRENT_DEPRECATED_MEMBER save_proxy = 5_bit;
		static constexpr save_state_flags_t TORRENT_DEPRECATED_MEMBER save_i2p_proxy = 6_bit;
		static constexpr save_state_flags_t TORRENT_DEPRECATED_MEMBER save_dht_proxy = 7_bit;
		static constexpr save_state_flags_t TORRENT_DEPRECATED_MEMBER save_peer_proxy = 8_bit;
		static constexpr save_state_flags_t TORRENT_DEPRECATED_MEMBER save_web_proxy = 9_bit;
		static constexpr save_state_flags_t TORRENT_DEPRECATED_MEMBER save_tracker_proxy = 10_bit;
#endif

<div style="background: #ffff00" width="100%">		void save_state(entry&amp; e, save_state_flags_t flags = save_state_flags_t::all()) const;
</div>		void load_state(bdecode_node const&amp; e, save_state_flags_t flags = save_state_flags_t::all());

		// .. note::
		// 	these calls are potentially expensive and won't scale well with
		// 	lots of torrents. If you're concerned about performance, consider
		// 	using ``post_torrent_updates()`` instead.
		//
		// ``get_torrent_status`` returns a vector of the torrent_status for
		// every torrent which satisfies ``pred``, which is a predicate function
		// which determines if a torrent should be included in the returned set
		// or not. Returning true means it should be included and false means
		// excluded. The ``flags`` argument is the same as to
		// ``torrent_handle::status()``. Since ``pred`` is guaranteed to be
		// called for every torrent, it may be used to count the number of
		// torrents of different categories as well.
		//
		// ``refresh_torrent_status`` takes a vector of torrent_status structs
		// (for instance the same vector that was returned by
		// get_torrent_status() ) and refreshes the status based on the
		// ``handle`` member. It is possible to use this function by first
		// setting up a vector of default constructed ``torrent_status`` objects,
		// only initializing the ``handle`` member, in order to request the
		// torrent status for multiple torrents in a single call. This can save a
		// significant amount of time if you have a lot of torrents.
		//
		// Any torrent_status object whose ``handle`` member is not referring to
		// a valid torrent are ignored.
		std::vector&lt;torrent_status&gt; get_torrent_status(
			std::function&lt;bool(torrent_status const&amp;)&gt; const&amp; pred
			, status_flags_t flags = {}) const;
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(99)">../include/libtorrent/enum_net.hpp:144</a></td><td>this could be done more efficiently by just looking up the interface with the given name, maybe even with if_nametoindex()</td></tr><tr id="99" style="display: none;" colspan="3"><td colspan="3"><h2>this could be done more efficiently by just looking up
the interface with the given name, maybe even with if_nametoindex()</h2><h4>../include/libtorrent/enum_net.hpp:144</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			// IPv6 address. If we're asking to be bound to an IPv6 address and
			// providing 0.0.0.0 as the device, turn it into "::"
			if (ip == address_v4::any() &amp;&amp; protocol == boost::asio::ip::tcp::v6())
				ip = address_v6::any();
			bind_ep.address(ip);
			// it appears to be an IP. Just bind to that address
			sock.bind(bind_ep, ec);
			return bind_ep.address();
		}

		ec.clear();

#if TORRENT_HAS_BINDTODEVICE
		// try to use SO_BINDTODEVICE here, if that exists. If it fails,
		// fall back to the mechanism we have below
		sock.set_option(aux::bind_to_device(device_name), ec);
		if (ec)
#endif
		{
			ec.clear();
<div style="background: #ffff00" width="100%">			std::vector&lt;ip_interface&gt; ifs = enum_net_interfaces(ios, ec);
</div>			if (ec) return bind_ep.address();

			bool found = false;

			for (auto const&amp; iface : ifs)
			{
				// we're looking for a specific interface, and its address
				// (which must be of the same family as the address we're
				// connecting to)
				if (std::strcmp(iface.name, device_name) != 0) continue;
				if (iface.interface_address.is_v4() != (protocol == boost::asio::ip::tcp::v4()))
					continue;

				bind_ep.address(iface.interface_address);
				found = true;
				break;
			}

			if (!found)
			{
				ec = error_code(boost::system::errc::no_such_device, generic_category());
				return bind_ep.address();
			}
		}
		sock.bind(bind_ep, ec);
		return bind_ep.address();
	}

	// returns the device name whose local address is ``addr``. If
	// no such device is found, an empty string is returned.
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(100)">../include/libtorrent/proxy_base.hpp:274</a></td><td>use the resolver interface that has a built-in cache</td></tr><tr id="100" style="display: none;" colspan="3"><td colspan="3"><h2>use the resolver interface that has a built-in cache</h2><h4>../include/libtorrent/proxy_base.hpp:274</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		return m_sock.lowest_layer();
	}

	next_layer_type&amp; next_layer()
	{
		return m_sock;
	}

	bool is_open() const { return m_sock.is_open(); }

protected:

	bool handle_error(error_code const&amp; e, handler_type const&amp; h);

	tcp::socket m_sock;
	std::string m_hostname; // proxy host
	int m_port;             // proxy port

	endpoint_type m_remote_endpoint;

<div style="background: #ffff00" width="100%">	tcp::resolver m_resolver;
</div>};

}

#endif
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(101)">../include/libtorrent/broadcast_socket.hpp:50</a></td><td>factor these functions out</td></tr><tr id="101" style="display: none;" colspan="3"><td colspan="3"><h2>factor these functions out</h2><h4>../include/libtorrent/broadcast_socket.hpp:50</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
*/

#ifndef TORRENT_BROADCAST_SOCKET_HPP_INCLUDED
#define TORRENT_BROADCAST_SOCKET_HPP_INCLUDED

#include "libtorrent/config.hpp"
#include "libtorrent/io_service_fwd.hpp"
#include "libtorrent/socket.hpp"
#include "libtorrent/address.hpp"
#include "libtorrent/error_code.hpp"
#include "libtorrent/string_view.hpp"
#include "libtorrent/span.hpp"

#include &lt;memory&gt;
#include &lt;list&gt;
#include &lt;array&gt;

namespace libtorrent {

<div style="background: #ffff00" width="100%">	TORRENT_EXTRA_EXPORT bool is_local(address const&amp; a);
</div>	TORRENT_EXTRA_EXPORT bool is_loopback(address const&amp; addr);
	TORRENT_EXTRA_EXPORT bool is_any(address const&amp; addr);
	TORRENT_EXTRA_EXPORT bool is_teredo(address const&amp; addr);
	TORRENT_EXTRA_EXPORT bool is_ip_address(std::string const&amp; host);

</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(102)">../include/libtorrent/socks5_stream.hpp:137</a></td><td>add async_connect() that takes a hostname and port as well</td></tr><tr id="102" style="display: none;" colspan="3"><td colspan="3"><h2>add async_connect() that takes a hostname and port as well</h2><h4>../include/libtorrent/socks5_stream.hpp:137</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		TORRENT_ASSERT(!is_ip_address(host));
		m_dst_name = host;
		if (m_dst_name.size() &gt; 255)
			m_dst_name.resize(255);
	}

	void close(error_code&amp; ec)
	{
		m_dst_name.clear();
		proxy_base::close(ec);
	}

#ifndef BOOST_NO_EXCEPTIONS
	void close()
	{
		m_dst_name.clear();
		proxy_base::close();
	}
#endif

<div style="background: #ffff00" width="100%">	template &lt;class Handler&gt;
</div>	void async_connect(endpoint_type const&amp; endpoint, Handler const&amp; handler)
	{
		// make sure we don't try to connect to INADDR_ANY. binding is fine,
		// and using a hostname is fine on SOCKS version 5.
		TORRENT_ASSERT(endpoint.address() != address()
			|| (!m_dst_name.empty() &amp;&amp; m_version == 5));

		m_remote_endpoint = endpoint;

		// the connect is split up in the following steps:
		// 1. resolve name of proxy server
		// 2. connect to proxy server
		// 3. if version == 5:
		//   3.1 send SOCKS5 authentication method message
		//   3.2 read SOCKS5 authentication response
		//   3.3 send username+password
		// 4. send SOCKS command message

		using std::placeholders::_1;
		using std::placeholders::_2;
		ADD_OUTSTANDING_ASYNC("socks5_stream::name_lookup");
		tcp::resolver::query q(m_hostname, to_string(m_port).data());
		m_resolver.async_resolve(q, std::bind(
			&amp;socks5_stream::name_lookup, this, _1, _2, handler_type(std::move(handler))));
	}

private:

	void name_lookup(error_code const&amp; e, tcp::resolver::iterator i
		, handler_type h);
</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(103)">../include/libtorrent/aux_/session_interface.hpp:130</a></td><td>make this interface a lot smaller. It could be split up into several smaller interfaces. Each subsystem could then limit the size of the mock object to test it.</td></tr><tr id="103" style="display: none;" colspan="3"><td colspan="3"><h2>make this interface a lot smaller. It could be split up into
several smaller interfaces. Each subsystem could then limit the size
of the mock object to test it.</h2><h4>../include/libtorrent/aux_/session_interface.hpp:130</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// a release build with logging disabled (which is the default) will
	// not have this class at all
	struct TORRENT_EXTRA_EXPORT session_logger
	{
#ifndef TORRENT_DISABLE_LOGGING
		virtual bool should_log() const = 0;
		virtual void session_log(char const* fmt, ...) const TORRENT_FORMAT(2,3) = 0;
#endif

#if TORRENT_USE_ASSERTS
		virtual bool is_single_thread() const = 0;
		virtual bool has_peer(peer_connection const* p) const = 0;
		virtual bool any_torrent_has_peer(peer_connection const* p) const = 0;
		virtual bool is_posting_torrent_updates() const = 0;
#endif
	protected:
		~session_logger() {}
	};
#endif // TORRENT_DISABLE_LOGGING || TORRENT_USE_ASSERTS

<div style="background: #ffff00" width="100%">	struct TORRENT_EXTRA_EXPORT session_interface
</div>#if !defined TORRENT_DISABLE_LOGGING || TORRENT_USE_ASSERTS
		: session_logger
#endif
	{

</pre></td></tr><tr style="background: #cfc"><td>relevance&nbsp;2</td><td><a href="javascript:expand(104)">../include/libtorrent/aux_/session_interface.hpp:139</a></td><td>the IP voting mechanism should be factored out to its own class, not part of the session and these constants should move too</td></tr><tr id="104" style="display: none;" colspan="3"><td colspan="3"><h2>the IP voting mechanism should be factored out
to its own class, not part of the session
and these constants should move too</h2><h4>../include/libtorrent/aux_/session_interface.hpp:139</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		virtual void session_log(char const* fmt, ...) const TORRENT_FORMAT(2,3) = 0;
#endif

#if TORRENT_USE_ASSERTS
		virtual bool is_single_thread() const = 0;
		virtual bool has_peer(peer_connection const* p) const = 0;
		virtual bool any_torrent_has_peer(peer_connection const* p) const = 0;
		virtual bool is_posting_torrent_updates() const = 0;
#endif
	protected:
		~session_logger() {}
	};
#endif // TORRENT_DISABLE_LOGGING || TORRENT_USE_ASSERTS

	struct TORRENT_EXTRA_EXPORT session_interface
#if !defined TORRENT_DISABLE_LOGGING || TORRENT_USE_ASSERTS
		: session_logger
#endif
	{

<div style="background: #ffff00" width="100%">
</div>		// the logic in ip_voter relies on more reliable sources are represented
		// by more significant bits
		static constexpr ip_source_t source_dht = 1_bit;
		static constexpr ip_source_t source_peer = 2_bit;
		static constexpr ip_source_t source_tracker = 3_bit;
		static constexpr ip_source_t source_router = 4_bit;

		virtual void set_external_address(address const&amp; ip
			, ip_source_t source_type, address const&amp; source) = 0;
		virtual void set_external_address(tcp::endpoint const&amp; local_endpoint
			, address const&amp; ip
			, ip_source_t source_type, address const&amp; source) = 0;
		virtual external_ip external_address() const = 0;

		virtual disk_interface&amp; disk_thread() = 0;

		virtual alert_manager&amp; alerts() = 0;

		virtual torrent_peer_allocator_interface&amp; get_peer_allocator() = 0;
		virtual io_service&amp; get_io_service() = 0;
		virtual resolver_interface&amp; get_resolver() = 0;

		virtual bool has_connection(peer_connection* p) const = 0;
		virtual void insert_peer(std::shared_ptr&lt;peer_connection&gt; const&amp; c) = 0;

		virtual void remove_torrent(torrent_handle const&amp; h, remove_flags_t options = {}) = 0;
		virtual void remove_torrent_impl(std::shared_ptr&lt;torrent&gt; tptr, remove_flags_t options) = 0;

		// port filter
		virtual port_filter const&amp; get_port_filter() const = 0;
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(105)">../src/session_impl.cpp:5586</a></td><td>report the proper address of the router as the source IP of this vote of our external address, instead of the empty address</td></tr><tr id="105" style="display: none;" colspan="3"><td colspan="3"><h2>report the proper address of the router as the source IP of
this vote of our external address, instead of the empty address</h2><h4>../src/session_impl.cpp:5586</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// look through our listen sockets to see if this mapping is for one of
		// them (it could also be a user mapping)

		auto ls
			= std::find_if(m_listen_sockets.begin(), m_listen_sockets.end()
			, std::bind(find_tcp_port_mapping, transport, mapping, _1));

		bool tcp = true;
		if (ls == m_listen_sockets.end())
		{
			ls = std::find_if(m_listen_sockets.begin(), m_listen_sockets.end()
				, std::bind(find_udp_port_mapping, transport, mapping, _1));
			tcp = false;
		}

		if (ls != m_listen_sockets.end())
		{
			if (!ec &amp;&amp; ip != address())
			{
<div style="background: #ffff00" width="100%">				(*ls)-&gt;external_address.cast_vote(ip, source_router, address());
</div>			}

			if (tcp) (*ls)-&gt;tcp_external_port = port;
			else (*ls)-&gt;udp_external_port = port;
		}

		if (!ec &amp;&amp; m_alerts.should_post&lt;portmap_alert&gt;())
		{
			m_alerts.emplace_alert&lt;portmap_alert&gt;(mapping, port
				, transport, proto);
		}
	}

#if TORRENT_ABI_VERSION == 1
	session_status session_impl::status() const
	{
//		INVARIANT_CHECK;
		TORRENT_ASSERT(is_single_thread());

		session_status s;

		s.optimistic_unchoke_counter = m_optimistic_unchoke_time_scaler;
		s.unchoke_counter = m_unchoke_time_scaler;
		s.num_dead_peers = int(m_undead_peers.size());

		s.num_peers = int(m_stats_counters[counters::num_peers_connected]);
		s.num_unchoked = int(m_stats_counters[counters::num_peers_up_unchoked_all]);
		s.allowed_upload_slots = int(m_stats_counters[counters::num_unchoke_slots]);

		s.num_torrents
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(106)">../src/torrent.cpp:1150</a></td><td>make this depend on the error and on the filesystem the files are being downloaded to. If the error is no_space_left_on_device and the filesystem doesn't support sparse files, only zero the priorities of the pieces that are at the tails of all files, leaving everything up to the highest written piece in each file</td></tr><tr id="106" style="display: none;" colspan="3"><td colspan="3"><h2>make this depend on the error and on the filesystem the
files are being downloaded to. If the error is no_space_left_on_device
and the filesystem doesn't support sparse files, only zero the priorities
of the pieces that are at the tails of all files, leaving everything
up to the highest written piece in each file</h2><h4>../src/torrent.cpp:1150</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// notify the user of the error
		if (alerts().should_post&lt;file_error_alert&gt;())
			alerts().emplace_alert&lt;file_error_alert&gt;(error.ec
				, resolve_filename(error.file()), error.operation, get_handle());

		// if a write operation failed, and future writes are likely to
		// fail, while reads may succeed, just set the torrent to upload mode
		// if we make an incorrect assumption here, it's not the end of the
		// world, if we ever issue a read request and it fails as well, we
		// won't get in here and we'll actually end up pausing the torrent
		if (rw == disk_class::write
			&amp;&amp; (error.ec == boost::system::errc::read_only_file_system
			|| error.ec == boost::system::errc::permission_denied
			|| error.ec == boost::system::errc::operation_not_permitted
			|| error.ec == boost::system::errc::no_space_on_device
			|| error.ec == boost::system::errc::file_too_large))
		{
			// if we failed to write, stop downloading and just
			// keep seeding.
<div style="background: #ffff00" width="100%">			set_upload_mode(true);
</div>			return;
		}

		// put the torrent in an error-state
		set_error(error.ec, error.file());

		// if the error appears to be more serious than a full disk, just pause the torrent
		pause();
	}

	void torrent::on_piece_fail_sync(piece_index_t, piece_block) try
	{
		if (m_abort) return;

		update_gauge();
		// some peers that previously was no longer interesting may
		// now have become interesting, since we lack this one piece now.
		for (auto i = begin(); i != end();)
		{
			peer_connection* p = *i;
			// update_interest may disconnect the peer and
			// invalidate the iterator
			++i;
			// no need to do anything with peers that
			// already are interested. Gaining a piece may
			// only make uninteresting peers interesting again.
			if (p-&gt;is_interesting()) continue;
			p-&gt;update_interest();
			if (!m_abort)
			{
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(107)">../src/torrent.cpp:7272</a></td><td>should disconnect all peers that have the pieces we have not just seeds. It would be pretty expensive to check all pieces for all peers though</td></tr><tr id="107" style="display: none;" colspan="3"><td colspan="3"><h2>should disconnect all peers that have the pieces we have
not just seeds. It would be pretty expensive to check all pieces
for all peers though</h2><h4>../src/torrent.cpp:7272</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		set_state(torrent_status::finished);
		set_queue_position(no_pos);

		m_became_finished = aux::time_now32();

		// we have to call completed() before we start
		// disconnecting peers, since there's an assert
		// to make sure we're cleared the piece picker
		if (is_seed()) completed();

		send_upload_only();
		state_updated();

		if (m_completed_time == 0)
			m_completed_time = time(nullptr);

		// disconnect all seeds
		if (settings().get_bool(settings_pack::close_redundant_connections))
		{
<div style="background: #ffff00" width="100%">			std::vector&lt;peer_connection*&gt; seeds;
</div>			for (auto const p : m_connections)
			{
				TORRENT_INCREMENT(m_iterating_connections);
				TORRENT_ASSERT(p-&gt;associated_torrent().lock().get() == this);
				if (p-&gt;upload_only())
				{
#ifndef TORRENT_DISABLE_LOGGING
					p-&gt;peer_log(peer_log_alert::info, "SEED", "CLOSING CONNECTION");
#endif
					seeds.push_back(p);
				}
			}
			for (auto&amp; p : seeds)
				p-&gt;disconnect(errors::torrent_finished, operation_t::bittorrent
					, peer_connection_interface::normal);
		}

		if (m_abort) return;

		update_want_peers();

		if (m_storage)
		{
			// we need to keep the object alive during this operation
			m_ses.disk_thread().async_release_files(m_storage
				, std::bind(&amp;torrent::on_cache_flushed, shared_from_this(), false));
		}

		// this torrent just completed downloads, which means it will fall
		// under a different limit with the auto-manager. Make sure we
</pre></td></tr><tr style="background: #ccf"><td>relevance&nbsp;1</td><td><a href="javascript:expand(108)">../include/libtorrent/ip_voter.hpp:128</a></td><td>have one instance per possible subnet, 192.168.x.x, 10.x.x.x, etc.</td></tr><tr id="108" style="display: none;" colspan="3"><td colspan="3"><h2>have one instance per possible subnet, 192.168.x.x, 10.x.x.x, etc.</h2><h4>../include/libtorrent/ip_voter.hpp:128</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// stores one address for each combination of local/global and ipv4/ipv6
	// use of this class should be avoided, get the IP from the appropriate
	// listen interface wherever possible
	struct TORRENT_EXTRA_EXPORT external_ip
	{
		external_ip()
			: m_addresses{{address_v4(), address_v6()}, {address_v4(), address_v6()}}
		{}

		external_ip(address const&amp; local4, address const&amp; global4
			, address const&amp; local6, address const&amp; global6);

		// the external IP as it would be observed from `ip`
		address external_address(address const&amp; ip) const;

	private:

		// support one local and one global address per address family
		// [0][n] = global [1][n] = local
		// [n][0] = IPv4 [n][1] = IPv6
<div style="background: #ffff00" width="100%">		address m_addresses[2][2];
</div>	};

}

#endif
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(109)">../test/test_resume.cpp:403</a></td><td>test what happens when loading a resume file with both piece priorities and file priorities (file prio should take presedence)</td></tr><tr id="109" style="display: none;" colspan="3"><td colspan="3"><h2>test what happens when loading a resume file with both piece priorities
and file priorities (file prio should take presedence)</h2><h4>../test/test_resume.cpp:403</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		{
			TEST_EQUAL(pieces[i], true);
		}
	}
}

} // anonymous namespace

TORRENT_TEST(piece_slots_seed)
{
	test_piece_slots_seed(settings());
}

TORRENT_TEST(piece_slots_seed_suggest_cache)
{
	settings_pack sett = settings();
	sett.set_int(settings_pack::suggest_mode, settings_pack::suggest_read_cache);
	test_piece_slots_seed(sett);
}

<div style="background: #ffff00" width="100%">
</div></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(110)">../test/test_resume.cpp:406</a></td><td>make sure a resume file only ever contain file priorities OR piece priorities. Never both.</td></tr><tr id="110" style="display: none;" colspan="3"><td colspan="3"><h2>make sure a resume file only ever contain file priorities OR piece
priorities. Never both.</h2><h4>../test/test_resume.cpp:406</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			TEST_EQUAL(pieces[i], true);
		}
	}
}

} // anonymous namespace

TORRENT_TEST(piece_slots_seed)
{
	test_piece_slots_seed(settings());
}

TORRENT_TEST(piece_slots_seed_suggest_cache)
{
	settings_pack sett = settings();
	sett.set_int(settings_pack::suggest_mode, settings_pack::suggest_read_cache);
	test_piece_slots_seed(sett);
}


<div style="background: #ffff00" width="100%">
</div></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(111)">../test/test_resume.cpp:409</a></td><td>generally save</td></tr><tr id="111" style="display: none;" colspan="3"><td colspan="3"><h2>generally save</h2><h4>../test/test_resume.cpp:409</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		}
	}
}

} // anonymous namespace

TORRENT_TEST(piece_slots_seed)
{
	test_piece_slots_seed(settings());
}

TORRENT_TEST(piece_slots_seed_suggest_cache)
{
	settings_pack sett = settings();
	sett.set_int(settings_pack::suggest_mode, settings_pack::suggest_read_cache);
	test_piece_slots_seed(sett);
}



<div style="background: #ffff00" width="100%">
</div>#if TORRENT_ABI_VERSION == 1
TORRENT_TEST(file_priorities_default_deprecated)
{
	lt::session ses(settings());
	std::vector&lt;download_priority_t&gt; file_priorities = test_resume_flags(ses
		, {}, "", "", true).get_file_priorities();

	TEST_EQUAL(file_priorities.size(), 3);
	TEST_EQUAL(file_priorities[0], 4);
	TEST_EQUAL(file_priorities[1], 4);
	TEST_EQUAL(file_priorities[2], 4);
}

// As long as the add_torrent_params priorities are empty, the file_priorities
// from the resume data should take effect
TORRENT_TEST(file_priorities_in_resume_deprecated)
{
	lt::session ses(settings());
	std::vector&lt;download_priority_t&gt; file_priorities = test_resume_flags(ses, {}, "", "123").get_file_priorities();

	TEST_EQUAL(file_priorities.size(), 3);
	TEST_EQUAL(file_priorities[0], 1);
	TEST_EQUAL(file_priorities[1], 2);
	TEST_EQUAL(file_priorities[2], 3);
}

// if both resume data and add_torrent_params has file_priorities, the
// add_torrent_params one take precedence
TORRENT_TEST(file_priorities_in_resume_and_params_deprecated)
{
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(112)">../test/test_resume.cpp:725</a></td><td>test all other resume flags here too. This would require returning more than just the torrent_status from test_resume_flags. Also http seeds and trackers for instance</td></tr><tr id="112" style="display: none;" colspan="3"><td colspan="3"><h2>test all other resume flags here too. This would require returning
more than just the torrent_status from test_resume_flags. Also http seeds
and trackers for instance</h2><h4>../test/test_resume.cpp:725</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	TEST_EQUAL(s.flags &amp; flags_mask, torrent_flags_t{});
	TEST_EQUAL(s.connections_limit, 1345);
	TEST_EQUAL(s.uploads_limit, 1346);
}

TORRENT_TEST(paused_deprecated)
{
	lt::session ses(settings());
	// resume data overrides the paused flag
	torrent_status s = test_resume_flags(ses, torrent_flags::paused, "", "", true).status();
	default_tests(s);
#ifdef TORRENT_WINDOWS
	TEST_EQUAL(s.save_path, "c:\\add_torrent_params save_path");
#else
	TEST_EQUAL(s.save_path, "/add_torrent_params save_path");
#endif
	TEST_EQUAL(s.flags &amp; flags_mask, torrent_flags_t{});
	TEST_EQUAL(s.connections_limit, 1345);
	TEST_EQUAL(s.uploads_limit, 1346);

<div style="background: #ffff00" width="100%">}
</div>
TORRENT_TEST(url_seed_resume_data_deprecated)
{
	// merge url seeds with resume data
	std::printf("flags: merge_resume_http_seeds\n");
	lt::session ses(settings());
	torrent_handle h = test_resume_flags(ses,
		torrent_flags::merge_resume_http_seeds, "", "", true);
	std::set&lt;std::string&gt; us = h.url_seeds();
	std::set&lt;std::string&gt; ws = h.http_seeds();

	TEST_EQUAL(us.size(), 3);
	TEST_EQUAL(std::count(us.begin(), us.end()
		, "http://add_torrent_params_url_seed.com/"), 1);
	TEST_EQUAL(std::count(us.begin(), us.end()
		, "http://torrent_file_url_seed.com/"), 1);
	TEST_EQUAL(std::count(us.begin(), us.end()
		, "http://resume_data_url_seed.com/"), 1);

	TEST_EQUAL(ws.size(), 1);
	TEST_EQUAL(std::count(ws.begin(), ws.end()
		, "http://resume_data_http_seed.com"), 1);
}

TORRENT_TEST(resume_override_torrent_deprecated)
{
	// resume data overrides the .torrent_file
	std::printf("flags: no merge_resume_http_seed\n");
	lt::session ses(settings());
	torrent_handle h = test_resume_flags(ses,
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(113)">../test/test_resume.cpp:1287</a></td><td>test all other resume flags here too. This would require returning more than just the torrent_status from test_resume_flags. Also http seeds and trackers for instance</td></tr><tr id="113" style="display: none;" colspan="3"><td colspan="3"><h2>test all other resume flags here too. This would require returning
more than just the torrent_status from test_resume_flags. Also http seeds
and trackers for instance</h2><h4>../test/test_resume.cpp:1287</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	TEST_EQUAL(s.flags &amp; flags_mask, torrent_flags::auto_managed);
	TEST_EQUAL(s.connections_limit, 1345);
	TEST_EQUAL(s.uploads_limit, 1346);
}

TORRENT_TEST(paused)
{
	lt::session ses(settings());
	// resume data overrides the paused flag
	torrent_status s = test_resume_flags(ses, torrent_flags::paused).status();
	default_tests(s);
#ifdef TORRENT_WINDOWS
	TEST_EQUAL(s.save_path, "c:\\add_torrent_params save_path");
#else
	TEST_EQUAL(s.save_path, "/add_torrent_params save_path");
#endif
	TEST_EQUAL(s.flags &amp; flags_mask, torrent_flags::paused);
	TEST_EQUAL(s.connections_limit, 1345);
	TEST_EQUAL(s.uploads_limit, 1346);

<div style="background: #ffff00" width="100%">}
</div></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(114)">../test/test_ssl.cpp:401</a></td><td>test using a signed certificate with the wrong info-hash in DN</td></tr><tr id="114" style="display: none;" colspan="3"><td colspan="3"><h2>test using a signed certificate with the wrong info-hash in DN</h2><h4>../test/test_ssl.cpp:401</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// in verifying peers
	ctx.set_verify_mode(context::verify_none, ec);
	if (ec)
	{
		std::printf("Failed to set SSL verify mode: %s\n"
			, ec.message().c_str());
		TEST_CHECK(!ec);
		return false;
	}

	std::string certificate = combine_path("..", combine_path("ssl", "peer_certificate.pem"));
	std::string private_key = combine_path("..", combine_path("ssl", "peer_private_key.pem"));
	std::string dh_params = combine_path("..", combine_path("ssl", "dhparams.pem"));

	if (flags &amp; invalid_certificate)
	{
		certificate = combine_path("..", combine_path("ssl", "invalid_peer_certificate.pem"));
		private_key = combine_path("..", combine_path("ssl", "invalid_peer_private_key.pem"));
	}

<div style="background: #ffff00" width="100%">
</div>	if (flags &amp; (valid_certificate | invalid_certificate))
	{
		std::printf("set_password_callback\n");
		ctx.set_password_callback(std::bind(&amp;password_callback, _1, _2, "test"), ec);
		if (ec)
		{
			std::printf("Failed to set certificate password callback: %s\n"
				, ec.message().c_str());
			TEST_CHECK(!ec);
			return false;
		}
		std::printf("use_certificate_file \"%s\"\n", certificate.c_str());
		ctx.use_certificate_file(certificate, context::pem, ec);
		if (ec)
		{
			std::printf("Failed to set certificate file: %s\n"
				, ec.message().c_str());
			TEST_CHECK(!ec);
			return false;
		}
		std::printf("use_private_key_file \"%s\"\n", private_key.c_str());
		ctx.use_private_key_file(private_key, context::pem, ec);
		if (ec)
		{
			std::printf("Failed to set private key: %s\n"
				, ec.message().c_str());
			TEST_CHECK(!ec);
			return false;
		}
		std::printf("use_tmp_dh_file \"%s\"\n", dh_params.c_str());
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(115)">../test/test_ssl.cpp:499</a></td><td>also test using a hash that refers to a valid torrent but that differs from the SNI hash</td></tr><tr id="115" style="display: none;" colspan="3"><td colspan="3"><h2>also test using a hash that refers to a valid torrent
but that differs from the SNI hash</h2><h4>../test/test_ssl.cpp:499</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	print_alerts(ses1, "ses1", true, true, &amp;on_alert);
	if (ec)
	{
		std::printf("Failed SSL handshake: %s\n"
			, ec.message().c_str());
		return false;
	}

	char handshake[] = "\x13" "BitTorrent protocol\0\0\0\0\0\0\0\x04"
		"                    " // space for info-hash
		"aaaaaaaaaaaaaaaaaaaa" // peer-id
		"\0\0\0\x01\x02"; // interested

	// fill in the info-hash
	if (flags &amp; valid_bittorrent_hash)
	{
		std::memcpy(handshake + 28, &amp;t-&gt;info_hash()[0], 20);
	}
	else
	{
<div style="background: #ffff00" width="100%">		std::generate(handshake + 28, handshake + 48, &amp;rand);
</div>	}

	// fill in the peer-id
	std::generate(handshake + 48, handshake + 68, &amp;rand);

	std::printf("bittorrent handshake\n");
	boost::asio::write(ssl_sock, boost::asio::buffer(handshake, (sizeof(handshake) - 1)), ec);
	print_alerts(ses1, "ses1", true, true, &amp;on_alert);
	if (ec)
	{
		std::printf("failed to write bittorrent handshake: %s\n"
			, ec.message().c_str());
		return false;
	}

	char buf[68];
	std::printf("read bittorrent handshake\n");
	boost::asio::read(ssl_sock, boost::asio::buffer(buf, sizeof(buf)), ec);
	print_alerts(ses1, "ses1", true, true, &amp;on_alert);
	if (ec)
	{
		std::printf("failed to read bittorrent handshake: %s\n"
			, ec.message().c_str());
		return false;
	}

	if (memcmp(buf, "\x13" "BitTorrent protocol", 20) != 0)
	{
		std::printf("invalid bittorrent handshake\n");
		return false;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(116)">../test/test_peer_list.cpp:968</a></td><td>test erasing peers</td></tr><tr id="116" style="display: none;" colspan="3"><td colspan="3"><h2>test erasing peers</h2><h4>../test/test_peer_list.cpp:968</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(117)">../test/test_peer_list.cpp:969</a></td><td>test update_peer_port with allow_multiple_connections_per_ip and without</td></tr><tr id="117" style="display: none;" colspan="3"><td colspan="3"><h2>test update_peer_port with allow_multiple_connections_per_ip and without</h2><h4>../test/test_peer_list.cpp:969</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(118)">../test/test_peer_list.cpp:970</a></td><td>test add i2p peers</td></tr><tr id="118" style="display: none;" colspan="3"><td colspan="3"><h2>test add i2p peers</h2><h4>../test/test_peer_list.cpp:970</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(119)">../test/test_peer_list.cpp:971</a></td><td>test allow_i2p_mixed</td></tr><tr id="119" style="display: none;" colspan="3"><td colspan="3"><h2>test allow_i2p_mixed</h2><h4>../test/test_peer_list.cpp:971</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(120)">../test/test_peer_list.cpp:972</a></td><td>test insert_peer failing with all error conditions</td></tr><tr id="120" style="display: none;" colspan="3"><td colspan="3"><h2>test insert_peer failing with all error conditions</h2><h4>../test/test_peer_list.cpp:972</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(121)">../test/test_peer_list.cpp:973</a></td><td>test IPv6</td></tr><tr id="121" style="display: none;" colspan="3"><td colspan="3"><h2>test IPv6</h2><h4>../test/test_peer_list.cpp:973</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(122)">../test/test_peer_list.cpp:974</a></td><td>test connect_to_peer() failing</td></tr><tr id="122" style="display: none;" colspan="3"><td colspan="3"><h2>test connect_to_peer() failing</h2><h4>../test/test_peer_list.cpp:974</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(123)">../test/test_peer_list.cpp:975</a></td><td>test connection_closed</td></tr><tr id="123" style="display: none;" colspan="3"><td colspan="3"><h2>test connection_closed</h2><h4>../test/test_peer_list.cpp:975</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(124)">../test/test_peer_list.cpp:976</a></td><td>connect candidates recalculation when incrementing failcount</td></tr><tr id="124" style="display: none;" colspan="3"><td colspan="3"><h2>connect candidates recalculation when incrementing failcount</h2><h4>../test/test_peer_list.cpp:976</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(125)">../test/test_tracker.cpp:54</a></td><td>test scrape requests</td></tr><tr id="125" style="display: none;" colspan="3"><td colspan="3"><h2>test scrape requests</h2><h4>../test/test_tracker.cpp:54</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(126)">../test/test_tracker.cpp:55</a></td><td>test parse peers6</td></tr><tr id="126" style="display: none;" colspan="3"><td colspan="3"><h2>test parse peers6</h2><h4>../test/test_tracker.cpp:55</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(127)">../test/test_tracker.cpp:56</a></td><td>test parse tracker-id</td></tr><tr id="127" style="display: none;" colspan="3"><td colspan="3"><h2>test parse tracker-id</h2><h4>../test/test_tracker.cpp:56</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(128)">../test/test_tracker.cpp:57</a></td><td>test parse failure-reason</td></tr><tr id="128" style="display: none;" colspan="3"><td colspan="3"><h2>test parse failure-reason</h2><h4>../test/test_tracker.cpp:57</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(129)">../test/test_tracker.cpp:58</a></td><td>test all failure paths, including invalid bencoding not a dictionary no files entry in scrape response no info-hash entry in scrape response malformed peers in peer list of dictionaries uneven number of bytes in peers and peers6 string responses</td></tr><tr id="129" style="display: none;" colspan="3"><td colspan="3"><h2>test all failure paths, including
invalid bencoding
not a dictionary
no files entry in scrape response
no info-hash entry in scrape response
malformed peers in peer list of dictionaries
uneven number of bytes in peers and peers6 string responses</h2><h4>../test/test_tracker.cpp:58</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#include "setup_transfer.hpp"
#include "udp_tracker.hpp"
#include "settings.hpp"
#include "libtorrent/alert.hpp"
#include "libtorrent/peer_info.hpp" // for peer_list_entry
#include "libtorrent/broadcast_socket.hpp" // for supports_ipv6
#include "libtorrent/alert_types.hpp"
#include "libtorrent/session.hpp"
#include "libtorrent/error_code.hpp"
#include "libtorrent/tracker_manager.hpp"
#include "libtorrent/http_tracker_connection.hpp" // for parse_tracker_response
#include "libtorrent/torrent_info.hpp"
#include "libtorrent/announce_entry.hpp"
#include "libtorrent/torrent.hpp"
#include "libtorrent/aux_/path.hpp"

#include &lt;fstream&gt;

using namespace lt;

<div style="background: #ffff00" width="100%">
</div>TORRENT_TEST(parse_hostname_peers)
{
	char const response[] = "d5:peersld7:peer id20:aaaaaaaaaaaaaaaaaaaa"
		"2:ip13:test_hostname4:porti1000eed"
		"7:peer id20:bbbbabaababababababa2:ip12:another_host4:porti1001eeee";
	error_code ec;
	tracker_response resp = parse_tracker_response(response
		, ec, false, sha1_hash());

	TEST_EQUAL(ec, error_code());
	TEST_EQUAL(resp.peers.size(), 2);
	if (resp.peers.size() == 2)
	{
		peer_entry const&amp; e0 = resp.peers[0];
		peer_entry const&amp; e1 = resp.peers[1];
		TEST_EQUAL(e0.hostname, "test_hostname");
		TEST_EQUAL(e0.port, 1000);
		TEST_EQUAL(e0.pid, peer_id("aaaaaaaaaaaaaaaaaaaa"));

		TEST_EQUAL(e1.hostname, "another_host");
		TEST_EQUAL(e1.port, 1001);
		TEST_EQUAL(e1.pid, peer_id("bbbbabaababababababa"));
	}
}

TORRENT_TEST(parse_peers4)
{
	char const response[] = "d5:peers12:\x01\x02\x03\x04\x30\x10"
		"\x09\x08\x07\x06\x20\x10" "e";
	error_code ec;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(130)">../test/test_timestamp_history.cpp:54</a></td><td>test the case where we have > 120 samples (and have the base delay actually be updated)</td></tr><tr id="130" style="display: none;" colspan="3"><td colspan="3"><h2>test the case where we have > 120 samples (and have the base delay actually be updated)</h2><h4>../test/test_timestamp_history.cpp:54</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(131)">../test/test_timestamp_history.cpp:55</a></td><td>test the case where a sample is lower than the history entry but not lower than the base</td></tr><tr id="131" style="display: none;" colspan="3"><td colspan="3"><h2>test the case where a sample is lower than the history entry but not lower than the base</h2><h4>../test/test_timestamp_history.cpp:55</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#include "libtorrent/timestamp_history.hpp"

TORRENT_TEST(timestamp_history)
{
	using namespace lt;

	timestamp_history h;
	TEST_EQUAL(h.add_sample(0x32, false), 0);
	TEST_EQUAL(h.base(), 0x32);
	TEST_EQUAL(h.add_sample(0x33, false), 0x1);
	TEST_EQUAL(h.base(), 0x32);
	TEST_EQUAL(h.add_sample(0x3433, false), 0x3401);
	TEST_EQUAL(h.base(), 0x32);
	TEST_EQUAL(h.add_sample(0x30, false), 0);
	TEST_EQUAL(h.base(), 0x30);

	// test that wrapping of the timestamp is properly handled
	h.add_sample(0xfffffff3, false);
	TEST_EQUAL(h.base(), 0xfffffff3);

<div style="background: #ffff00" width="100%">}
</div>
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(132)">../test/test_flags.cpp:131</a></td><td>change to a different test setup. currently always paused. test_set_after_add(torrent_flags::paused); test_unset_after_add(torrent_flags::paused);</td></tr><tr id="132" style="display: none;" colspan="3"><td colspan="3"><h2>change to a different test setup. currently always paused.
test_set_after_add(torrent_flags::paused);
test_unset_after_add(torrent_flags::paused);</h2><h4>../test/test_flags.cpp:131</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">TORRENT_TEST(flag_share_mode)
{
	// share-mode
	test_add_and_get_flags(torrent_flags::share_mode);
	test_set_after_add(torrent_flags::share_mode);
	test_unset_after_add(torrent_flags::share_mode);
}

TORRENT_TEST(flag_apply_ip_filter)
{
	// apply-ip-filter
	test_add_and_get_flags(torrent_flags::apply_ip_filter);
	test_set_after_add(torrent_flags::apply_ip_filter);
	test_unset_after_add(torrent_flags::apply_ip_filter);
}

TORRENT_TEST(flag_paused)
{
	// paused
	test_add_and_get_flags(torrent_flags::paused);
<div style="background: #ffff00" width="100%">}
</div>
TORRENT_TEST(flag_auto_managed)
{
	// auto-managed
	test_add_and_get_flags(torrent_flags::auto_managed);
	test_set_after_add(torrent_flags::auto_managed);
	test_unset_after_add(torrent_flags::auto_managed);
}

TORRENT_TEST(flag_super_seeding)
{
	// super-seeding
	test_add_and_get_flags(torrent_flags::super_seeding);
	test_set_after_add(torrent_flags::super_seeding);
	test_unset_after_add(torrent_flags::super_seeding);
}

TORRENT_TEST(flag_sequential_download)
{
	// sequential-download
	test_add_and_get_flags(torrent_flags::sequential_download);
	test_set_after_add(torrent_flags::sequential_download);
	test_unset_after_add(torrent_flags::sequential_download);
}

TORRENT_TEST(flag_stop_when_ready)
{
	// stop-when-ready
	test_add_and_get_flags(torrent_flags::stop_when_ready);
	// setting stop-when-ready when already stopped has no effect.
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(133)">../test/test_flags.cpp:165</a></td><td>change to a different test setup. currently always paused. test_set_after_add(torrent_flags::stop_when_ready);</td></tr><tr id="133" style="display: none;" colspan="3"><td colspan="3"><h2>change to a different test setup. currently always paused.
test_set_after_add(torrent_flags::stop_when_ready);</h2><h4>../test/test_flags.cpp:165</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">{
	// super-seeding
	test_add_and_get_flags(torrent_flags::super_seeding);
	test_set_after_add(torrent_flags::super_seeding);
	test_unset_after_add(torrent_flags::super_seeding);
}

TORRENT_TEST(flag_sequential_download)
{
	// sequential-download
	test_add_and_get_flags(torrent_flags::sequential_download);
	test_set_after_add(torrent_flags::sequential_download);
	test_unset_after_add(torrent_flags::sequential_download);
}

TORRENT_TEST(flag_stop_when_ready)
{
	// stop-when-ready
	test_add_and_get_flags(torrent_flags::stop_when_ready);
	// setting stop-when-ready when already stopped has no effect.
<div style="background: #ffff00" width="100%">	test_unset_after_add(torrent_flags::stop_when_ready);
</div>}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(134)">../test/test_upnp.cpp:151</a></td><td>store the log and verify that some key messages are there</td></tr><tr id="134" style="display: none;" colspan="3"><td colspan="3"><h2>store the log and verify that some key messages are there</h2><h4>../test/test_upnp.cpp:151</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			, address const&amp; ip, int port
			, portmap_protocol const protocol, error_code const&amp; err
			, portmap_transport) override
		{
			callback_info info = {mapping, port, err};
			callbacks.push_back(info);
			std::cout &lt;&lt; "mapping: " &lt;&lt; static_cast&lt;int&gt;(mapping)
				&lt;&lt; ", port: " &lt;&lt; port &lt;&lt; ", IP: " &lt;&lt; ip
				&lt;&lt; ", proto: " &lt;&lt; static_cast&lt;int&gt;(protocol)
				&lt;&lt; ", error: \"" &lt;&lt; err.message() &lt;&lt; "\"\n";
		}
	#ifndef TORRENT_DISABLE_LOGGING
		bool should_log_portmap(portmap_transport) const override
		{
			return true;
		}

		void log_portmap(portmap_transport, char const* msg) const override
		{
			std::cout &lt;&lt; "UPnP: " &lt;&lt; msg &lt;&lt; std::endl;
<div style="background: #ffff00" width="100%">		}
</div>	#endif
	};
}

void run_upnp_test(char const* root_filename, char const* control_name, int igd_version)
{
	lt::io_service ios;

	g_port = start_web_server();

	std::vector&lt;char&gt; buf;
	error_code ec;
	load_file(root_filename, buf, ec);
	buf.push_back(0);

	FILE* xml_file = fopen("upnp.xml", "w+");
	if (xml_file == nullptr)
	{
		std::printf("failed to open file 'upnp.xml': %s\n", strerror(errno));
		TEST_CHECK(false);
		return;
	}
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wformat-nonliteral"
#endif
	std::fprintf(xml_file, &amp;buf[0], g_port);
#ifdef __clang__
#pragma clang diagnostic pop
#endif
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(135)">../test/test_file_storage.cpp:627</a></td><td>test file attributes</td></tr><tr id="135" style="display: none;" colspan="3"><td colspan="3"><h2>test file attributes</h2><h4>../test/test_file_storage.cpp:627</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(136)">../test/test_file_storage.cpp:628</a></td><td>test symlinks</td></tr><tr id="136" style="display: none;" colspan="3"><td colspan="3"><h2>test symlinks</h2><h4>../test/test_file_storage.cpp:628</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(137)">../test/test_file_storage.cpp:629</a></td><td>test reorder_file (make sure internal_file_entry::swap() is used)</td></tr><tr id="137" style="display: none;" colspan="3"><td colspan="3"><h2>test reorder_file (make sure internal_file_entry::swap() is used)</h2><h4>../test/test_file_storage.cpp:629</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(138)">../test/test_storage.cpp:990</a></td><td>this should take a span of iovec_ts</td></tr><tr id="138" style="display: none;" colspan="3"><td colspan="3"><h2>this should take a span of iovec_ts</h2><h4>../test/test_storage.cpp:990</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">}

#if TORRENT_ABI_VERSION == 1
TORRENT_TEST(rename_file_fastresume_deprecated)
{
	test_rename_file_fastresume(true);
}
#endif

namespace {

void alloc_iov(iovec_t* iov, int num_bufs)
{
	for (int i = 0; i &lt; num_bufs; ++i)
	{
		iov[i] = { new char[static_cast&lt;std::size_t&gt;(num_bufs * (i + 1))]
			, num_bufs * (i + 1) };
	}
}

<div style="background: #ffff00" width="100%">void fill_pattern(iovec_t* iov, int num_bufs)
</div>{
	int counter = 0;
	for (int i = 0; i &lt; num_bufs; ++i)
	{
		for (char&amp; v : iov[i])
		{
			v = char(counter &amp; 0xff);
			++counter;
		}
	}
}

bool check_pattern(std::vector&lt;char&gt; const&amp; buf, int counter)
{
	unsigned char const* p = reinterpret_cast&lt;unsigned char const*&gt;(buf.data());
	for (int k = 0; k &lt; int(buf.size()); ++k)
	{
		if (p[k] != (counter &amp; 0xff)) return false;
		++counter;
	}
	return true;
}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(139)">../test/test_storage.cpp:1015</a></td><td>this should take a span</td></tr><tr id="139" style="display: none;" colspan="3"><td colspan="3"><h2>this should take a span</h2><h4>../test/test_storage.cpp:1015</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	{
		for (char&amp; v : iov[i])
		{
			v = char(counter &amp; 0xff);
			++counter;
		}
	}
}

bool check_pattern(std::vector&lt;char&gt; const&amp; buf, int counter)
{
	unsigned char const* p = reinterpret_cast&lt;unsigned char const*&gt;(buf.data());
	for (int k = 0; k &lt; int(buf.size()); ++k)
	{
		if (p[k] != (counter &amp; 0xff)) return false;
		++counter;
	}
	return true;
}

<div style="background: #ffff00" width="100%">void free_iov(iovec_t* iov, int num_bufs)
</div>{
	for (int i = 0; i &lt; num_bufs; ++i)
	{
		delete[] iov[i].data();
		iov[i] = { nullptr, 0 };
	}
}

} // anonymous namespace

TORRENT_TEST(iovec_copy_bufs)
{
	iovec_t iov1[10];
	iovec_t iov2[10];

	alloc_iov(iov1, 10);
	fill_pattern(iov1, 10);

	TEST_CHECK(bufs_size({iov1, 10}) &gt;= 106);

	// copy exactly 106 bytes from iov1 to iov2
	int num_bufs = aux::copy_bufs(iov1, 106, iov2);

	// verify that the first 100 bytes is pattern 1
	// and that the remaining bytes are pattern 2

	int counter = 0;
	for (int i = 0; i &lt; num_bufs; ++i)
	{
		for (char v : iov2[i])
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(140)">../test/test_torrent_info.cpp:171</a></td><td>test remap_files</td></tr><tr id="140" style="display: none;" colspan="3"><td colspan="3"><h2>test remap_files</h2><h4>../test/test_torrent_info.cpp:171</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(141)">../test/test_torrent_info.cpp:172</a></td><td>merkle torrents. specifically torrent_info::add_merkle_nodes and torrent with "root hash"</td></tr><tr id="141" style="display: none;" colspan="3"><td colspan="3"><h2>merkle torrents. specifically torrent_info::add_merkle_nodes and torrent with "root hash"</h2><h4>../test/test_torrent_info.cpp:172</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(142)">../test/test_torrent_info.cpp:173</a></td><td>torrent with 'p' (padfile) attribute</td></tr><tr id="142" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with 'p' (padfile) attribute</h2><h4>../test/test_torrent_info.cpp:173</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(143)">../test/test_torrent_info.cpp:174</a></td><td>torrent with 'h' (hidden) attribute</td></tr><tr id="143" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with 'h' (hidden) attribute</h2><h4>../test/test_torrent_info.cpp:174</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(144)">../test/test_torrent_info.cpp:175</a></td><td>torrent with 'x' (executable) attribute</td></tr><tr id="144" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with 'x' (executable) attribute</h2><h4>../test/test_torrent_info.cpp:175</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(145)">../test/test_torrent_info.cpp:176</a></td><td>torrent with 'l' (symlink) attribute</td></tr><tr id="145" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with 'l' (symlink) attribute</h2><h4>../test/test_torrent_info.cpp:176</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(146)">../test/test_torrent_info.cpp:177</a></td><td>creating a merkle torrent (torrent_info::build_merkle_list)</td></tr><tr id="146" style="display: none;" colspan="3"><td colspan="3"><h2>creating a merkle torrent (torrent_info::build_merkle_list)</h2><h4>../test/test_torrent_info.cpp:177</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(147)">../test/test_torrent_info.cpp:178</a></td><td>torrent with multiple trackers in multiple tiers, making sure we shuffle them (how do you test shuffling?, load it multiple times and make sure it's in different order at least once)</td></tr><tr id="147" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with multiple trackers in multiple tiers, making sure we
shuffle them (how do you test shuffling?, load it multiple times and make
sure it's in different order at least once)</h2><h4>../test/test_torrent_info.cpp:178</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(148)">../test/test_torrent_info.cpp:181</a></td><td>torrents with a zero-length name</td></tr><tr id="148" style="display: none;" colspan="3"><td colspan="3"><h2>torrents with a zero-length name</h2><h4>../test/test_torrent_info.cpp:181</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(149)">../test/test_torrent_info.cpp:182</a></td><td>torrents with a merkle tree and add_merkle_nodes</td></tr><tr id="149" style="display: none;" colspan="3"><td colspan="3"><h2>torrents with a merkle tree and add_merkle_nodes</h2><h4>../test/test_torrent_info.cpp:182</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(150)">../test/test_torrent_info.cpp:183</a></td><td>torrent with a non-dictionary info-section</td></tr><tr id="150" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with a non-dictionary info-section</h2><h4>../test/test_torrent_info.cpp:183</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(151)">../test/test_torrent_info.cpp:184</a></td><td>torrents with DHT nodes</td></tr><tr id="151" style="display: none;" colspan="3"><td colspan="3"><h2>torrents with DHT nodes</h2><h4>../test/test_torrent_info.cpp:184</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(152)">../test/test_torrent_info.cpp:185</a></td><td>torrent with url-list as a single string</td></tr><tr id="152" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with url-list as a single string</h2><h4>../test/test_torrent_info.cpp:185</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(153)">../test/test_torrent_info.cpp:186</a></td><td>torrent with http seed as a single string</td></tr><tr id="153" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with http seed as a single string</h2><h4>../test/test_torrent_info.cpp:186</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(154)">../test/test_torrent_info.cpp:187</a></td><td>torrent with a comment</td></tr><tr id="154" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with a comment</h2><h4>../test/test_torrent_info.cpp:187</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(155)">../test/test_torrent_info.cpp:188</a></td><td>torrent with an SSL cert</td></tr><tr id="155" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with an SSL cert</h2><h4>../test/test_torrent_info.cpp:188</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(156)">../test/test_torrent_info.cpp:189</a></td><td>torrent with attributes (executable and hidden)</td></tr><tr id="156" style="display: none;" colspan="3"><td colspan="3"><h2>torrent with attributes (executable and hidden)</h2><h4>../test/test_torrent_info.cpp:189</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(157)">../test/test_torrent_info.cpp:190</a></td><td>torrent_info::add_tracker</td></tr><tr id="157" style="display: none;" colspan="3"><td colspan="3"><h2>torrent_info::add_tracker</h2><h4>../test/test_torrent_info.cpp:190</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(158)">../test/test_torrent_info.cpp:191</a></td><td>torrent_info constructor that takes an invalid bencoded buffer</td></tr><tr id="158" style="display: none;" colspan="3"><td colspan="3"><h2>torrent_info constructor that takes an invalid bencoded buffer</h2><h4>../test/test_torrent_info.cpp:191</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(159)">../test/test_torrent_info.cpp:192</a></td><td>verify_encoding with a string that triggers character replacement</td></tr><tr id="159" style="display: none;" colspan="3"><td colspan="3"><h2>verify_encoding with a string that triggers character replacement</h2><h4>../test/test_torrent_info.cpp:192</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	{ "invalid_name.torrent", errors::torrent_missing_name },
	{ "invalid_info.torrent", errors::torrent_missing_info },
	{ "string.torrent", errors::torrent_is_no_dict },
	{ "negative_size.torrent", errors::torrent_invalid_length },
	{ "negative_file_size.torrent", errors::torrent_invalid_length },
	{ "invalid_path_list.torrent", errors::torrent_invalid_name},
	{ "missing_path_list.torrent", errors::torrent_missing_name },
	{ "invalid_pieces.torrent", errors::torrent_missing_pieces },
	{ "unaligned_pieces.torrent", errors::torrent_invalid_hashes },
	{ "invalid_root_hash.torrent", errors::torrent_invalid_hashes },
	{ "invalid_root_hash2.torrent", errors::torrent_missing_pieces },
	{ "invalid_merkle.torrent", errors::no_files_in_torrent},
	{ "invalid_file_size.torrent", errors::torrent_invalid_length },
	{ "invalid_symlink.torrent", errors::torrent_invalid_name },
	{ "many_pieces.torrent", errors::too_many_pieces_in_torrent },
	{ "no_files.torrent", errors::no_files_in_torrent},
};

} // anonymous namespace

<div style="background: #ffff00" width="100%">
</div>TORRENT_TEST(url_list_and_httpseeds)
{
	entry info;
	info["pieces"] = "aaaaaaaaaaaaaaaaaaaa";
	info["name.utf-8"] = "test1";
	info["name"] = "test__";
	info["piece length"] = 16 * 1024;
	info["length"] = 3245;
	entry::list_type l;
	l.push_back(entry("http://foo.com/bar1"));
	l.push_back(entry("http://foo.com/bar1"));
	l.push_back(entry("http://foo.com/bar2"));
	entry const e(l);
	entry torrent;
	torrent["url-list"] = e;
	torrent["httpseeds"] = e;
	torrent["info"] = info;
	std::vector&lt;char&gt; buf;
	bencode(std::back_inserter(buf), torrent);
	torrent_info ti(buf, from_span);
	TEST_EQUAL(ti.web_seeds().size(), 4);
}

TORRENT_TEST(add_url_seed)
{
	torrent_info ti(sha1_hash("                   "));
	TEST_EQUAL(ti.web_seeds().size(), 0);

	ti.add_url_seed("http://test.com");

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(160)">../test/test_block_cache.cpp:484</a></td><td>test try_evict_blocks</td></tr><tr id="160" style="display: none;" colspan="3"><td colspan="3"><h2>test try_evict_blocks</h2><h4>../test/test_block_cache.cpp:484</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(161)">../test/test_block_cache.cpp:485</a></td><td>test evicting volatile pieces, to see them be removed</td></tr><tr id="161" style="display: none;" colspan="3"><td colspan="3"><h2>test evicting volatile pieces, to see them be removed</h2><h4>../test/test_block_cache.cpp:485</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(162)">../test/test_block_cache.cpp:486</a></td><td>test evicting dirty pieces</td></tr><tr id="162" style="display: none;" colspan="3"><td colspan="3"><h2>test evicting dirty pieces</h2><h4>../test/test_block_cache.cpp:486</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(163)">../test/test_block_cache.cpp:487</a></td><td>test free_piece</td></tr><tr id="163" style="display: none;" colspan="3"><td colspan="3"><h2>test free_piece</h2><h4>../test/test_block_cache.cpp:487</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(164)">../test/test_block_cache.cpp:488</a></td><td>test abort_dirty</td></tr><tr id="164" style="display: none;" colspan="3"><td colspan="3"><h2>test abort_dirty</h2><h4>../test/test_block_cache.cpp:488</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(165)">../test/test_block_cache.cpp:489</a></td><td>test unaligned reads</td></tr><tr id="165" style="display: none;" colspan="3"><td colspan="3"><h2>test unaligned reads</h2><h4>../test/test_block_cache.cpp:489</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// return the reference to the buffer we just read
	rj.argument = remove_flags_t{};

	tailqueue&lt;disk_io_job&gt; jobs;
	bc.clear(jobs);
}

} // anonymous namespace

TORRENT_TEST(block_cache)
{
	test_write();
	test_flush();
	test_insert();
	test_evict();
	test_arc_promote();
	test_arc_unghost();
	test_iovec();
	test_unaligned_read();

<div style="background: #ffff00" width="100%">}
</div>
TORRENT_TEST(delete_piece)
{
	TEST_SETUP;

	TEST_CHECK(bc.num_pieces() == 0);

	INSERT(0, 0);

	TEST_CHECK(bc.num_pieces() == 1);

	rj.action = job_action_t::read;
	rj.d.io.offset = 0x2000;
	rj.d.io.buffer_size = 0x4000;
	rj.piece = piece_index_t(0);
	rj.storage = pm;
	rj.argument = remove_flags_t{};
	ret = bc.try_read(&amp;rj, alloc);
	TEST_EQUAL(ret, -1);

	cached_piece_entry* pe_ = bc.find_piece(pm.get(), piece_index_t(0));
	bc.mark_for_eviction(pe_, block_cache::disallow_ghost);

	TEST_CHECK(bc.num_pieces() == 0);
}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(166)">../test/test_fast_extension.cpp:1074</a></td><td>test sending invalid requests (out of bound piece index, offsets and sizes)</td></tr><tr id="166" style="display: none;" colspan="3"><td colspan="3"><h2>test sending invalid requests (out of bound piece index, offsets and
sizes)</h2><h4>../test/test_fast_extension.cpp:1074</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(167)">../test/test_file_progress.cpp:107</a></td><td>test the update function too</td></tr><tr id="167" style="display: none;" colspan="3"><td colspan="3"><h2>test the update function too</h2><h4>../test/test_file_progress.cpp:107</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
	for (auto const idx : fs.piece_range())
	{
		piece_picker picker(4, fs.total_size() % 4, fs.num_pieces());
		picker.we_have(idx);

		aux::vector&lt;std::int64_t, file_index_t&gt; vec;
		aux::file_progress fp;

		fp.init(picker, fs);
		fp.export_progress(vec);

		std::int64_t sum = 0;
		for (file_index_t i(0); i &lt; vec.end_index(); ++i)
			sum += vec[i];

		TEST_EQUAL(sum, fs.piece_size(idx));
	}
}

<div style="background: #ffff00" width="100%">
</div></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(168)">../test/test_bloom_filter.cpp:134</a></td><td>test size()</td></tr><tr id="168" style="display: none;" colspan="3"><td colspan="3"><h2>test size()</h2><h4>../test/test_bloom_filter.cpp:134</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(169)">../test/test_bloom_filter.cpp:135</a></td><td>test clear()</td></tr><tr id="169" style="display: none;" colspan="3"><td colspan="3"><h2>test clear()</h2><h4>../test/test_bloom_filter.cpp:135</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	sha1_hash k("\x01\x00\x02\x00                ");
	TEST_CHECK(!filter.find(k));
	filter.set(k);
	TEST_CHECK(filter.find(k));

	std::uint8_t compare[4] = { 0x16, 0xff, 0x55, 0xaa};

	bits_out = filter.to_string();
	TEST_EQUAL(memcmp(compare, bits_out.c_str(), 4), 0);
}

} // anonymous namespace

TORRENT_TEST(bloom_filter)
{
	test_set_and_get();
	test_set_bits();
	test_count_zeroes();
	test_to_from_string();

<div style="background: #ffff00" width="100%">}
</div></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(170)">../test/test_dht.cpp:465</a></td><td>check to make sure the "best" items are stored</td></tr><tr id="170" style="display: none;" colspan="3"><td colspan="3"><h2>check to make sure the "best" items are stored</h2><h4>../test/test_dht.cpp:465</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			, msg_args().target(items[j].target));

		key_desc_t const desc[] =
		{
			{ "r", bdecode_node::dict_t, 0, key_desc_t::parse_children },
				{ "v", bdecode_node::dict_t, 0, 0},
				{ "id", bdecode_node::string_t, 20, key_desc_t::last_child},
			{ "y", bdecode_node::string_t, 1, 0},
		};

		bdecode_node parsed[4];
		char error_string[200];

		int ret = verify_message(response, desc, parsed, error_string);
		if (ret)
		{
			items_num.insert(items_num.begin(), j);
		}
	}

<div style="background: #ffff00" width="100%">	TEST_EQUAL(items_num.size(), 4);
</div>}

int sum_distance_exp(int s, node_entry const&amp; e, node_id const&amp; ref)
{
	return s + distance_exp(e.id, ref);
}

std::vector&lt;tcp::endpoint&gt; g_got_peers;

void get_peers_cb(std::vector&lt;tcp::endpoint&gt; const&amp; peers)
{
	g_got_peers.insert(g_got_peers.end(), peers.begin(), peers.end());
}

std::vector&lt;dht::item&gt; g_got_items;
dht::item g_put_item;
int g_put_count;

void get_mutable_item_cb(dht::item const&amp; i, bool a)
{
	if (!a) return;
	if (!i.empty())
		g_got_items.push_back(i);
}

void put_mutable_item_data_cb(dht::item&amp; i)
{
	if (!i.empty())
		g_got_items.push_back(i);

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(171)">../test/test_dht.cpp:3278</a></td><td>this won't work because the second node isn't pinged so it wont be added to the routing table</td></tr><tr id="171" style="display: none;" colspan="3"><td colspan="3"><h2>this won't work because the second node isn't pinged so it wont
be added to the routing table</h2><h4>../test/test_dht.cpp:3278</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	bool ret = verify_message(request, get_item_desc_ro, parsed, error_string);

	TEST_CHECK(ret);
	TEST_EQUAL(parsed[3].int_value(), 1);

	// should have one node now, which is 4.4.4.4:1234
	TEST_EQUAL(std::get&lt;0&gt;(node.size()), 1);
	// and no replacement nodes
	TEST_EQUAL(std::get&lt;1&gt;(node.size()), 0);

	// now, disable read_only, try again.
	g_sent_packets.clear();
	sett.read_only = false;

	send_dht_request(node, "get", source, &amp;response);
	// sender should be added to repacement bucket
	TEST_EQUAL(std::get&lt;1&gt;(node.size()), 1);

	g_sent_packets.clear();
#if 0
<div style="background: #ffff00" width="100%">	target = generate_next();
</div>	node.get_item(target, get_immutable_item_cb);

	// since we have 2 nodes, we should have two packets.
	TEST_EQUAL(g_sent_packets.size(), 2);

	// both of them shouldn't have a 'ro' key.
	lazy_from_entry(g_sent_packets.front().second, request);
	ret = verify_message(request, get_item_desc_ro, parsed, error_string);

	TEST_CHECK(ret);
	TEST_CHECK(!parsed[3]);

	lazy_from_entry(g_sent_packets.back().second, request);
	ret = verify_message(request, get_item_desc_ro, parsed, error_string);

	TEST_CHECK(ret);
	TEST_CHECK(!parsed[3]);
#endif
}

#ifndef TORRENT_DISABLE_LOGGING
// these tests rely on logging being enabled

TORRENT_TEST(invalid_error_msg)
{
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(172)">../test/test_dht.cpp:3763</a></td><td>test obfuscated_get_peers</td></tr><tr id="172" style="display: none;" colspan="3"><td colspan="3"><h2>test obfuscated_get_peers</h2><h4>../test/test_dht.cpp:3763</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		std::printf("   invalid sample_infohashes request: %s\n", print_entry(response).c_str());
		TEST_ERROR(t.error_string);
		return;
	}

	std::vector&lt;node_entry&gt; nodes;
	nodes.emplace_back(h1, ep1);
	nodes.emplace_back(h2, ep2);

	g_sent_packets.clear();
	send_dht_response(t.dht_node, response, initial_node
		, msg_args()
			.interval(seconds(10))
			.num(2)
			.samples({to_hash("1000000000000000000000000000000000000001")})
			.nodes(nodes));

	TEST_CHECK(g_sent_packets.empty());
}

<div style="background: #ffff00" width="100%">
</div>#else
TORRENT_TEST(dht)
{
	// dummy dht test
	TEST_CHECK(true);
}

#endif
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(173)">../test/test_resolve_links.cpp:86</a></td><td>test files with different piece size (negative test)</td></tr><tr id="173" style="display: none;" colspan="3"><td colspan="3"><h2>test files with different piece size (negative test)</h2><h4>../test/test_resolve_links.cpp:86</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	{ "test2", "test1_pad_files", 0},
	{ "test3", "test1_pad_files", 0},
	{ "test2", "test1_single", 0},

	// these are all padded. The first small file will accidentally also
	// match, even though it's not tail padded, the following file is identical
	{ "test2_pad_files", "test1_pad_files", 2},
	{ "test3_pad_files", "test1_pad_files", 2},
	{ "test3_pad_files", "test2_pad_files", 2},
	{ "test1_pad_files", "test2_pad_files", 2},
	{ "test1_pad_files", "test3_pad_files", 2},
	{ "test2_pad_files", "test3_pad_files", 2},

	// one might expect this to work, but since the tail of the single file
	// torrent is not padded, the last piece hash won't match
	{ "test1_pad_files", "test1_single", 0},

	// if it's padded on the other hand, it will work
	{ "test1_pad_files", "test1_single_padded", 1},

<div style="background: #ffff00" width="100%">};
</div>
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(174)">../test/test_resolve_links.cpp:89</a></td><td>it would be nice to test resolving of more than just 2 files as well. like 3 single file torrents merged into one, resolving all 3 files.</td></tr><tr id="174" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to test resolving of more than just 2 files as well.
like 3 single file torrents merged into one, resolving all 3 files.</h2><h4>../test/test_resolve_links.cpp:89</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	{ "test2", "test1_single", 0},

	// these are all padded. The first small file will accidentally also
	// match, even though it's not tail padded, the following file is identical
	{ "test2_pad_files", "test1_pad_files", 2},
	{ "test3_pad_files", "test1_pad_files", 2},
	{ "test3_pad_files", "test2_pad_files", 2},
	{ "test1_pad_files", "test2_pad_files", 2},
	{ "test1_pad_files", "test3_pad_files", 2},
	{ "test2_pad_files", "test3_pad_files", 2},

	// one might expect this to work, but since the tail of the single file
	// torrent is not padded, the last piece hash won't match
	{ "test1_pad_files", "test1_single", 0},

	// if it's padded on the other hand, it will work
	{ "test1_pad_files", "test1_single_padded", 1},

};

<div style="background: #ffff00" width="100%">
</div>TORRENT_TEST(resolve_links)
{
	std::string path = combine_path(parent_path(current_working_directory())
		, "mutable_test_torrents");

	for (int i = 0; i &lt; int(sizeof(test_torrents)/sizeof(test_torrents[0])); ++i)
	{
		test_torrent_t const&amp; e = test_torrents[i];

		std::string p = combine_path(path, e.filename1) + ".torrent";
		std::printf("loading %s\n", p.c_str());
		std::shared_ptr&lt;torrent_info&gt; ti1 = std::make_shared&lt;torrent_info&gt;(p);

		p = combine_path(path, e.filename2) + ".torrent";
		std::printf("loading %s\n", p.c_str());
		std::shared_ptr&lt;torrent_info&gt; ti2 = std::make_shared&lt;torrent_info&gt;(p);

		std::printf("resolving\n");
		resolve_links l(ti1);
		l.match(ti2, ".");

		aux::vector&lt;resolve_links::link_t, file_index_t&gt; const&amp; links = l.get_links();

		auto const num_matches = std::size_t(std::count_if(links.begin(), links.end()
			, std::bind(&amp;resolve_links::link_t::ti, _1)));

		// some debug output in case the test fails
		if (num_matches &gt; e.expected_matches)
		{
			file_storage const&amp; fs = ti1-&gt;files();
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(175)">../test/test_transfer.cpp:218</a></td><td>these settings_pack tests belong in their own test</td></tr><tr id="175" style="display: none;" colspan="3"><td colspan="3"><h2>these settings_pack tests belong in their own test</h2><h4>../test/test_transfer.cpp:218</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// to the time it will take to complete the test
	pack.set_int(settings_pack::min_reconnect_time, 0);
	pack.set_int(settings_pack::stop_tracker_timeout, 1);
	pack.set_bool(settings_pack::announce_to_all_trackers, true);
	pack.set_bool(settings_pack::announce_to_all_tiers, true);

	// make sure we announce to both http and udp trackers
	pack.set_bool(settings_pack::prefer_udp_trackers, false);
	pack.set_bool(settings_pack::enable_outgoing_utp, false);
	pack.set_bool(settings_pack::enable_incoming_utp, false);
	pack.set_bool(settings_pack::enable_lsd, false);
	pack.set_bool(settings_pack::enable_natpmp, false);
	pack.set_bool(settings_pack::enable_upnp, false);
	pack.set_bool(settings_pack::enable_dht, false);

	pack.set_int(settings_pack::out_enc_policy, settings_pack::pe_disabled);
	pack.set_int(settings_pack::in_enc_policy, settings_pack::pe_disabled);

	pack.set_bool(settings_pack::allow_multiple_connections_per_ip, false);

<div style="background: #ffff00" width="100%">	pack.set_int(settings_pack::unchoke_slots_limit, 0);
</div>	ses1.apply_settings(pack);
	TEST_CHECK(ses1.get_settings().get_int(settings_pack::unchoke_slots_limit) == 0);

	pack.set_int(settings_pack::unchoke_slots_limit, -1);
	ses1.apply_settings(pack);
	TEST_CHECK(ses1.get_settings().get_int(settings_pack::unchoke_slots_limit) == -1);

	pack.set_int(settings_pack::unchoke_slots_limit, 8);
	ses1.apply_settings(pack);
	TEST_CHECK(ses1.get_settings().get_int(settings_pack::unchoke_slots_limit) == 8);

	ses2.apply_settings(pack);

	torrent_handle tor1;
	torrent_handle tor2;

	create_directory("tmp1_transfer", ec);
	std::ofstream file("tmp1_transfer/temporary");
	std::shared_ptr&lt;torrent_info&gt; t = ::create_torrent(&amp;file, "temporary", 32 * 1024, 13, false);
	file.close();

	TEST_CHECK(exists(combine_path("tmp1_transfer", "temporary")));

	add_torrent_params addp(&amp;test_storage_constructor);
	addp.flags &amp;= ~torrent_flags::paused;
	addp.flags &amp;= ~torrent_flags::auto_managed;

	add_torrent_params params;
	params.storage_mode = storage_mode;
	params.flags &amp;= ~torrent_flags::paused;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(176)">../test/test_transfer.cpp:312</a></td><td>factor out the disk-full test into its own unit test</td></tr><tr id="176" style="display: none;" colspan="3"><td colspan="3"><h2>factor out the disk-full test into its own unit test</h2><h4>../test/test_transfer.cpp:312</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		{
			flags &amp;= ~move_storage;
			tor1.move_storage("tmp1_transfer_moved");
			tor2.move_storage("tmp2_transfer_moved");
			std::cout &lt;&lt; "moving storage" &lt;&lt; std::endl;
		}

		if ((flags &amp; delete_files) &amp;&amp; st2.progress &gt; 0.1f)
		{
			ses1.remove_torrent(tor1, session::delete_files);
			std::cout &lt;&lt; "deleting files" &lt;&lt; std::endl;

			std::this_thread::sleep_for(lt::seconds(1));
			break;
		}

		// wait 10 loops before we restart the torrent. This lets
		// us catch all events that failed (and would put the torrent
		// back into upload mode) before we restart it.

<div style="background: #ffff00" width="100%">		if (flags &amp; disk_full
</div>			&amp;&amp; !(tor2.flags() &amp; torrent_flags::upload_mode)
			&amp;&amp; ++upload_mode_timer &gt; 10)
		{
			flags &amp;= ~disk_full;
			static_cast&lt;test_storage*&gt;(tor2.get_storage_impl())-&gt;set_limit(16 * 1024 * 1024);

			// if we reset the upload mode too soon, there may be more disk
			// jobs failing right after, putting us back in upload mode. So,
			// give the disk some time to fail all disk jobs before resetting
			// upload mode to false
			std::this_thread::sleep_for(lt::milliseconds(500));

			// then we need to drain the alert queue, so the peer_disconnects
			// counter doesn't get incremented by old alerts
			print_alerts(ses1, "ses1", true, true, &amp;on_alert);
			print_alerts(ses2, "ses2", true, true, &amp;on_alert);

			lt::error_code err = tor2.status().errc;
			std::printf("error: \"%s\"\n", err.message().c_str());
			TEST_CHECK(!err);
			tor2.unset_flags(torrent_flags::upload_mode);

			// at this point we probably disconnected the seed
			// so we need to reconnect as well
			std::printf("%s: reconnecting peer\n", time_now_string());
			error_code ec2;
			tor2.connect_peer(tcp::endpoint(address::from_string("127.0.0.1", ec2)
				, ses1.listen_port()));

			TEST_CHECK(tor2.status().is_finished == false);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(177)">../src/ut_metadata.cpp:282</a></td><td>we really need to increment the refcounter on the torrent while this buffer is still in the peer's send buffer</td></tr><tr id="177" style="display: none;" colspan="3"><td colspan="3"><h2>we really need to increment the refcounter on the torrent
while this buffer is still in the peer's send buffer</h2><h4>../src/ut_metadata.cpp:282</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				int const offset = piece * 16 * 1024;
				metadata = m_tp.metadata().data() + offset;
				metadata_piece_size = std::min(
					m_tp.get_metadata_size() - offset, 16 * 1024);
				TORRENT_ASSERT(metadata_piece_size &gt; 0);
				TORRENT_ASSERT(offset &gt;= 0);
				TORRENT_ASSERT(offset + metadata_piece_size &lt;= m_tp.get_metadata_size());
			}

			char msg[200];
			char* header = msg;
			char* p = &amp;msg[6];
			int const len = bencode(p, e);
			int const total_size = 2 + len + metadata_piece_size;
			namespace io = detail;
			io::write_uint32(total_size, header);
			io::write_uint8(bt_peer_connection::msg_extended, header);
			io::write_uint8(m_message_index, header);

			m_pc.send_buffer({msg, len + 6});
<div style="background: #ffff00" width="100%">			if (metadata_piece_size)
</div>			{
				m_pc.append_const_send_buffer(
					span&lt;char&gt;(const_cast&lt;char*&gt;(metadata), metadata_piece_size), metadata_piece_size);
			}

			m_pc.stats_counters().inc_stats_counter(counters::num_outgoing_extended);
			m_pc.stats_counters().inc_stats_counter(counters::num_outgoing_metadata);
		}

		bool on_extended(int const length
			, int const extended_msg, span&lt;char const&gt; body) override
		{
			if (extended_msg != 2) return false;
			if (m_message_index == 0) return false;

			if (length &gt; 17 * 1024)
			{
#ifndef TORRENT_DISABLE_LOGGING
				m_pc.peer_log(peer_log_alert::incoming_message, "UT_METADATA"
					, "packet too big %d", length);
#endif
				m_pc.disconnect(errors::invalid_metadata_message, operation_t::bittorrent, peer_connection_interface::peer_error);
				return true;
			}

			if (!m_pc.packet_finished()) return true;

			error_code ec;
			bdecode_node msg = bdecode(body, ec);
			if (msg.type() != bdecode_node::dict_t)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(178)">../src/ut_metadata.cpp:335</a></td><td>make this an enum class</td></tr><tr id="178" style="display: none;" colspan="3"><td colspan="3"><h2>make this an enum class</h2><h4>../src/ut_metadata.cpp:335</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			{
#ifndef TORRENT_DISABLE_LOGGING
				m_pc.peer_log(peer_log_alert::incoming_message, "UT_METADATA"
					, "not a dictionary");
#endif
				m_pc.disconnect(errors::invalid_metadata_message, operation_t::bittorrent, peer_connection_interface::peer_error);
				return true;
			}

			bdecode_node const&amp; type_ent = msg.dict_find_int("msg_type");
			bdecode_node const&amp; piece_ent = msg.dict_find_int("piece");
			if (!type_ent || !piece_ent)
			{
#ifndef TORRENT_DISABLE_LOGGING
				m_pc.peer_log(peer_log_alert::incoming_message, "UT_METADATA"
					, "missing or invalid keys");
#endif
				m_pc.disconnect(errors::invalid_metadata_message, operation_t::bittorrent, peer_connection_interface::peer_error);
				return true;
			}
<div style="background: #ffff00" width="100%">			auto const type = static_cast&lt;int&gt;(type_ent.int_value());
</div>			auto const piece = static_cast&lt;int&gt;(piece_ent.int_value());

#ifndef TORRENT_DISABLE_LOGGING
			m_pc.peer_log(peer_log_alert::incoming_message, "UT_METADATA"
				, "type: %d piece: %d", type, piece);
#endif

			switch (type)
			{
				case metadata_req:
				{
					if (!m_torrent.valid_metadata()
						|| piece &lt; 0 || piece &gt;= (m_tp.get_metadata_size() + 16 * 1024 - 1) / (16 * 1024))
					{
#ifndef TORRENT_DISABLE_LOGGING
						if (m_pc.should_log(peer_log_alert::info))
						{
							m_pc.peer_log(peer_log_alert::info, "UT_METADATA"
								, "have: %d invalid piece %d metadata size: %d"
								, int(m_torrent.valid_metadata()), piece
								, m_torrent.valid_metadata()
									? m_tp.get_metadata_size() : 0);
						}
#endif
						write_metadata_packet(metadata_dont_have, piece);
						return true;
					}
					if (m_pc.send_buffer_size() &lt; send_buffer_limit)
						write_metadata_packet(metadata_piece, piece);
					else if (m_incoming_requests.size() &lt; max_incoming_requests)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(179)">../src/disk_buffer_pool.cpp:207</a></td><td>perhaps we should sort the buffers here?</td></tr><tr id="179" style="display: none;" colspan="3"><td colspan="3"><h2>perhaps we should sort the buffers here?</h2><h4>../src/disk_buffer_pool.cpp:207</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			{
				// uh oh. We failed to allocate the buffer!
				// we need to roll back and free all the buffers
				// we've already allocated
				for (auto j : iov)
				{
					if (j.data() == nullptr) break;
					char* buf = j.data();
					TORRENT_ASSERT(is_disk_buffer(buf, l));
					remove_buffer_in_use(buf);
					free_buffer_impl(buf, l);
				}
				return -1;
			}
		}
		return 0;
	}

	void disk_buffer_pool::free_iovec(span&lt;iovec_t const&gt; iov)
	{
<div style="background: #ffff00" width="100%">		std::unique_lock&lt;std::mutex&gt; l(m_pool_mutex);
</div>		for (auto i : iov)
		{
			char* buf = i.data();
			TORRENT_ASSERT(is_disk_buffer(buf, l));
			remove_buffer_in_use(buf);
			free_buffer_impl(buf, l);
		}
		check_buffer_level(l);
	}

	char* disk_buffer_pool::allocate_buffer_impl(std::unique_lock&lt;std::mutex&gt;&amp; l
		, char const*)
	{
		TORRENT_ASSERT(m_settings_set);
		TORRENT_ASSERT(m_magic == 0x1337);
		TORRENT_ASSERT(l.owns_lock());
		TORRENT_UNUSED(l);

		char* ret = static_cast&lt;char*&gt;(std::malloc(default_block_size));

		if (ret == nullptr)
		{
			m_exceeded_max_size = true;
			m_trigger_cache_trim();
			return nullptr;
		}

		++m_in_use;

#if TORRENT_USE_INVARIANT_CHECKS
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(180)">../src/socks5_stream.cpp:93</a></td><td>we could bind the socket here, since we know what the target endpoint is of the proxy</td></tr><tr id="180" style="display: none;" colspan="3"><td colspan="3"><h2>we could bind the socket here, since we know what the
target endpoint is of the proxy</h2><h4>../src/socks5_stream.cpp:93</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
	boost::system::error_category&amp; socks_category()
	{
		static socks_error_category cat;
		return cat;
	}

	void socks5_stream::name_lookup(error_code const&amp; e, tcp::resolver::iterator i
		, handler_type h)
	{
		COMPLETE_ASYNC("socks5_stream::name_lookup");
		if (handle_error(e, h)) return;

		error_code ec;
		if (!m_sock.is_open())
		{
			m_sock.open(i-&gt;endpoint().protocol(), ec);
			if (handle_error(ec, h)) return;
		}

<div style="background: #ffff00" width="100%">		ADD_OUTSTANDING_ASYNC("socks5_stream::connected");
</div>		m_sock.async_connect(i-&gt;endpoint(), std::bind(
			&amp;socks5_stream::connected, this, _1, std::move(h)));
	}

	void socks5_stream::connected(error_code const&amp; e, handler_type h)
	{
		COMPLETE_ASYNC("socks5_stream::connected");
		if (handle_error(e, h)) return;

		using namespace libtorrent::detail;
		if (m_version == 5)
		{
			// send SOCKS5 authentication methods
			m_buffer.resize(m_user.empty()?3:4);
			char* p = &amp;m_buffer[0];
			write_uint8(5, p); // SOCKS VERSION 5
			if (m_user.empty())
			{
				write_uint8(1, p); // 1 authentication method (no auth)
				write_uint8(0, p); // no authentication
			}
			else
			{
				write_uint8(2, p); // 2 authentication methods
				write_uint8(0, p); // no authentication
				write_uint8(2, p); // username/password
			}
			ADD_OUTSTANDING_ASYNC("socks5_stream::handshake1");
			async_write(m_sock, boost::asio::buffer(m_buffer)
				, std::bind(&amp;socks5_stream::handshake1, this, _1, std::move(h)));
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(181)">../src/peer_connection.cpp:1084</a></td><td>this should be the global download rate</td></tr><tr id="181" style="display: none;" colspan="3"><td colspan="3"><h2>this should be the global download rate</h2><h4>../src/peer_connection.cpp:1084</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		int rate = 0;

		// if we haven't received any data recently, the current download rate
		// is not representative
		if (aux::time_now() - m_last_piece &gt; seconds(30) &amp;&amp; m_download_rate_peak &gt; 0)
		{
			rate = m_download_rate_peak;
		}
		else if (aux::time_now() - m_last_unchoked &lt; seconds(5)
			&amp;&amp; m_statistics.total_payload_upload() &lt; 2 * 0x4000)
		{
			// if we're have only been unchoked for a short period of time,
			// we don't know what rate we can get from this peer. Instead of assuming
			// the lowest possible rate, assume the average.

			int peers_with_requests = int(stats_counters()[counters::num_peers_down_requests]);
			// avoid division by 0
			if (peers_with_requests == 0) peers_with_requests = 1;

<div style="background: #ffff00" width="100%">			rate = t-&gt;statistics().transfer_rate(stat::download_payload) / peers_with_requests;
</div>		}
		else
		{
			// current download rate in bytes per seconds
			rate = m_statistics.transfer_rate(stat::download_payload);
		}

		// avoid division by zero
		if (rate &lt; 50) rate = 50;

		// average of current rate and peak
//		rate = (rate + m_download_rate_peak) / 2;

		return milliseconds((m_outstanding_bytes + extra_bytes
			+ m_queued_time_critical * t-&gt;block_size() * 1000) / rate);
	}

	void peer_connection::add_stat(std::int64_t const downloaded, std::int64_t const uploaded)
	{
		TORRENT_ASSERT(is_single_thread());
		m_statistics.add_stat(downloaded, uploaded);
	}

	void peer_connection::received_bytes(int const bytes_payload, int const bytes_protocol)
	{
		TORRENT_ASSERT(is_single_thread());
		m_statistics.received_bytes(bytes_payload, bytes_protocol);
		if (m_ignore_stats) return;
		std::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
		if (!t) return;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(182)">../src/peer_connection.cpp:3402</a></td><td>sort the allowed fast set in priority order</td></tr><tr id="182" style="display: none;" colspan="3"><td colspan="3"><h2>sort the allowed fast set in priority order</h2><h4>../src/peer_connection.cpp:3402</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// if the peer has the piece and we want
		// to download it, request it
		if (index &lt; m_have_piece.end_index()
			&amp;&amp; m_have_piece[index]
			&amp;&amp; !t-&gt;has_piece_passed(index)
			&amp;&amp; t-&gt;valid_metadata()
			&amp;&amp; t-&gt;has_picker()
			&amp;&amp; t-&gt;picker().piece_priority(index) &gt; dont_download)
		{
			t-&gt;peer_is_interesting(*this);
		}
	}

	std::vector&lt;piece_index_t&gt; const&amp; peer_connection::allowed_fast()
	{
		TORRENT_ASSERT(is_single_thread());
		std::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
		TORRENT_ASSERT(t);

<div style="background: #ffff00" width="100%">		return m_allowed_fast;
</div>	}

	bool peer_connection::can_request_time_critical() const
	{
		TORRENT_ASSERT(is_single_thread());
		if (has_peer_choked() || !is_interesting()) return false;
		if (int(m_download_queue.size()) + int(m_request_queue.size())
			&gt; m_desired_queue_size * 2) return false;
		if (on_parole()) return false;
		if (m_disconnecting) return false;
		std::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
		TORRENT_ASSERT(t);
		if (t-&gt;upload_mode()) return false;

		// ignore snubbed peers, since they're not likely to return pieces in a
		// timely manner anyway
		if (m_snubbed) return false;
		return true;
	}

	bool peer_connection::make_time_critical(piece_block const&amp; block)
	{
		TORRENT_ASSERT(is_single_thread());
		auto const rit = std::find_if(m_request_queue.begin()
			, m_request_queue.end(), aux::has_block(block));
		if (rit == m_request_queue.end()) return false;
#if TORRENT_USE_ASSERTS
		std::shared_ptr&lt;torrent&gt; t = m_torrent.lock();
		TORRENT_ASSERT(t);
		TORRENT_ASSERT(t-&gt;has_picker());
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(183)">../src/magnet_uri.cpp:261</a></td><td>what's the right number here?</td></tr><tr id="183" style="display: none;" colspan="3"><td colspan="3"><h2>what's the right number here?</h2><h4>../src/magnet_uri.cpp:261</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">					return;
				}
				p.info_hash = info_hash;
				has_ih = true;
			}
			else if (name == "so"_sv) // select-only (files)
			{
				// accept only digits, '-' and ','
				if (std::any_of(value.begin(), value.end(), [](char c)
					{ return !is_digit(c) &amp;&amp; c != '-' &amp;&amp; c != ','; }))
					continue;

				do
				{
					string_view token;
					std::tie(token, value) = split_string(value, ',');

					if (token.empty()) continue;

					int idx1, idx2;
<div style="background: #ffff00" width="100%">					constexpr int max_index = 10000; // can't risk out of memory
</div>
					auto const divider = token.find_first_of('-');
					if (divider != std::string::npos) // it's a range
					{
						if (divider == 0) // no start index
							continue;
						if (divider == token.size() - 1) // no end index
							continue;

						idx1 = std::atoi(token.substr(0, divider).to_string().c_str());
						if (idx1 &lt; 0 || idx1 &gt; max_index) // invalid index
							continue;
						idx2 = std::atoi(token.substr(divider + 1).to_string().c_str());
						if (idx2 &lt; 0 || idx2 &gt; max_index) // invalid index
							continue;

						if (idx1 &gt; idx2) // wrong range limits
							continue;
					}
					else // it's an index
					{
						idx1 = std::atoi(token.to_string().c_str());
						if (idx1 &lt; 0 || idx1 &gt; max_index) // invalid index
							continue;
						idx2 = idx1;
					}

					if (int(p.file_priorities.size()) &lt;= idx2)
						p.file_priorities.resize(std::size_t(idx2 + 1), dont_download);

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(184)">../src/part_file.cpp:246</a></td><td>what do we do if someone is currently reading from the disk from this piece? does it matter? Since we won't actively erase the data from disk, but it may be overwritten soon, it's probably not that big of a deal</td></tr><tr id="184" style="display: none;" colspan="3"><td colspan="3"><h2>what do we do if someone is currently reading from the disk
from this piece? does it matter? Since we won't actively erase the
data from disk, but it may be overwritten soon, it's probably not that
big of a deal</h2><h4>../src/part_file.cpp:246</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			&amp;&amp; ec == boost::system::errc::no_such_file_or_directory)
		{
			// this means the directory the file is in doesn't exist.
			// so create it
			ec.clear();
			create_directories(m_path, ec);

			if (ec) return;
			f = std::make_shared&lt;file&gt;(fn, mode, ec);
		}
		if (!ec) m_file = std::move(f);
	}

	void part_file::free_piece(piece_index_t const piece)
	{
		std::lock_guard&lt;std::mutex&gt; l(m_mutex);

		auto const i = m_piece_map.find(piece);
		if (i == m_piece_map.end()) return;

<div style="background: #ffff00" width="100%">
</div>		m_free_slots.push_back(i-&gt;second);
		m_piece_map.erase(i);
		m_dirty_metadata = true;
	}

	void part_file::move_partfile(std::string const&amp; path, error_code&amp; ec)
	{
		std::lock_guard&lt;std::mutex&gt; l(m_mutex);

		flush_metadata_impl(ec);
		if (ec) return;

		// we're only supposed to move part files from a fence job. i.e. no other
		// disk jobs are supposed to be in-flight at this point
		TORRENT_ASSERT(!m_file || m_file.unique());
		m_file.reset();

		if (!m_piece_map.empty())
		{
			std::string old_path = combine_path(m_path, m_name);
			std::string new_path = combine_path(path, m_name);

			rename(old_path, new_path, ec);
			if (ec == boost::system::errc::no_such_file_or_directory)
				ec.clear();

			if (ec)
			{
				copy_file(old_path, new_path, ec);
				if (ec) return;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(185)">../src/part_file.cpp:358</a></td><td>instead of rebuilding the whole file header and flushing it, update the slot entries as we go</td></tr><tr id="185" style="display: none;" colspan="3"><td colspan="3"><h2>instead of rebuilding the whole file header
and flushing it, update the slot entries as we go</h2><h4>../src/part_file.cpp:358</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">						TORRENT_ASSERT(j-&gt;second == slot);
						m_free_slots.push_back(j-&gt;second);
						m_piece_map.erase(j);
						m_dirty_metadata = true;
					}
				}
			}
			file_offset += block_to_copy;
			piece_offset = 0;
			size -= block_to_copy;
		}
	}

	void part_file::flush_metadata(error_code&amp; ec)
	{
		std::lock_guard&lt;std::mutex&gt; l(m_mutex);

		flush_metadata_impl(ec);
	}

<div style="background: #ffff00" width="100%">	void part_file::flush_metadata_impl(error_code&amp; ec)
</div>	{
		// do we need to flush the metadata?
		if (m_dirty_metadata == false) return;

		if (m_piece_map.empty())
		{
			m_file.reset();

			// if we don't have any pieces left in the
			// part file, remove it
			std::string const p = combine_path(m_path, m_name);
			remove(p, ec);

			if (ec == boost::system::errc::no_such_file_or_directory)
				ec.clear();
			return;
		}

		open_file(open_mode::read_write | open_mode::attribute_hidden, ec);
		if (ec) return;

		std::vector&lt;char&gt; header(static_cast&lt;std::size_t&gt;(m_header_size));

		using namespace libtorrent::detail;

		char* ptr = header.data();
		write_uint32(m_max_pieces, ptr);
		write_uint32(m_piece_size, ptr);

		for (piece_index_t piece(0); piece &lt; piece_index_t(m_max_pieces); ++piece)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(186)">../src/packet_buffer.cpp:155</a></td><td>use compare_less_wrap for this comparison as well</td></tr><tr id="186" style="display: none;" colspan="3"><td colspan="3"><h2>use compare_less_wrap for this comparison as well</h2><h4>../src/packet_buffer.cpp:155</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	{
		INVARIANT_CHECK;
		TORRENT_ASSERT_VAL(size &lt;= 0xffff, size);
		std::uint32_t new_size = m_capacity == 0 ? 16 : m_capacity;

		while (new_size &lt; size)
			new_size &lt;&lt;= 1;

		aux::unique_ptr&lt;packet_ptr[], index_type&gt; new_storage(new packet_ptr[new_size]);

		for (index_type i = m_first; i &lt; (m_first + m_capacity); ++i)
			new_storage[i &amp; (new_size - 1)] = std::move(m_storage[i &amp; (m_capacity - 1)]);

		m_storage = std::move(new_storage);
		m_capacity = new_size;
	}

	packet_ptr packet_buffer::remove(index_type idx)
	{
		INVARIANT_CHECK;
<div style="background: #ffff00" width="100%">		if (idx &gt;= m_first + m_capacity)
</div>			return packet_ptr();

		if (compare_less_wrap(idx, m_first, 0xffff))
			return packet_ptr();

		std::size_t const mask = m_capacity - 1;
		packet_ptr old_value = std::move(m_storage[idx &amp; mask]);
		m_storage[idx &amp; mask].reset();

		if (old_value)
		{
			--m_size;
			if (m_size == 0) m_last = m_first;
		}

		if (idx == m_first &amp;&amp; m_size != 0)
		{
			++m_first;
			for (index_type i = 0; i &lt; m_capacity; ++i, ++m_first)
				if (m_storage[m_first &amp; mask]) break;
			m_first &amp;= 0xffff;
		}

		if (((idx + 1) &amp; 0xffff) == m_last &amp;&amp; m_size != 0)
		{
			--m_last;
			for (index_type i = 0; i &lt; m_capacity; ++i, --m_last)
				if (m_storage[m_last &amp; mask]) break;
			++m_last;
			m_last &amp;= 0xffff;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(187)">../src/session_impl.cpp:1246</a></td><td>it would be nice to reserve() these vectors up front</td></tr><tr id="187" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to reserve() these vectors up front</h2><h4>../src/session_impl.cpp:1246</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			bandwidth_channel* ch = &amp;p-&gt;channel[peer_connection::download_channel];
			if (use_quota_overhead(ch, amount_down))
				ret |= 1 &lt;&lt; peer_connection::download_channel;
			ch = &amp;p-&gt;channel[peer_connection::upload_channel];
			if (use_quota_overhead(ch, amount_up))
				ret |= 1 &lt;&lt; peer_connection::upload_channel;
		}
		return ret;
	}

	// session_impl is responsible for deleting 'pack'
	void session_impl::apply_settings_pack(std::shared_ptr&lt;settings_pack&gt; pack)
	{
		INVARIANT_CHECK;
		apply_settings_pack_impl(*pack);
	}

	settings_pack session_impl::get_settings() const
	{
		settings_pack ret;
<div style="background: #ffff00" width="100%">		for (int i = settings_pack::string_type_base;
</div>			i &lt; settings_pack::max_string_setting_internal; ++i)
		{
			ret.set_str(i, m_settings.get_str(i));
		}
		for (int i = settings_pack::int_type_base;
			i &lt; settings_pack::max_int_setting_internal; ++i)
		{
			ret.set_int(i, m_settings.get_int(i));
		}
		for (int i = settings_pack::bool_type_base;
			i &lt; settings_pack::max_bool_setting_internal; ++i)
		{
			ret.set_bool(i, m_settings.get_bool(i));
		}
		return ret;
	}

	void session_impl::apply_settings_pack_impl(settings_pack const&amp; pack)
	{
		bool const reopen_listen_port =
#if TORRENT_ABI_VERSION == 1
			(pack.has_val(settings_pack::ssl_listen)
				&amp;&amp; pack.get_int(settings_pack::ssl_listen)
					!= m_settings.get_int(settings_pack::ssl_listen))
			||
#endif
			(pack.has_val(settings_pack::listen_interfaces)
				&amp;&amp; pack.get_str(settings_pack::listen_interfaces)
					!= m_settings.get_str(settings_pack::listen_interfaces));

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(188)">../src/session_impl.cpp:3335</a></td><td>have a separate list for these connections, instead of having to loop through all of them</td></tr><tr id="188" style="display: none;" colspan="3"><td colspan="3"><h2>have a separate list for these connections, instead of having to loop through all of them</h2><h4>../src/session_impl.cpp:3335</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// --------------------------------------------------------------
		if (!m_paused) m_auto_manage_time_scaler--;
		if (m_auto_manage_time_scaler &lt; 0)
		{
			m_auto_manage_time_scaler = settings().get_int(settings_pack::auto_manage_interval);
			recalculate_auto_managed_torrents();
		}

		// --------------------------------------------------------------
		// check for incoming connections that might have timed out
		// --------------------------------------------------------------

		for (auto i = m_connections.begin(); i != m_connections.end();)
		{
			peer_connection* p = (*i).get();
			++i;
			// ignore connections that already have a torrent, since they
			// are ticked through the torrents' second_tick
			if (!p-&gt;associated_torrent().expired()) continue;

<div style="background: #ffff00" width="100%">			int timeout = m_settings.get_int(settings_pack::handshake_timeout);
</div>#if TORRENT_USE_I2P
			timeout *= is_i2p(*p-&gt;get_socket()) ? 4 : 1;
#endif
			if (m_last_tick - p-&gt;connected_time () &gt; seconds(timeout))
				p-&gt;disconnect(errors::timed_out, operation_t::bittorrent);
		}

		// --------------------------------------------------------------
		// second_tick every torrent (that wants it)
		// --------------------------------------------------------------

#if TORRENT_DEBUG_STREAMING &gt; 0
		std::printf("\033[2J\033[0;0H");
#endif

		aux::vector&lt;torrent*&gt;&amp; want_tick = m_torrent_lists[torrent_want_tick];
		for (int i = 0; i &lt; int(want_tick.size()); ++i)
		{
			torrent&amp; t = *want_tick[i];
			TORRENT_ASSERT(t.want_tick());
			TORRENT_ASSERT(!t.is_aborted());

			t.second_tick(tick_interval_ms);

			// if the call to second_tick caused the torrent
			// to no longer want to be ticked (i.e. it was
			// removed from the list) we need to back up the counter
			// to not miss the torrent after it
			if (!t.want_tick()) --i;
		}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(189)">../src/session_impl.cpp:3368</a></td><td>this should apply to all bandwidth channels</td></tr><tr id="189" style="display: none;" colspan="3"><td colspan="3"><h2>this should apply to all bandwidth channels</h2><h4>../src/session_impl.cpp:3368</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#if TORRENT_DEBUG_STREAMING &gt; 0
		std::printf("\033[2J\033[0;0H");
#endif

		aux::vector&lt;torrent*&gt;&amp; want_tick = m_torrent_lists[torrent_want_tick];
		for (int i = 0; i &lt; int(want_tick.size()); ++i)
		{
			torrent&amp; t = *want_tick[i];
			TORRENT_ASSERT(t.want_tick());
			TORRENT_ASSERT(!t.is_aborted());

			t.second_tick(tick_interval_ms);

			// if the call to second_tick caused the torrent
			// to no longer want to be ticked (i.e. it was
			// removed from the list) we need to back up the counter
			// to not miss the torrent after it
			if (!t.want_tick()) --i;
		}

<div style="background: #ffff00" width="100%">		if (m_settings.get_bool(settings_pack::rate_limit_ip_overhead))
</div>		{
			int const up_limit = upload_rate_limit(m_global_class);
			int const down_limit = download_rate_limit(m_global_class);

			if (down_limit &gt; 0
				&amp;&amp; m_stat.download_ip_overhead() &gt;= down_limit
				&amp;&amp; m_alerts.should_post&lt;performance_alert&gt;())
			{
				m_alerts.emplace_alert&lt;performance_alert&gt;(torrent_handle()
					, performance_alert::download_limit_too_low);
			}

			if (up_limit &gt; 0
				&amp;&amp; m_stat.upload_ip_overhead() &gt;= up_limit
				&amp;&amp; m_alerts.should_post&lt;performance_alert&gt;())
			{
				m_alerts.emplace_alert&lt;performance_alert&gt;(torrent_handle()
					, performance_alert::upload_limit_too_low);
			}
		}

		m_peak_up_rate = std::max(m_stat.upload_rate(), m_peak_up_rate);
		m_peak_down_rate = std::max(m_stat.download_rate(), m_peak_down_rate);

		m_stat.second_tick(tick_interval_ms);

		// --------------------------------------------------------------
		// scrape paused torrents that are auto managed
		// (unless the session is paused)
		// --------------------------------------------------------------
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(190)">../src/session_impl.cpp:4090</a></td><td>use a lower limit than m_settings.connections_limit to allocate the to 10% or so of connection slots for incoming connections cap this at max - 1, since we may add one below</td></tr><tr id="190" style="display: none;" colspan="3"><td colspan="3"><h2>use a lower limit than m_settings.connections_limit
to allocate the to 10% or so of connection slots for incoming
connections
cap this at max - 1, since we may add one below</h2><h4>../src/session_impl.cpp:4090</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// boost, which are done immediately on a tracker response. These
		// connections needs to be deducted from the regular connection attempt
		// quota for this tick
		if (m_boost_connections &gt; 0)
		{
			if (m_boost_connections &gt; max_connections)
			{
				m_boost_connections -= max_connections;
				max_connections = 0;
			}
			else
			{
				max_connections -= m_boost_connections;
				m_boost_connections = 0;
			}
		}

		// zero connections speeds are allowed, we just won't make any connections
		if (max_connections &lt;= 0) return;

<div style="background: #ffff00" width="100%">		int const limit = std::min(m_settings.get_int(settings_pack::connections_limit)
</div>			- num_connections(), std::numeric_limits&lt;int&gt;::max() - 1);

		// this logic is here to smooth out the number of new connection
		// attempts over time, to prevent connecting a large number of
		// sockets, wait 10 seconds, and then try again
		if (m_settings.get_bool(settings_pack::smooth_connects) &amp;&amp; max_connections &gt; (limit+1) / 2)
			max_connections = (limit + 1) / 2;

		aux::vector&lt;torrent*&gt;&amp; want_peers_download = m_torrent_lists[torrent_want_peers_download];
		aux::vector&lt;torrent*&gt;&amp; want_peers_finished = m_torrent_lists[torrent_want_peers_finished];

		// if no torrent want any peers, just return
		if (want_peers_download.empty() &amp;&amp; want_peers_finished.empty()) return;

		// if we don't have any connection attempt quota, return
		if (max_connections &lt;= 0) return;

		int steps_since_last_connect = 0;
		int const num_torrents = int(want_peers_finished.size() + want_peers_download.size());
		for (;;)
		{
			if (m_next_downloading_connect_torrent &gt;= int(want_peers_download.size()))
				m_next_downloading_connect_torrent = 0;

			if (m_next_finished_connect_torrent &gt;= int(want_peers_finished.size()))
				m_next_finished_connect_torrent = 0;

			torrent* t = nullptr;
			// there are prioritized torrents. Pick one of those
			while (!m_prio_torrents.empty())
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(191)">../src/session_impl.cpp:4227</a></td><td>post a message to have this happen immediately instead of waiting for the next tick</td></tr><tr id="191" style="display: none;" colspan="3"><td colspan="3"><h2>post a message to have this happen
immediately instead of waiting for the next tick</h2><h4>../src/session_impl.cpp:4227</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				continue;
			}

			if (!p-&gt;is_peer_interested()
				|| p-&gt;is_disconnecting()
				|| p-&gt;is_connecting())
			{
				// this peer is not unchokable. So, if it's unchoked
				// already, make sure to choke it.
				if (p-&gt;is_choked())
				{
					p-&gt;reset_choke_counters();
					continue;
				}
				if (pi &amp;&amp; pi-&gt;optimistically_unchoked)
				{
					m_stats_counters.inc_stats_counter(counters::num_peers_up_unchoked_optimistic, -1);
					pi-&gt;optimistically_unchoked = false;
					// force a new optimistic unchoke
					m_optimistic_unchoke_time_scaler = 0;
<div style="background: #ffff00" width="100%">				}
</div>				t-&gt;choke_peer(*p);
				p-&gt;reset_choke_counters();
				continue;
			}

			peers.push_back(p.get());
		}

		// the unchoker wants an estimate of our upload rate capacity
		// (used by bittyrant)
		int max_upload_rate = upload_rate_limit(m_global_class);
		if (m_settings.get_int(settings_pack::choking_algorithm)
			== settings_pack::bittyrant_choker
			&amp;&amp; max_upload_rate == 0)
		{
			// we don't know at what rate we can upload. If we have a
			// measurement of the peak, use that + 10kB/s, otherwise
			// assume 20 kB/s
			max_upload_rate = std::max(20000, m_peak_up_rate + 10000);
			if (m_alerts.should_post&lt;performance_alert&gt;())
				m_alerts.emplace_alert&lt;performance_alert&gt;(torrent_handle()
					, performance_alert::bittyrant_with_no_uplimit);
		}

		int const allowed_upload_slots = unchoke_sort(peers, max_upload_rate
			, unchoke_interval, m_settings);

		m_stats_counters.set_value(counters::num_unchoke_slots
			, allowed_upload_slots);

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(192)">../src/session_impl.cpp:4573</a></td><td>it might be a nice feature here to limit the number of torrents to send in a single update. By just posting the first n torrents, they would nicely be round-robined because the torrent lists are always pushed back. Perhaps the status_update_alert could even have a fixed array of n entries rather than a vector, to further improve memory locality.</td></tr><tr id="192" style="display: none;" colspan="3"><td colspan="3"><h2>it might be a nice feature here to limit the number of torrents
to send in a single update. By just posting the first n torrents, they
would nicely be round-robined because the torrent lists are always
pushed back. Perhaps the status_update_alert could even have a fixed
array of n entries rather than a vector, to further improve memory
locality.</h2><h4>../src/session_impl.cpp:4573</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			t-&gt;status(&amp;st, flags);
		}
	}

	void session_impl::post_torrent_updates(status_flags_t const flags)
	{
		INVARIANT_CHECK;

		TORRENT_ASSERT(is_single_thread());

		std::vector&lt;torrent*&gt;&amp; state_updates
			= m_torrent_lists[aux::session_impl::torrent_state_updates];

#if TORRENT_USE_ASSERTS
		m_posting_torrent_updates = true;
#endif

		std::vector&lt;torrent_status&gt; status;
		status.reserve(state_updates.size());

<div style="background: #ffff00" width="100%">		for (auto&amp; t : state_updates)
</div>		{
			TORRENT_ASSERT(t-&gt;m_links[aux::session_impl::torrent_state_updates].in_list());
			status.emplace_back();
			// querying accurate download counters may require
			// the torrent to be loaded. Loading a torrent, and evicting another
			// one will lead to calling state_updated(), which screws with
			// this list while we're working on it, and break things
			t-&gt;status(&amp;status.back(), flags);
			t-&gt;clear_in_state_update();
		}
		state_updates.clear();

#if TORRENT_USE_ASSERTS
		m_posting_torrent_updates = false;
#endif

		m_alerts.emplace_alert&lt;state_update_alert&gt;(std::move(status));
	}

	void session_impl::post_session_stats()
	{
		if (!m_posted_stats_header)
		{
			m_posted_stats_header = true;
			m_alerts.emplace_alert&lt;session_stats_header_alert&gt;();
		}
		m_disk_thread.update_stats_counters(m_stats_counters);

#ifndef TORRENT_DISABLE_DHT
		if (m_dht)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(193)">../src/session_impl.cpp:5777</a></td><td>refactor, move the storage to dht_tracker</td></tr><tr id="193" style="display: none;" colspan="3"><td colspan="3"><h2>refactor, move the storage to dht_tracker</h2><h4>../src/session_impl.cpp:5777</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			session_log("not starting DHT, outstanding router lookups: %d"
				, m_outstanding_router_lookups);
#endif
			return;
		}

		if (m_abort)
		{
#ifndef TORRENT_DISABLE_LOGGING
			session_log("not starting DHT, aborting");
#endif
			return;
		}

#ifndef TORRENT_DISABLE_LOGGING
		session_log("starting DHT, running: %s, router lookups: %d, aborting: %s"
			, m_dht ? "true" : "false", m_outstanding_router_lookups
			, m_abort ? "true" : "false");
#endif

<div style="background: #ffff00" width="100%">		m_dht_storage = m_dht_storage_constructor(m_dht_settings);
</div>		m_dht = std::make_shared&lt;dht::dht_tracker&gt;(
			static_cast&lt;dht::dht_observer*&gt;(this)
			, m_io_service
			, [=](aux::listen_socket_handle const&amp; sock
				, udp::endpoint const&amp; ep
				, span&lt;char const&gt; p
				, error_code&amp; ec
				, udp_send_flags_t const flags)
				{ send_udp_packet_listen(sock, ep, p, ec, flags); }
			, m_dht_settings
			, m_stats_counters
			, *m_dht_storage
			, std::move(m_dht_state));

		for (auto&amp; s : m_listen_sockets)
			m_dht-&gt;new_socket(s);

		for (auto const&amp; n : m_dht_router_nodes)
		{
			m_dht-&gt;add_router_node(n);
		}

		for (auto const&amp; n : m_dht_nodes)
		{
			m_dht-&gt;add_node(n);
		}
		m_dht_nodes.clear();
		m_dht_nodes.shrink_to_fit();

		auto cb = [this](
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(194)">../src/session_impl.cpp:6099</a></td><td>asserts that no outstanding async operations are still in flight</td></tr><tr id="194" style="display: none;" colspan="3"><td colspan="3"><h2>asserts that no outstanding async operations are still in flight</h2><h4>../src/session_impl.cpp:6099</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	void session_impl::add_obfuscated_hash(sha1_hash const&amp; obfuscated
		, std::weak_ptr&lt;torrent&gt; const&amp; t)
	{
		m_obfuscated_torrents.insert(std::make_pair(obfuscated, t.lock()));
	}
#endif // TORRENT_DISABLE_ENCRYPTION

	bool session_impl::is_listening() const
	{
		return !m_listen_sockets.empty();
	}

	session_impl::~session_impl()
	{
		// since we're destructing the session, no more alerts will make it out to
		// the user. So stop posting them now
		m_alerts.set_alert_mask({});

		// this is not allowed to be the network thread!
//		TORRENT_ASSERT(is_not_thread());
<div style="background: #ffff00" width="100%">
</div>		// this can happen if we end the io_service run loop with an exception
		for (auto&amp; t : m_torrents)
		{
			t.second-&gt;panic();
			t.second-&gt;abort();
		}
		m_torrents.clear();

#if defined TORRENT_ASIO_DEBUGGING
		FILE* f = fopen("wakeups.log", "w+");
		if (f != nullptr)
		{
			time_point m = min_time();
			if (!_wakeups.empty()) m = _wakeups[0].timestamp;
			time_point prev = m;
			std::uint64_t prev_csw = 0;
			if (!_wakeups.empty()) prev_csw = _wakeups[0].context_switches;
			std::fprintf(f, "abs. time\trel. time\tctx switch\tidle-wakeup\toperation\n");
			for (wakeup_t const&amp; w : _wakeups)
			{
				bool const idle_wakeup = w.context_switches &gt; prev_csw;
				std::fprintf(f, "%" PRId64 "\t%" PRId64 "\t%" PRId64 "\t%c\t%s\n"
					, total_microseconds(w.timestamp - m)
					, total_microseconds(w.timestamp - prev)
					, w.context_switches
					, idle_wakeup ? '*' : '.'
					, w.operation);
				prev = w.timestamp;
				prev_csw = w.context_switches;
			}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(195)">../src/session_impl.cpp:6894</a></td><td>remove this function once all callers are updated to specify a listen socket</td></tr><tr id="195" style="display: none;" colspan="3"><td colspan="3"><h2>remove this function once all callers are updated to specify a listen socket</h2><h4>../src/session_impl.cpp:6894</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	{
#ifndef TORRENT_DISABLE_EXTENSIONS
		for (auto const&amp; ext : m_ses_extensions[plugins_dht_request_idx])
		{
			if (ext-&gt;on_dht_request(query
				, request.addr, request.message, response))
				return true;
		}
#else
		TORRENT_UNUSED(query);
		TORRENT_UNUSED(request);
		TORRENT_UNUSED(response);
#endif
		return false;
	}

	void session_impl::set_external_address(address const&amp; ip
		, ip_source_t const source_type, address const&amp; source)
	{
		// for now, just pick the first socket with a matching address family
<div style="background: #ffff00" width="100%">		for (auto&amp; i : m_listen_sockets)
</div>		{
			if (is_v4(i-&gt;local_endpoint) != ip.is_v4())
				continue;

			set_external_address(i, ip, source_type, source);
			break;
		}
	}

	void session_impl::set_external_address(
		tcp::endpoint const&amp; local_endpoint, address const&amp; ip
		, ip_source_t const source_type, address const&amp; source)
	{
		auto sock = std::find_if(m_listen_sockets.begin(), m_listen_sockets.end()
			, [&amp;](std::shared_ptr&lt;listen_socket_t&gt; const&amp; v) { return v-&gt;local_endpoint == local_endpoint; });

		if (sock != m_listen_sockets.end())
			set_external_address(*sock, ip, source_type, source);
	}

	void session_impl::set_external_address(std::shared_ptr&lt;listen_socket_t&gt; const&amp; sock
		, address const&amp; ip, ip_source_t const source_type, address const&amp; source)
	{
		if (!sock-&gt;external_address.cast_vote(ip, source_type, source)) return;

#ifndef TORRENT_DISABLE_LOGGING
		if (should_log())
		{
			session_log("external address updated for %s [ new-ip: %s type: %d last-voter: %s ]"
				, sock-&gt;device.empty() ? print_endpoint(sock-&gt;local_endpoint).c_str() : sock-&gt;device.c_str()
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(196)">../src/ip_notifier.cpp:37</a></td><td>simulator support</td></tr><tr id="196" style="display: none;" colspan="3"><td colspan="3"><h2>simulator support</h2><h4>../src/ip_notifier.cpp:37</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

*/

#include "libtorrent/aux_/ip_notifier.hpp"
#include "libtorrent/assert.hpp"

#if defined TORRENT_BUILD_SIMULATOR
<div style="background: #ffff00" width="100%">#elif TORRENT_USE_NETLINK
</div>#include "libtorrent/netlink.hpp"
#include "libtorrent/socket.hpp"
#include &lt;array&gt;
#elif TORRENT_USE_SYSTEMCONFIGURATION
#include &lt;SystemConfiguration/SystemConfiguration.h&gt;
#elif defined TORRENT_WINDOWS
#include "libtorrent/aux_/throw.hpp"
#include "libtorrent/aux_/disable_warnings_push.hpp"
#include &lt;boost/asio/windows/object_handle.hpp&gt;
#include &lt;iphlpapi.h&gt;
#include "libtorrent/aux_/disable_warnings_pop.hpp"
#endif

namespace libtorrent { namespace aux {

namespace {

#if defined TORRENT_BUILD_SIMULATOR
struct ip_change_notifier_impl final : ip_change_notifier
{
	explicit ip_change_notifier_impl(io_service&amp; ios)
		: m_ios(ios) {}

	void async_wait(std::function&lt;void(error_code const&amp;)&gt; cb) override
	{
		m_ios.post([cb]()
		{ cb(make_error_code(boost::system::errc::not_supported)); });
	}

	void cancel() override {}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(197)">../src/cpuid.cpp:128</a></td><td>enable when aarch64 is really tested</td></tr><tr id="197" style="display: none;" colspan="3"><td colspan="3"><h2>enable when aarch64 is really tested</h2><h4>../src/cpuid.cpp:128</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	bool supports_mmx()
	{
#if TORRENT_HAS_SSE
		std::uint32_t cpui[4] = {0};
		cpuid(cpui, 1);
		return (cpui[2] &amp; (1 &lt;&lt; 23)) != 0;
#else
		return false;
#endif
	}

	bool supports_arm_neon()
	{
#if TORRENT_HAS_ARM_NEON &amp;&amp; TORRENT_HAS_AUXV
#if defined __arm__
		//return (getauxval(AT_HWCAP) &amp; HWCAP_NEON);
		return (helper_getauxval(16) &amp; (1 &lt;&lt; 12));
#elif defined __aarch64__
		//return (getauxval(AT_HWCAP) &amp; HWCAP_ASIMD);
		//return (getauxval(16) &amp; (1 &lt;&lt; 1));
<div style="background: #ffff00" width="100%">		return false;
</div>#endif
#else
		return false;
#endif
	}

	bool supports_arm_crc32c()
	{
#if TORRENT_HAS_ARM_CRC32 &amp;&amp; TORRENT_HAS_AUXV
#if defined TORRENT_FORCE_ARM_CRC32
		return true;
#elif defined __arm__
		//return (getauxval(AT_HWCAP2) &amp; HWCAP2_CRC32);
		return (helper_getauxval(26) &amp; (1 &lt;&lt; 4));
#elif defined __aarch64__
		//return (getauxval(AT_HWCAP) &amp; HWCAP_CRC32);
		return (helper_getauxval(16) &amp; (1 &lt;&lt; 7));
#endif
#else
		return false;
#endif
	}

	} // anonymous namespace

	bool const sse42_support = supports_sse42();
	bool const mmx_support = supports_mmx();
	bool const arm_neon_support = supports_arm_neon();
	bool const arm_crc32c_support = supports_arm_crc32c();
} }
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(198)">../src/add_torrent_params.cpp:76</a></td><td>pre C++17, GCC and msvc does not make std::string nothrow move assignable, which means no type containing a string will be nothrow move assignable by default either static_assert(std::is_nothrow_move_assignable<add_torrent_params>::value , "should be nothrow move assignable");</td></tr><tr id="198" style="display: none;" colspan="3"><td colspan="3"><h2>pre C++17, GCC and msvc does not make std::string nothrow move
assignable, which means no type containing a string will be nothrow move
assignable by default either
static_assert(std::is_nothrow_move_assignable<add_torrent_params>::value
, "should be nothrow move assignable");</h2><h4>../src/add_torrent_params.cpp:76</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			DECL_FLAG(sequential_download);
			DECL_FLAG(pinned);
			DECL_FLAG(stop_when_ready);
			DECL_FLAG(override_trackers);
			DECL_FLAG(override_web_seeds);
			DECL_FLAG(need_save_resume);
			DECL_FLAG(override_resume_data);
			DECL_FLAG(merge_resume_trackers);
			DECL_FLAG(use_resume_save_path);
			DECL_FLAG(merge_resume_http_seeds);
			DECL_FLAG(default_flags);
#undef DECL_FLAG
#endif // TORRENT_ABI_VERSION

	static_assert(std::is_nothrow_move_constructible&lt;add_torrent_params&gt;::value
		, "should be nothrow move constructible");

	static_assert(std::is_nothrow_move_constructible&lt;std::string&gt;::value
		, "should be nothrow move constructible");

<div style="background: #ffff00" width="100%">
</div></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(199)">../src/add_torrent_params.cpp:82</a></td><td>it would be nice if this was nothrow default constructible static_assert(std::is_nothrow_default_constructible<add_torrent_params>::value , "should be nothrow default constructible");</td></tr><tr id="199" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice if this was nothrow default constructible
static_assert(std::is_nothrow_default_constructible<add_torrent_params>::value
, "should be nothrow default constructible");</h2><h4>../src/add_torrent_params.cpp:82</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			DECL_FLAG(pinned);
			DECL_FLAG(stop_when_ready);
			DECL_FLAG(override_trackers);
			DECL_FLAG(override_web_seeds);
			DECL_FLAG(need_save_resume);
			DECL_FLAG(override_resume_data);
			DECL_FLAG(merge_resume_trackers);
			DECL_FLAG(use_resume_save_path);
			DECL_FLAG(merge_resume_http_seeds);
			DECL_FLAG(default_flags);
#undef DECL_FLAG
#endif // TORRENT_ABI_VERSION

	static_assert(std::is_nothrow_move_constructible&lt;add_torrent_params&gt;::value
		, "should be nothrow move constructible");

	static_assert(std::is_nothrow_move_constructible&lt;std::string&gt;::value
		, "should be nothrow move constructible");


<div style="background: #ffff00" width="100%">}
</div></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(200)">../src/torrent.cpp:98</a></td><td>factor out cache_status to its own header</td></tr><tr id="200" style="display: none;" colspan="3"><td colspan="3"><h2>factor out cache_status to its own header</h2><h4>../src/torrent.cpp:98</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#include "libtorrent/kademlia/dht_tracker.hpp"
#include "libtorrent/peer_info.hpp"
#include "libtorrent/http_connection.hpp"
#include "libtorrent/random.hpp"
#include "libtorrent/peer_class.hpp" // for peer_class
#include "libtorrent/socket_io.hpp" // for read_*_endpoint
#include "libtorrent/ip_filter.hpp"
#include "libtorrent/request_blocks.hpp"
#include "libtorrent/performance_counters.hpp" // for counters
#include "libtorrent/resolver_interface.hpp"
#include "libtorrent/aux_/alloca.hpp"
#include "libtorrent/resolve_links.hpp"
#include "libtorrent/aux_/file_progress.hpp"
#include "libtorrent/aux_/has_block.hpp"
#include "libtorrent/alert_manager.hpp"
#include "libtorrent/disk_interface.hpp"
#include "libtorrent/broadcast_socket.hpp" // for is_ip_address
#include "libtorrent/download_priority.hpp"
#include "libtorrent/hex.hpp" // to_hex
#include "libtorrent/aux_/range.hpp"
<div style="background: #ffff00" width="100%">#include "libtorrent/disk_io_thread.hpp" // for cache_status
</div>#include "libtorrent/aux_/numeric_cast.hpp"
#include "libtorrent/aux_/path.hpp"
#include "libtorrent/aux_/generate_peer_id.hpp"

#ifndef TORRENT_DISABLE_LOGGING
#include "libtorrent/aux_/session_impl.hpp" // for tracker_logger
#endif

#include "libtorrent/aux_/torrent_impl.hpp"

using namespace std::placeholders;

namespace libtorrent {
namespace {

bool is_downloading_state(int const st)
{
	switch (st)
	{
		case torrent_status::checking_files:
		case torrent_status::allocating:
		case torrent_status::checking_resume_data:
			return false;
		case torrent_status::downloading_metadata:
		case torrent_status::downloading:
		case torrent_status::finished:
		case torrent_status::seeding:
			return true;
		default:
			// unexpected state
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(201)">../src/torrent.cpp:331</a></td><td>if this is a merkle torrent and we can't restore the tree, we need to wipe all the bits in the have array, but not necessarily we might want to do a full check to see if we have all the pieces. This is low priority since almost no one uses merkle torrents</td></tr><tr id="201" style="display: none;" colspan="3"><td colspan="3"><h2>if this is a merkle torrent and we can't
restore the tree, we need to wipe all the
bits in the have array, but not necessarily
we might want to do a full check to see if we have
all the pieces. This is low priority since almost
no one uses merkle torrents</h2><h4>../src/torrent.cpp:331</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		std::sort(m_trackers.begin(), m_trackers.end()
			, [] (announce_entry const&amp; lhs, announce_entry const&amp; rhs)
			{ return lhs.tier &lt; rhs.tier; });

		if (settings().get_bool(settings_pack::prefer_udp_trackers))
			prioritize_udp_trackers();

		// --- MERKLE TREE ---

		if (m_torrent_file-&gt;is_valid()
			&amp;&amp; m_torrent_file-&gt;is_merkle_torrent())
		{
			if (p.merkle_tree.size() == m_torrent_file-&gt;merkle_tree().size())
			{
				std::vector&lt;sha1_hash&gt; tree(p.merkle_tree);
				m_torrent_file-&gt;set_merkle_tree(tree);
			}
			else
			{
<div style="background: #ffff00" width="100%">				TORRENT_ASSERT_FAIL();
</div>			}
		}

		if (m_torrent_file-&gt;is_valid())
		{
			// setting file- or piece priorities for seed mode makes no sense. If a
			// torrent ends up in seed mode by accident, it can be very confusing,
			// so assume the seed mode flag is not intended and don't enable it in
			// that case. Also, if the resume data says we're missing a piece, we
			// can't be in seed-mode.
			m_seed_mode = (p.flags &amp; torrent_flags::seed_mode)
				&amp;&amp; std::find(p.file_priorities.begin(), p.file_priorities.end(), dont_download) == p.file_priorities.end()
				&amp;&amp; std::find(p.piece_priorities.begin(), p.piece_priorities.end(), dont_download) == p.piece_priorities.end()
				&amp;&amp; std::find(p.have_pieces.begin(), p.have_pieces.end(), false) == p.have_pieces.end();

			m_connections_initialized = true;
		}
		else
		{
			if (!p.name.empty()) m_name.reset(new std::string(p.name));
		}

#if TORRENT_ABI_VERSION == 1
		// deprecated in 1.2
		if (!m_url.empty() &amp;&amp; m_uuid.empty()) m_uuid = m_url;
#endif

		TORRENT_ASSERT(is_single_thread());
		m_file_priority.assign(p.file_priorities.begin(), p.file_priorities.end());

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(202)">../src/torrent.cpp:460</a></td><td>if the existing torrent doesn't have metadata, insert the metadata we just downloaded into it.</td></tr><tr id="202" style="display: none;" colspan="3"><td colspan="3"><h2>if the existing torrent doesn't have metadata, insert
the metadata we just downloaded into it.</h2><h4>../src/torrent.cpp:460</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			alerts().emplace_alert&lt;torrent_update_alert&gt;(get_handle(), info_hash(), tf-&gt;info_hash());

		m_torrent_file = tf;
		m_info_hash = tf-&gt;info_hash();

		// now, we might already have this torrent in the session.
		std::shared_ptr&lt;torrent&gt; t = m_ses.find_torrent(m_torrent_file-&gt;info_hash()).lock();
		if (t)
		{
			if (!m_uuid.empty() &amp;&amp; t-&gt;uuid().empty())
				t-&gt;set_uuid(m_uuid);
			if (!m_url.empty() &amp;&amp; t-&gt;url().empty())
				t-&gt;set_url(m_url);

			// insert this torrent in the uuid index
			if (!m_uuid.empty() || !m_url.empty())
			{
				m_ses.insert_uuid_torrent(m_uuid.empty() ? m_url : m_uuid, t);
			}

<div style="background: #ffff00" width="100%">
</div>			set_error(errors::duplicate_torrent, torrent_status::error_file_url);
			abort();
			return;
		}

		m_ses.insert_torrent(m_torrent_file-&gt;info_hash(), me, m_uuid);

		// if the user added any trackers while downloading the
		// .torrent file, merge them into the new tracker list
		std::vector&lt;announce_entry&gt; new_trackers = m_torrent_file-&gt;trackers();
		for (auto const&amp; tr : m_trackers)
		{
			// if we already have this tracker, ignore it
			if (std::any_of(new_trackers.begin(), new_trackers.end()
				, [&amp;tr] (announce_entry const&amp; ae) { return ae.url == tr.url; }))
				continue;

			// insert the tracker ordered by tier
			new_trackers.insert(std::find_if(new_trackers.begin(), new_trackers.end()
				, [&amp;tr] (announce_entry const&amp; ae) { return ae.tier &gt;= tr.tier; }), tr);
		}
		m_trackers.swap(new_trackers);

		// add the web seeds from the .torrent file
		std::vector&lt;web_seed_entry&gt; const&amp; web_seeds = m_torrent_file-&gt;web_seeds();
		std::vector&lt;web_seed_t&gt; ws(web_seeds.begin(), web_seeds.end());
		aux::random_shuffle(ws.begin(), ws.end());
		for (auto&amp; w : ws) m_web_seeds.push_back(std::move(w));

#if !defined TORRENT_DISABLE_ENCRYPTION
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(203)">../src/torrent.cpp:1473</a></td><td>is verify_peer_cert called once per certificate in the chain, and this function just tells us which depth we're at right now? If so, the comment makes sense. any certificate that isn't the leaf (i.e. the one presented by the peer) should be accepted automatically, given preverified is true. The leaf certificate need to be verified to make sure its DN matches the info-hash</td></tr><tr id="203" style="display: none;" colspan="3"><td colspan="3"><h2>is verify_peer_cert called once per certificate in the chain, and
this function just tells us which depth we're at right now? If so, the comment
makes sense.
any certificate that isn't the leaf (i.e. the one presented by the peer)
should be accepted automatically, given preverified is true. The leaf certificate
need to be verified to make sure its DN matches the info-hash</h2><h4>../src/torrent.cpp:1473</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// if files are checked for this torrent, call the extension
		// to let it initialize itself
		if (m_connections_initialized)
			tp-&gt;on_files_checked();
	}

#endif

#ifdef TORRENT_USE_OPENSSL
#ifdef TORRENT_MACOS_DEPRECATED_LIBCRYPTO
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#endif

	bool torrent::verify_peer_cert(bool const preverified, boost::asio::ssl::verify_context&amp; ctx)
	{
		// if the cert wasn't signed by the correct CA, fail the verification
		if (!preverified) return false;

		// we're only interested in checking the certificate at the end of the chain.
<div style="background: #ffff00" width="100%">		int depth = X509_STORE_CTX_get_error_depth(ctx.native_handle());
</div>		if (depth &gt; 0) return true;

		X509* cert = X509_STORE_CTX_get_current_cert(ctx.native_handle());

		// Go through the alternate names in the certificate looking for matching DNS entries
		auto* gens = static_cast&lt;GENERAL_NAMES*&gt;(
			X509_get_ext_d2i(cert, NID_subject_alt_name, nullptr, nullptr));

#ifndef TORRENT_DISABLE_LOGGING
		std::string names;
		bool match = false;
#endif
		for (int i = 0; i &lt; aux::openssl_num_general_names(gens); ++i)
		{
			GENERAL_NAME* gen = aux::openssl_general_name_value(gens, i);
			if (gen-&gt;type != GEN_DNS) continue;
			ASN1_IA5STRING* domain = gen-&gt;d.dNSName;
			if (domain-&gt;type != V_ASN1_IA5STRING || !domain-&gt;data || !domain-&gt;length) continue;
			auto const* torrent_name = reinterpret_cast&lt;char const*&gt;(domain-&gt;data);
			std::size_t const name_length = aux::numeric_cast&lt;std::size_t&gt;(domain-&gt;length);

#ifndef TORRENT_DISABLE_LOGGING
			if (i &gt; 1) names += " | n: ";
			names.append(torrent_name, name_length);
#endif
			if (std::strncmp(torrent_name, "*", name_length) == 0
				|| std::strncmp(torrent_name, m_torrent_file-&gt;name().c_str(), name_length) == 0)
			{
#ifndef TORRENT_DISABLE_LOGGING
				match = true;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(204)">../src/torrent.cpp:1887</a></td><td>this could be optimized by looking up which files are complete and just look at those</td></tr><tr id="204" style="display: none;" colspan="3"><td colspan="3"><h2>this could be optimized by looking up which files are
complete and just look at those</h2><h4>../src/torrent.cpp:1887</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">					we_have(i);
				}
			}
		}

		set_state(torrent_status::checking_resume_data);

		aux::vector&lt;std::string, file_index_t&gt; links;
#ifndef TORRENT_DISABLE_MUTABLE_TORRENTS
		if (!m_torrent_file-&gt;similar_torrents().empty()
			|| !m_torrent_file-&gt;collections().empty())
		{
			resolve_links res(m_torrent_file);

			for (auto const&amp; ih : m_torrent_file-&gt;similar_torrents())
			{
				std::shared_ptr&lt;torrent&gt; t = m_ses.find_torrent(ih).lock();
				if (!t) continue;

				// Only attempt to reuse files from torrents that are seeding.
<div style="background: #ffff00" width="100%">				if (!t-&gt;is_seed()) continue;
</div>
				res.match(t-&gt;get_torrent_copy(), t-&gt;save_path());
			}
			for (auto const&amp; c : m_torrent_file-&gt;collections())
			{
				std::vector&lt;std::shared_ptr&lt;torrent&gt;&gt; ts = m_ses.find_collection(c);

				for (auto const&amp; t : ts)
				{
					// Only attempt to reuse files from torrents that are seeding.
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(205)">../src/torrent.cpp:1900</a></td><td>this could be optimized by looking up which files are complete and just look at those</td></tr><tr id="205" style="display: none;" colspan="3"><td colspan="3"><h2>this could be optimized by looking up which files are
complete and just look at those</h2><h4>../src/torrent.cpp:1900</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		{
			resolve_links res(m_torrent_file);

			for (auto const&amp; ih : m_torrent_file-&gt;similar_torrents())
			{
				std::shared_ptr&lt;torrent&gt; t = m_ses.find_torrent(ih).lock();
				if (!t) continue;

				// Only attempt to reuse files from torrents that are seeding.
				if (!t-&gt;is_seed()) continue;

				res.match(t-&gt;get_torrent_copy(), t-&gt;save_path());
			}
			for (auto const&amp; c : m_torrent_file-&gt;collections())
			{
				std::vector&lt;std::shared_ptr&lt;torrent&gt;&gt; ts = m_ses.find_collection(c);

				for (auto const&amp; t : ts)
				{
					// Only attempt to reuse files from torrents that are seeding.
<div style="background: #ffff00" width="100%">					if (!t-&gt;is_seed()) continue;
</div>
					res.match(t-&gt;get_torrent_copy(), t-&gt;save_path());
				}
			}

			std::vector&lt;resolve_links::link_t&gt; const&amp; l = res.get_links();
			if (!l.empty())
			{
				for (auto const&amp; i : l)
				{
					if (!i.ti) continue;
					links.push_back(combine_path(i.save_path
						, i.ti-&gt;files().file_path(i.file_idx)));
				}
			}
		}
#endif // TORRENT_DISABLE_MUTABLE_TORRENTS

#if TORRENT_USE_ASSERTS
		TORRENT_ASSERT(m_outstanding_check_files == false);
		m_outstanding_check_files = true;
#endif
		m_ses.disk_thread().async_check_files(
			m_storage, m_add_torrent_params ? m_add_torrent_params.get() : nullptr
			, links, std::bind(&amp;torrent::on_resume_data_checked
			, shared_from_this(), _1, _2));
		// async_check_files will gut links
#ifndef TORRENT_DISABLE_LOGGING
		debug_log("init, async_check_files");
#endif
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(206)">../src/torrent.cpp:2543</a></td><td>this pattern is repeated in a few places. Factor this into a function and generalize the concept of a torrent having a dedicated listen port</td></tr><tr id="206" style="display: none;" colspan="3"><td colspan="3"><h2>this pattern is repeated in a few places. Factor this into
a function and generalize the concept of a torrent having a
dedicated listen port</h2><h4>../src/torrent.cpp:2543</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// if the files haven't been checked yet, we're
		// not ready for peers. Except, if we don't have metadata,
		// we need peers to download from
		if (!m_files_checked &amp;&amp; valid_metadata()) return;

		if (!m_announce_to_lsd) return;

		// private torrents are never announced on LSD
		if (m_torrent_file-&gt;is_valid() &amp;&amp; m_torrent_file-&gt;priv()) return;

		// i2p torrents are also never announced on LSD
		// unless we allow mixed swarms
		if (m_torrent_file-&gt;is_valid()
			&amp;&amp; (torrent_file().is_i2p() &amp;&amp; !settings().get_bool(settings_pack::allow_i2p_mixed)))
			return;

		if (is_paused()) return;

		if (!m_ses.has_lsd()) return;

<div style="background: #ffff00" width="100%">#ifdef TORRENT_USE_OPENSSL
</div>		int port = is_ssl_torrent() ? m_ses.ssl_listen_port() : m_ses.listen_port();
#else
		int port = m_ses.listen_port();
#endif

		// announce with the local discovery service
		m_ses.announce_lsd(m_torrent_file-&gt;info_hash(), port
			, settings().get_bool(settings_pack::broadcast_lsd) &amp;&amp; m_lsd_seq == 0);
		++m_lsd_seq;
	}

#ifndef TORRENT_DISABLE_DHT

	void torrent::dht_announce()
	{
		TORRENT_ASSERT(is_single_thread());
		if (!m_ses.dht())
		{
#ifndef TORRENT_DISABLE_LOGGING
			debug_log("DHT: no dht initialized");
#endif
			return;
		}
		if (!should_announce_dht())
		{
#ifndef TORRENT_DISABLE_LOGGING
			if (should_log())
			{
				if (!m_ses.announce_dht())
					debug_log("DHT: no listen sockets");
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(207)">../src/torrent.cpp:3498</a></td><td>add one peer per IP the hostname resolves to</td></tr><tr id="207" style="display: none;" colspan="3"><td colspan="3"><h2>add one peer per IP the hostname resolves to</h2><h4>../src/torrent.cpp:3498</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	}
	catch (...) { handle_exception(); }
#endif

	void torrent::on_peer_name_lookup(error_code const&amp; e
		, std::vector&lt;address&gt; const&amp; host_list, int const port) try
	{
		TORRENT_ASSERT(is_single_thread());

		INVARIANT_CHECK;

		COMPLETE_ASYNC("torrent::on_peer_name_lookup");

#ifndef TORRENT_DISABLE_LOGGING
		if (e &amp;&amp; should_log())
			debug_log("peer name lookup error: %s", e.message().c_str());
#endif

		if (e || m_abort || host_list.empty() || m_ses.is_aborted()) return;

<div style="background: #ffff00" width="100%">		tcp::endpoint host(host_list.front(), std::uint16_t(port));
</div>
		if (m_ip_filter &amp;&amp; m_ip_filter-&gt;access(host.address()) &amp; ip_filter::blocked)
		{
#ifndef TORRENT_DISABLE_LOGGING
			if (should_log())
			{
				error_code ec;
				debug_log("blocked ip from tracker: %s", host.address().to_string(ec).c_str());
			}
#endif
			if (m_ses.alerts().should_post&lt;peer_blocked_alert&gt;())
				m_ses.alerts().emplace_alert&lt;peer_blocked_alert&gt;(get_handle()
					, host, peer_blocked_alert::ip_filter);
			return;
		}

		if (add_peer(host, peer_info::tracker))
			state_updated();

#ifndef TORRENT_DISABLE_LOGGING
		if (should_log())
		{
			error_code ec;
			debug_log("name-lookup add_peer() [ %s ] connect-candidates: %d"
				, host.address().to_string(ec).c_str()
				, m_peer_list ? m_peer_list-&gt;num_connect_candidates() : -1);
		}
#endif
		update_want_peers();
	}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(208)">../src/torrent.cpp:8313</a></td><td>add a flag to ignore stats, and only care about resume data for content. For unchanged files, don't trigger a load of the metadata just to save an empty resume data file</td></tr><tr id="208" style="display: none;" colspan="3"><td colspan="3"><h2>add a flag to ignore stats, and only care about resume data for
content. For unchanged files, don't trigger a load of the metadata
just to save an empty resume data file</h2><h4>../src/torrent.cpp:8313</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		if (m_complete != 0xffffff) seeds = m_complete;
		else seeds = m_peer_list ? m_peer_list-&gt;num_seeds() : 0;

		if (m_incomplete != 0xffffff) downloaders = m_incomplete;
		else downloaders = m_peer_list ? m_peer_list-&gt;num_peers() - m_peer_list-&gt;num_seeds() : 0;

		if (seeds == 0)
		{
			ret |= no_seeds;
			ret |= downloaders &amp; prio_mask;
		}
		else
		{
			ret |= ((1 + downloaders) * scale / seeds) &amp; prio_mask;
		}

		return ret;
	}

	// this is an async operation triggered by the client
<div style="background: #ffff00" width="100%">	void torrent::save_resume_data(resume_data_flags_t const flags)
</div>	{
		TORRENT_ASSERT(is_single_thread());
		INVARIANT_CHECK;

		if (!valid_metadata())
		{
			alerts().emplace_alert&lt;save_resume_data_failed_alert&gt;(get_handle()
				, errors::no_metadata);
			return;
		}

		if ((flags &amp; torrent_handle::only_if_modified) &amp;&amp; !m_need_save_resume_data)
		{
			alerts().emplace_alert&lt;save_resume_data_failed_alert&gt;(get_handle()
				, errors::resume_data_not_modified);
			return;
		}

		m_need_save_resume_data = false;
		m_save_resume_flags = flags;
		state_updated();

		if ((flags &amp; torrent_handle::flush_disk_cache) &amp;&amp; m_storage)
			m_ses.disk_thread().async_release_files(m_storage);

		state_updated();

		add_torrent_params atp;
		write_resume_data(atp);
		alerts().emplace_alert&lt;save_resume_data_alert&gt;(std::move(atp), get_handle());
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(209)">../src/torrent.cpp:9832</a></td><td>instead of resorting the whole list, insert the peers directly into the right place</td></tr><tr id="209" style="display: none;" colspan="3"><td colspan="3"><h2>instead of resorting the whole list, insert the peers
directly into the right place</h2><h4>../src/torrent.cpp:9832</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				std::printf("timed out [average-piece-time: %d ms ]\n"
					, m_average_piece_time);
#endif
			}

			// pick all blocks for this piece. the peers list is kept up to date
			// and sorted. when we issue a request to a peer, its download queue
			// time will increase and it may need to be bumped in the peers list,
			// since it's ordered by download queue time
			pick_time_critical_block(peers, ignore_peers
				, peers_with_requests
				, pi, &amp;i, m_picker.get()
				, blocks_in_piece, timed_out);

			// put back the peers we ignored into the peer list for the next piece
			if (!ignore_peers.empty())
			{
				peers.insert(peers.begin(), ignore_peers.begin(), ignore_peers.end());
				ignore_peers.clear();

<div style="background: #ffff00" width="100%">				std::sort(peers.begin(), peers.end()
</div>					, [] (peer_connection const* lhs, peer_connection const* rhs)
					{ return lhs-&gt;download_queue_time(16*1024) &lt; rhs-&gt;download_queue_time(16*1024); });
			}

			// if this peer's download time exceeds 2 seconds, we're done.
			// We don't want to build unreasonably long request queues
			if (!peers.empty() &amp;&amp; peers[0]-&gt;download_queue_time() &gt; milliseconds(2000))
				break;
		}

		// commit all the time critical requests
		for (auto p : peers_with_requests)
		{
			p-&gt;send_block_requests();
		}
	}

	std::set&lt;std::string&gt; torrent::web_seeds(web_seed_entry::type_t const type) const
	{
		TORRENT_ASSERT(is_single_thread());
		std::set&lt;std::string&gt; ret;
		for (auto const&amp; s : m_web_seeds)
		{
			if (s.peer_info.banned) continue;
			if (s.removed) continue;
			if (s.type != type) continue;
			ret.insert(s.url);
		}
		return ret;
	}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(210)">../src/choker.cpp:311</a></td><td>optimize this using partial_sort or something. We don't need to sort the entire list</td></tr><tr id="210" style="display: none;" colspan="3"><td colspan="3"><h2>optimize this using partial_sort or something. We don't need
to sort the entire list</h2><h4>../src/choker.cpp:311</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			return upload_slots;
		}

		// ==== rate-based ====
		//
		// The rate based unchoker looks at our upload rate to peers, and find
		// a balance between number of upload slots and the rate we achieve. The
		// intention is to not spread upload bandwidth too thin, but also to not
		// unchoke few enough peers to not be able to saturate the up-link.
		// this is done by traversing the peers sorted by our upload rate to
		// them in decreasing rates. For each peer we increase our threshold
		// by 1 kB/s. The first peer we get to to whom we upload slower than
		// the threshold, we stop and that's the number of unchoke slots we have.
		if (sett.get_int(settings_pack::choking_algorithm)
			== settings_pack::rate_based_choker)
		{
			// first reset the number of unchoke slots, because we'll calculate
			// it purely based on the current state of our peers.
			upload_slots = 0;

<div style="background: #ffff00" width="100%">
</div></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(211)">../src/choker.cpp:314</a></td><td>make the comparison function a free function and move it into this cpp file</td></tr><tr id="211" style="display: none;" colspan="3"><td colspan="3"><h2>make the comparison function a free function and move it
into this cpp file</h2><h4>../src/choker.cpp:314</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		}

		// ==== rate-based ====
		//
		// The rate based unchoker looks at our upload rate to peers, and find
		// a balance between number of upload slots and the rate we achieve. The
		// intention is to not spread upload bandwidth too thin, but also to not
		// unchoke few enough peers to not be able to saturate the up-link.
		// this is done by traversing the peers sorted by our upload rate to
		// them in decreasing rates. For each peer we increase our threshold
		// by 1 kB/s. The first peer we get to to whom we upload slower than
		// the threshold, we stop and that's the number of unchoke slots we have.
		if (sett.get_int(settings_pack::choking_algorithm)
			== settings_pack::rate_based_choker)
		{
			// first reset the number of unchoke slots, because we'll calculate
			// it purely based on the current state of our peers.
			upload_slots = 0;


<div style="background: #ffff00" width="100%">			std::sort(peers.begin(), peers.end()
</div>				, std::bind(&amp;upload_rate_compare, _1, _2));

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(212)">../src/choker.cpp:319</a></td><td>make configurable</td></tr><tr id="212" style="display: none;" colspan="3"><td colspan="3"><h2>make configurable</h2><h4>../src/choker.cpp:319</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		//
		// The rate based unchoker looks at our upload rate to peers, and find
		// a balance between number of upload slots and the rate we achieve. The
		// intention is to not spread upload bandwidth too thin, but also to not
		// unchoke few enough peers to not be able to saturate the up-link.
		// this is done by traversing the peers sorted by our upload rate to
		// them in decreasing rates. For each peer we increase our threshold
		// by 1 kB/s. The first peer we get to to whom we upload slower than
		// the threshold, we stop and that's the number of unchoke slots we have.
		if (sett.get_int(settings_pack::choking_algorithm)
			== settings_pack::rate_based_choker)
		{
			// first reset the number of unchoke slots, because we'll calculate
			// it purely based on the current state of our peers.
			upload_slots = 0;


			std::sort(peers.begin(), peers.end()
				, std::bind(&amp;upload_rate_compare, _1, _2));

<div style="background: #ffff00" width="100%">			int rate_threshold = 1024;
</div>
			for (auto const p : peers)
			{
				int const rate = int(p-&gt;uploaded_in_last_round()
					* 1000 / total_milliseconds(unchoke_interval));

				if (rate &lt; rate_threshold) break;

				++upload_slots;

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(213)">../src/choker.cpp:331</a></td><td>make configurable</td></tr><tr id="213" style="display: none;" colspan="3"><td colspan="3"><h2>make configurable</h2><h4>../src/choker.cpp:331</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		{
			// first reset the number of unchoke slots, because we'll calculate
			// it purely based on the current state of our peers.
			upload_slots = 0;


			std::sort(peers.begin(), peers.end()
				, std::bind(&amp;upload_rate_compare, _1, _2));

			int rate_threshold = 1024;

			for (auto const p : peers)
			{
				int const rate = int(p-&gt;uploaded_in_last_round()
					* 1000 / total_milliseconds(unchoke_interval));

				if (rate &lt; rate_threshold) break;

				++upload_slots;

<div style="background: #ffff00" width="100%">				rate_threshold += 1024;
</div>			}
			++upload_slots;
		}

		// sorts the peers that are eligible for unchoke by download rate and
		// secondary by total upload. The reason for this is, if all torrents are
		// being seeded, the download rate will be 0, and the peers we have sent
		// the least to should be unchoked

		// we use partial sort here, because we only care about the top
		// upload_slots peers.

		if (sett.get_int(settings_pack::seed_choking_algorithm)
			== settings_pack::round_robin)
		{
			int const pieces = sett.get_int(settings_pack::seeding_piece_quota);

			std::partial_sort(peers.begin(), peers.begin()
				+ std::min(upload_slots, int(peers.size())), peers.end()
				, std::bind(&amp;unchoke_compare_rr, _1, _2, pieces));
		}
		else if (sett.get_int(settings_pack::seed_choking_algorithm)
			== settings_pack::fastest_upload)
		{
			std::partial_sort(peers.begin(), peers.begin()
				+ std::min(upload_slots, int(peers.size())), peers.end()
				, std::bind(&amp;unchoke_compare_fastest_upload, _1, _2));
		}
		else if (sett.get_int(settings_pack::seed_choking_algorithm)
			== settings_pack::anti_leech)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(214)">../src/web_connection_base.cpp:68</a></td><td>introduce a web-seed default class which has a low download priority</td></tr><tr id="214" style="display: none;" colspan="3"><td colspan="3"><h2>introduce a web-seed default class which has a low download priority</h2><h4>../src/web_connection_base.cpp:68</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		: peer_connection(pack)
		, m_first_request(true)
		, m_ssl(false)
		, m_external_auth(web.auth)
		, m_extra_headers(web.extra_headers)
		, m_parser(http_parser::dont_parse_chunks)
		, m_body_start(0)
	{
		TORRENT_ASSERT(&amp;web.peer_info == pack.peerinfo);
		// when going through a proxy, we don't necessarily have an endpoint here,
		// since the proxy might be resolving the hostname, not us
		TORRENT_ASSERT(web.endpoints.empty() || web.endpoints.front() == pack.endp);

		INVARIANT_CHECK;

		TORRENT_ASSERT(is_outgoing());

		TORRENT_ASSERT(!m_torrent.lock()-&gt;is_upload_only());

		// we only want left-over bandwidth
<div style="background: #ffff00" width="100%">
</div>		std::string protocol;
		error_code ec;
		std::tie(protocol, m_basic_auth, m_host, m_port, m_path)
			= parse_url_components(web.url, ec);
		TORRENT_ASSERT(!ec);

		if (m_port == -1 &amp;&amp; protocol == "http")
			m_port = 80;

#ifdef TORRENT_USE_OPENSSL
		if (protocol == "https")
		{
			m_ssl = true;
			if (m_port == -1) m_port = 443;
		}
#endif

		if (!m_basic_auth.empty())
			m_basic_auth = base64encode(m_basic_auth);

		m_server_string = "URL seed @ ";
		m_server_string += m_host;
	}

	int web_connection_base::timeout() const
	{
		// since this is a web seed, change the timeout
		// according to the settings.
		return m_settings.get_int(settings_pack::urlseed_timeout);
	}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(215)">../src/utp_stream.cpp:1736</a></td><td>this loop is not very efficient. It could be fixed by having a separate list of sequence numbers that need resending</td></tr><tr id="215" style="display: none;" colspan="3"><td colspan="3"><h2>this loop is not very efficient. It could be fixed by having
a separate list of sequence numbers that need resending</h2><h4>../src/utp_stream.cpp:1736</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">}

// sends a packet, pulls data from the write buffer (if there's any)
// if ack is true, we need to send a packet regardless of if there's
// any data. Returns true if we could send more data (i.e. call
// send_pkt() again)
// returns true if there is more space for payload in our
// congestion window, false if there is no more space.
bool utp_socket_impl::send_pkt(int const flags)
{
#ifdef TORRENT_EXPENSIVE_INVARIANT_CHECKS
	INVARIANT_CHECK;
#endif

	bool const force = (flags &amp; pkt_ack) || (flags &amp; pkt_fin);

//	TORRENT_ASSERT(m_state != UTP_STATE_FIN_SENT || (flags &amp; pkt_ack));

	// first see if we need to resend any packets

<div style="background: #ffff00" width="100%">	for (int i = (m_acked_seq_nr + 1) &amp; ACK_MASK; i != m_seq_nr; i = (i + 1) &amp; ACK_MASK)
</div>	{
		packet* p = m_outbuf.at(aux::numeric_cast&lt;packet_buffer::index_type&gt;(i));
		if (!p) continue;
		if (!p-&gt;need_resend) continue;
		if (!resend_packet(p))
		{
			// we couldn't resend the packet. It probably doesn't
			// fit in our cwnd. If force is set, we need to continue
			// to send our packet anyway, if we don't have force set,
			// we might as well return
			if (!force) return false;
			// resend_packet might have failed
			if (m_state == UTP_STATE_ERROR_WAIT || m_state == UTP_STATE_DELETE) return false;
			break;
		}

		// don't fast-resend this packet
		if (m_fast_resend_seq_nr == i)
			m_fast_resend_seq_nr = (m_fast_resend_seq_nr + 1) &amp; ACK_MASK;
	}

	// MTU DISCOVERY

	// under these conditions, the next packet we send should be an MTU probe.
	// MTU probes get to use the mid-point packet size, whereas other packets
	// use a conservative packet size of the largest known to work. The reason
	// for the cwnd condition is to make sure the probe is surrounded by non-
	// probes, to be able to distinguish a loss of the probe vs. just loss in
	// general.
	bool const mtu_probe = (m_mtu_seq == 0
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(216)">../src/udp_tracker_connection.cpp:632</a></td><td>why is this a linked list?</td></tr><tr id="216" style="display: none;" colspan="3"><td colspan="3"><h2>why is this a linked list?</h2><h4>../src/udp_tracker_connection.cpp:632</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				ipv6_peer_entry e{};
				std::memcpy(e.ip.data(), buf.data(), 16);
				buf = buf.subspan(16);
				e.port = aux::read_uint16(buf);
				resp.peers6.push_back(e);
			}
		}
		else
		{
			resp.peers4.reserve(static_cast&lt;std::size_t&gt;(num_peers));
			for (int i = 0; i &lt; num_peers; ++i)
			{
				ipv4_peer_entry e{};
				std::memcpy(e.ip.data(), buf.data(), 4);
				buf = buf.subspan(4);
				e.port = aux::read_uint16(buf);
				resp.peers4.push_back(e);
			}
		}

<div style="background: #ffff00" width="100%">		std::list&lt;address&gt; ip_list;
</div>		std::transform(m_endpoints.begin(), m_endpoints.end(), std::back_inserter(ip_list)
			, [](tcp::endpoint const&amp; ep) { return ep.address(); } );

		cb-&gt;tracker_response(tracker_req(), m_target.address(), ip_list, resp);

		close();
		return true;
	}

	bool udp_tracker_connection::on_scrape_response(span&lt;char const&gt; buf)
	{
		restart_read_timeout();
		auto const action = static_cast&lt;action_t&gt;(aux::read_int32(buf));
		std::uint32_t const transaction = aux::read_uint32(buf);

		if (transaction != m_transaction_id)
		{
			fail(error_code(errors::invalid_tracker_transaction_id));
			return false;
		}

		if (action == action_t::error)
		{
			fail(error_code(errors::tracker_failure)
				, std::string(buf.data(), static_cast&lt;std::size_t&gt;(buf.size())).c_str());
			return true;
		}

		if (action != action_t::scrape)
		{
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(217)">../src/torrent_peer.cpp:174</a></td><td>how do we deal with our external address changing?</td></tr><tr id="217" style="display: none;" colspan="3"><td colspan="3"><h2>how do we deal with our external address changing?</h2><h4>../src/torrent_peer.cpp:174</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// prefer opening non-encrypted
		// connections. If it fails, we'll
		// retry with encryption
		, pe_support(false)
#endif
		, is_v6_addr(false)
#if TORRENT_USE_I2P
		, is_i2p_addr(false)
#endif
		, on_parole(false)
		, banned(false)
		, supports_utp(true) // assume peers support utp
		, confirmed_supports_utp(false)
		, supports_holepunch(false)
		, web_seed(false)
	{}

	std::uint32_t torrent_peer::rank(external_ip const&amp; external, int external_port) const
	{
		TORRENT_ASSERT(in_use);
<div style="background: #ffff00" width="100%">		if (peer_rank == 0)
</div>			peer_rank = peer_priority(
				tcp::endpoint(external.external_address(this-&gt;address()), std::uint16_t(external_port))
				, tcp::endpoint(this-&gt;address(), this-&gt;port));
		return peer_rank;
	}

#ifndef TORRENT_DISABLE_LOGGING
	std::string torrent_peer::to_string() const
	{
		TORRENT_ASSERT(in_use);
#if TORRENT_USE_I2P
		if (is_i2p_addr) return dest().to_string();
#endif // TORRENT_USE_I2P
		error_code ec;
		return address().to_string(ec);
	}
#endif

	std::int64_t torrent_peer::total_download() const
	{
		TORRENT_ASSERT(in_use);
		if (connection != nullptr)
		{
			TORRENT_ASSERT(prev_amount_download == 0);
			return connection-&gt;statistics().total_payload_download();
		}
		else
		{
			return std::int64_t(prev_amount_download) &lt;&lt; 10;
		}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(218)">../src/piece_picker.cpp:106</a></td><td>find a better place for this</td></tr><tr id="218" style="display: none;" colspan="3"><td colspan="3"><h2>find a better place for this</h2><h4>../src/piece_picker.cpp:106</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			if (limit == 0)
			{
				std::cerr &lt;&lt; " ...";
				break;
			}
			if (*i == -1) break;
			while (j != p.m_priority_boundaries.end() &amp;&amp; *j &lt;= index)
			{
				std::cerr &lt;&lt; "| ";
				++j;
			}
			std::cerr &lt;&lt; *i &lt;&lt; "(" &lt;&lt; p.m_piece_map[*i].index &lt;&lt; ") ";
			--limit;
		}
		std::cerr &lt;&lt; std::endl;
	}
}
#endif // TORRENT_PICKER_LOG
namespace libtorrent {

<div style="background: #ffff00" width="100%">	const piece_block piece_block::invalid(
</div>		std::numeric_limits&lt;piece_index_t&gt;::max()
		, std::numeric_limits&lt;int&gt;::max());

	constexpr prio_index_t piece_picker::piece_pos::we_have_index;

	constexpr picker_options_t piece_picker::rarest_first;
	constexpr picker_options_t piece_picker::reverse;
	constexpr picker_options_t piece_picker::on_parole;
	constexpr picker_options_t piece_picker::prioritize_partials;
	constexpr picker_options_t piece_picker::sequential;
	constexpr picker_options_t piece_picker::time_critical_mode;
	constexpr picker_options_t piece_picker::align_expanded_pieces;

	constexpr download_queue_t piece_picker::piece_pos::piece_downloading;
	constexpr download_queue_t piece_picker::piece_pos::piece_full;
	constexpr download_queue_t piece_picker::piece_pos::piece_finished;
	constexpr download_queue_t piece_picker::piece_pos::piece_zero_prio;
	constexpr download_queue_t piece_picker::piece_pos::num_download_categories;
	constexpr download_queue_t piece_picker::piece_pos::piece_open;
	constexpr download_queue_t piece_picker::piece_pos::piece_downloading_reverse;
	constexpr download_queue_t piece_picker::piece_pos::piece_full_reverse;

	piece_picker::piece_picker(int const blocks_per_piece
		, int const blocks_in_last_piece, int const total_num_pieces)
		: m_priority_boundaries(1, m_pieces.end_index())
	{
#ifdef TORRENT_PICKER_LOG
		std::cerr &lt;&lt; "[" &lt;&lt; this &lt;&lt; "] " &lt;&lt; "new piece_picker" &lt;&lt; std::endl;
#endif
#if TORRENT_USE_INVARIANT_CHECKS
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(219)">../src/piece_picker.cpp:1982</a></td><td>this could probably be optimized by incrementally calling partial_sort to sort one more element in the list. Because chances are that we'll just need a single piece, and once we've picked from it we're done. Sorting the rest of the list in that case is a waste of time.</td></tr><tr id="219" style="display: none;" colspan="3"><td colspan="3"><h2>this could probably be optimized by incrementally
calling partial_sort to sort one more element in the list. Because
chances are that we'll just need a single piece, and once we've
picked from it we're done. Sorting the rest of the list in that
case is a waste of time.</h2><h4>../src/piece_picker.cpp:1982</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				pc.inc_stats_counter(counters::piece_picker_partial_loops);

				// in time critical mode, only pick high priority pieces
				if ((options &amp; time_critical_mode)
					&amp;&amp; piece_priority(dp.index) != top_priority)
					continue;

				if (!is_piece_free(dp.index, pieces)) continue;

				TORRENT_ASSERT(m_piece_map[dp.index].download_queue()
					== piece_pos::piece_downloading);

				ordered_partials[num_ordered_partials++] = &amp;dp;
			}

			// now, sort the list.
			if (options &amp; rarest_first)
			{
				ret |= picker_log_alert::rarest_first_partials;

<div style="background: #ffff00" width="100%">				std::sort(ordered_partials.begin(), ordered_partials.begin() + num_ordered_partials
</div>					, std::bind(&amp;piece_picker::partial_compare_rarest_first, this
						, _1, _2));
			}

			for (int i = 0; i &lt; num_ordered_partials; ++i)
			{
				ret |= picker_log_alert::prioritize_partials;

				num_blocks = add_blocks_downloading(*ordered_partials[i], pieces
					, interesting_blocks, backup_blocks, backup_blocks2
					, num_blocks, prefer_contiguous_blocks, peer, options);
				if (num_blocks &lt;= 0) return ret;
				if (int(backup_blocks.size()) &gt;= num_blocks
					&amp;&amp; int(backup_blocks2.size()) &gt;= num_blocks)
					break;
			}

			num_blocks = append_blocks(interesting_blocks, backup_blocks
				, num_blocks);
			if (num_blocks &lt;= 0) return ret;

			num_blocks = append_blocks(interesting_blocks, backup_blocks2
				, num_blocks);
			if (num_blocks &lt;= 0) return ret;
		}

		if (!suggested_pieces.empty())
		{
			for (piece_index_t i : suggested_pieces)
			{
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(220)">../src/piece_picker.cpp:2486</a></td><td>when expanding pieces for cache stripe reasons, the !downloading condition doesn't make much sense</td></tr><tr id="220" style="display: none;" colspan="3"><td colspan="3"><h2>when expanding pieces for cache stripe reasons,
the !downloading condition doesn't make much sense</h2><h4>../src/piece_picker.cpp:2486</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		TORRENT_ASSERT(index &lt; m_piece_map.end_index());
		if (next(index) == m_piece_map.end_index())
			return m_blocks_in_last_piece;
		else
			return m_blocks_per_piece;
	}

	bool piece_picker::is_piece_free(piece_index_t const piece
		, typed_bitfield&lt;piece_index_t&gt; const&amp; bitmask) const
	{
		return bitmask[piece]
			&amp;&amp; !m_piece_map[piece].have()
			&amp;&amp; !m_piece_map[piece].filtered();
	}

	bool piece_picker::can_pick(piece_index_t const piece
		, typed_bitfield&lt;piece_index_t&gt; const&amp; bitmask) const
	{
		return bitmask[piece]
			&amp;&amp; !m_piece_map[piece].have()
<div style="background: #ffff00" width="100%">			&amp;&amp; !m_piece_map[piece].downloading()
</div>			&amp;&amp; !m_piece_map[piece].filtered();
	}

#if TORRENT_USE_INVARIANT_CHECKS
	void piece_picker::check_peers()
	{
		for (auto const&amp; b : m_block_info)
		{
			TORRENT_ASSERT(b.peer == nullptr || static_cast&lt;torrent_peer*&gt;(b.peer)-&gt;in_use);
		}
	}
#endif

	void piece_picker::clear_peer(torrent_peer* peer)
	{
		for (auto&amp; b : m_block_info)
		{
			if (b.peer == peer) b.peer = nullptr;
		}
	}

	// the first bool is true if this is the only peer that has requested and downloaded
	// blocks from this piece.
	// the second bool is true if this is the only active peer that is requesting
	// and downloading blocks from this piece. Active means having a connection.
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(221)">../src/storage_utils.cpp:285</a></td><td>ideally, if we end up copying files because of a move across volumes, the source should not be deleted until they've all been copied. That would let us rollback with higher confidence.</td></tr><tr id="221" style="display: none;" colspan="3"><td colspan="3"><h2>ideally, if we end up copying files because of a move across
volumes, the source should not be deleted until they've all been
copied. That would let us rollback with higher confidence.</h2><h4>../src/storage_utils.cpp:285</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// later
		aux::vector&lt;bool, file_index_t&gt; copied_files(std::size_t(f.num_files()), false);

		// track how far we got in case of an error
		file_index_t file_index{};
		error_code e;
		for (auto const i : f.file_range())
		{
			// files moved out to absolute paths are not moved
			if (f.file_absolute_path(i)) continue;

			std::string const old_path = combine_path(save_path, f.file_path(i));
			std::string const new_path = combine_path(new_save_path, f.file_path(i));

			if (flags == move_flags_t::dont_replace &amp;&amp; exists(new_path))
			{
				if (ret == status_t::no_error) ret = status_t::need_full_check;
				continue;
			}

<div style="background: #ffff00" width="100%">			move_file(old_path, new_path, e);
</div>
			// if the source file doesn't exist. That's not a problem
			// we just ignore that file
			if (e == boost::system::errc::no_such_file_or_directory)
				e.clear();
			else if (e
				&amp;&amp; e != boost::system::errc::invalid_argument
				&amp;&amp; e != boost::system::errc::permission_denied)
			{
				// moving the file failed
				// on OSX, the error when trying to rename a file across different
				// volumes is EXDEV, which will make it fall back to copying.
				e.clear();
				copy_file(old_path, new_path, e);
				if (!e) copied_files[i] = true;
			}

			if (e)
			{
				ec.ec = e;
				ec.file(i);
				ec.operation = operation_t::file_rename;
				file_index = i;
				break;
			}
		}

		if (!e &amp;&amp; pf)
		{
			pf-&gt;move_partfile(new_save_path, e);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(222)">../src/file_progress.cpp:163</a></td><td>it would be nice to not depend on alert_manager here</td></tr><tr id="222" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to not depend on alert_manager here</h2><h4>../src/file_progress.cpp:163</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		TORRENT_ASSERT(m_have_pieces.get_bit(index) == false);
		m_have_pieces.set_bit(index);
#endif

		int const piece_size = fs.piece_length();
		std::int64_t off = std::int64_t(static_cast&lt;int&gt;(index)) * piece_size;
		file_index_t file_index = fs.file_index_at_offset(off);
		std::int64_t size = fs.piece_size(index);
		for (; size &gt; 0; ++file_index)
		{
			std::int64_t const file_offset = off - fs.file_offset(file_index);
			TORRENT_ASSERT(file_index != fs.end_file());
			TORRENT_ASSERT(file_offset &lt;= fs.file_size(file_index));
			std::int64_t const add = std::min(fs.file_size(file_index)
				- file_offset, size);
			m_file_progress[file_index] += add;

			TORRENT_ASSERT(m_file_progress[file_index]
					&lt;= fs.file_size(file_index));

<div style="background: #ffff00" width="100%">			if (m_file_progress[file_index] &gt;= fs.file_size(file_index) &amp;&amp; alerts)
</div>			{
				if (!fs.pad_file_at(file_index))
				{
					if (alerts-&gt;should_post&lt;file_completed_alert&gt;())
					{
						// this file just completed, post alert
						alerts-&gt;emplace_alert&lt;file_completed_alert&gt;(h, file_index);
					}
				}
			}
			size -= add;
			off += add;
			TORRENT_ASSERT(size &gt;= 0);
		}
	}

#if TORRENT_USE_INVARIANT_CHECKS
	void file_progress::check_invariant() const
	{
		if (m_file_progress.empty()) return;

		file_index_t index(0);
		for (std::int64_t progress : m_file_progress)
		{
			TORRENT_ASSERT(progress &lt;= m_file_sizes[index++]);
		}
	}
#endif
} }
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(223)">../src/disk_io_thread.cpp:467</a></td><td>in this case, the piece should probably not be flushed yet. are there any more cases where it should?</td></tr><tr id="223" style="display: none;" colspan="3"><td colspan="3"><h2>in this case, the piece should probably not be flushed yet. are there
any more cases where it should?</h2><h4>../src/disk_io_thread.cpp:467</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			{
				DLOG("[%d hash-done] ", static_cast&lt;int&gt;(i));
				continue;
			}

#if DEBUG_DISK_THREAD
			if (pe-&gt;num_dirty &lt; pe-&gt;blocks_in_piece)
			{
				DLOG("[%d dirty:%d] ", static_cast&lt;int&gt;(i), int(pe-&gt;num_dirty));
			}
			else if (pe-&gt;hashing_done == 0 &amp;&amp; hash_cursor &lt; pe-&gt;blocks_in_piece)
			{
				DLOG("[%d cursor:%d] ", static_cast&lt;int&gt;(i), hash_cursor);
			}
			else
			{
				DLOG("[%d xx] ", static_cast&lt;int&gt;(i));
			}
#endif

<div style="background: #ffff00" width="100%">
</div>			range_full = false;
			break;
		}

		if (!range_full)
		{
			DLOG("not flushing\n");
			return 0;
		}
		DLOG("\n");

		// now, build a iovec for all pieces that we want to flush, so that they
		// can be flushed in a single atomic operation. This is especially important
		// when there are more than 1 disk thread, to make sure they don't
		// interleave in undesired places.
		// in order to remember where each piece boundary ended up in the iovec,
		// we keep the indices in the iovec_offset array

		cont_pieces = static_cast&lt;int&gt;(range_end) - static_cast&lt;int&gt;(range_start);
		int const blocks_to_flush = int(p-&gt;blocks_in_piece * cont_pieces);
		TORRENT_ALLOCA(iov, iovec_t, blocks_to_flush);
		TORRENT_ALLOCA(flushing, int, blocks_to_flush);
		// this is the offset into iov and flushing for each piece
		TORRENT_ALLOCA(iovec_offset, int, cont_pieces + 1);
		int iov_len = 0;
		// this is the block index each piece starts at
		int block_start = 0;
		// keep track of the pieces that have had their refcount incremented
		// so we know to decrement them later
		TORRENT_ALLOCA(refcount_pieces, int, cont_pieces);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(224)">../src/disk_io_thread.cpp:918</a></td><td>it would be nice to optimize this by having the cache pieces also ordered by</td></tr><tr id="224" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to optimize this by having the cache
pieces also ordered by</h2><h4>../src/disk_io_thread.cpp:918</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			// we really should not have any pieces left. This is only called
			// from disk_io_thread::do_delete, which is a fence job and should
			// have any other jobs active, i.e. there should not be any references
			// keeping pieces or blocks alive
			if ((flags &amp; flush_delete_cache) &amp;&amp; (flags &amp; flush_expect_clear))
			{
				auto const&amp; storage_pieces = storage-&gt;cached_pieces();
				for (auto const&amp; p : storage_pieces)
				{
					cached_piece_entry* pe = m_disk_cache.find_piece(storage, p.piece);
					TORRENT_PIECE_ASSERT(pe-&gt;num_dirty == 0, pe);
				}
			}
#endif
		}
		else
		{
			auto range = m_disk_cache.all_pieces();
			while (range.first != range.second)
			{
<div style="background: #ffff00" width="100%">				if ((flags &amp; (flush_read_cache | flush_delete_cache)) == 0)
</div>				{
					// if we're not flushing the read cache, and not deleting the
					// cache, skip pieces with no dirty blocks, i.e. read cache
					// pieces
					while (range.first-&gt;num_dirty == 0)
					{
						++range.first;
						if (range.first == range.second) return;
					}
				}
				cached_piece_entry* pe = const_cast&lt;cached_piece_entry*&gt;(&amp;*range.first);
				flush_piece(pe, flags, completed_jobs, l);
				range = m_disk_cache.all_pieces();
			}
		}
	}

	// this is called if we're exceeding (or about to exceed) the cache
	// size limit. This means we should not restrict ourselves to contiguous
	// blocks of write cache line size, but try to flush all old blocks
	// this is why we pass in 1 as cont_block to the flushing functions
	void disk_io_thread::try_flush_write_blocks(int num, jobqueue_t&amp; completed_jobs
		, std::unique_lock&lt;std::mutex&gt;&amp; l)
	{
		DLOG("try_flush_write_blocks: %d\n", num);

		auto const range = m_disk_cache.write_lru_pieces();
		aux::vector&lt;std::pair&lt;std::shared_ptr&lt;storage_interface&gt;, piece_index_t&gt;&gt; pieces;
		pieces.reserve(m_disk_cache.num_write_lru_pieces());

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(225)">../src/disk_io_thread.cpp:960</a></td><td>instead of doing a lookup each time through the loop, save cached_piece_entry pointers with piece_refcount incremented to pin them</td></tr><tr id="225" style="display: none;" colspan="3"><td colspan="3"><h2>instead of doing a lookup each time through the loop, save
cached_piece_entry pointers with piece_refcount incremented to pin them</h2><h4>../src/disk_io_thread.cpp:960</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	// blocks of write cache line size, but try to flush all old blocks
	// this is why we pass in 1 as cont_block to the flushing functions
	void disk_io_thread::try_flush_write_blocks(int num, jobqueue_t&amp; completed_jobs
		, std::unique_lock&lt;std::mutex&gt;&amp; l)
	{
		DLOG("try_flush_write_blocks: %d\n", num);

		auto const range = m_disk_cache.write_lru_pieces();
		aux::vector&lt;std::pair&lt;std::shared_ptr&lt;storage_interface&gt;, piece_index_t&gt;&gt; pieces;
		pieces.reserve(m_disk_cache.num_write_lru_pieces());

		for (auto p = range; p.get() &amp;&amp; num &gt; 0; p.next())
		{
			cached_piece_entry* e = p.get();
			if (e-&gt;num_dirty == 0) continue;
			pieces.emplace_back(e-&gt;storage, e-&gt;piece);
		}

		for (auto const&amp; p : pieces)
		{
<div style="background: #ffff00" width="100%">			cached_piece_entry* pe = m_disk_cache.find_piece(p.first.get(), p.second);
</div>			if (pe == nullptr) continue;

			// another thread may flush this piece while we're looping and
			// evict it into a read piece and then also evict it to ghost
			if (pe-&gt;cache_state != cached_piece_entry::write_lru) continue;

#if TORRENT_USE_ASSERTS
			pe-&gt;piece_log.push_back(piece_log_t(piece_log_t::try_flush_write_blocks, -1));
#endif
			++pe-&gt;piece_refcount;
			kick_hasher(pe, l);
			num -= try_flush_hashed(pe, 1, completed_jobs, l);
			--pe-&gt;piece_refcount;

			m_disk_cache.maybe_free_piece(pe);
		}

		// when the write cache is under high pressure, it is likely
		// counter productive to actually do this, since a piece may
		// not have had its flush_hashed job run on it
		// so only do it if no other thread is currently flushing

		if (num == 0 || m_stats_counters[counters::num_writing_threads] &gt; 0) return;

		// if we still need to flush blocks, start over and flush
		// everything in LRU order (degrade to lru cache eviction)
		for (auto const&amp; p : pieces)
		{
			cached_piece_entry* pe = m_disk_cache.find_piece(p.first.get(), p.second);
			if (pe == nullptr) continue;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(226)">../src/disk_io_thread.cpp:1161</a></td><td>in the future, propagate exceptions back to the handlers</td></tr><tr id="226" style="display: none;" colspan="3"><td colspan="3"><h2>in the future, propagate exceptions back to the handlers</h2><h4>../src/disk_io_thread.cpp:1161</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		std::shared_ptr&lt;storage_interface&gt; storage = j-&gt;storage;

#ifdef TORRENT_EXPENSIVE_INVARIANT_CHECKS
		if (j-&gt;storage)
		{
			std::unique_lock&lt;std::mutex&gt; l(m_cache_mutex);
			auto const&amp; pieces = j-&gt;storage-&gt;cached_pieces();
			for (auto const&amp; p : pieces)
				TORRENT_ASSERT(p.storage == j-&gt;storage);
		}
#endif
		if (storage &amp;&amp; storage-&gt;m_settings == nullptr)
			storage-&gt;m_settings = &amp;m_settings;

		TORRENT_ASSERT(static_cast&lt;int&gt;(j-&gt;action) &lt; int(job_functions.size()));

		m_stats_counters.inc_stats_counter(counters::num_running_disk_jobs, 1);

		// call disk function
<div style="background: #ffff00" width="100%">		status_t ret = status_t::no_error;
</div>		try
		{
			int const idx = static_cast&lt;int&gt;(j-&gt;action);
			ret = (this-&gt;*(job_functions[static_cast&lt;std::size_t&gt;(idx)]))(j, completed_jobs);
		}
		catch (boost::system::system_error const&amp; err)
		{
			ret = status_t::fatal_disk_error;
			j-&gt;error.ec = err.code();
			j-&gt;error.operation = operation_t::exception;
		}
		catch (std::bad_alloc const&amp;)
		{
			ret = status_t::fatal_disk_error;
			j-&gt;error.ec = errors::no_memory;
			j-&gt;error.operation = operation_t::exception;
		}
		catch (std::exception const&amp;)
		{
			ret = status_t::fatal_disk_error;
			j-&gt;error.ec = boost::asio::error::fault;
			j-&gt;error.operation = operation_t::exception;
		}

		// note that -2 errors are OK
		TORRENT_ASSERT(ret != status_t::fatal_disk_error
			|| (j-&gt;error.ec &amp;&amp; j-&gt;error.operation != operation_t::unknown));

		m_stats_counters.inc_stats_counter(counters::num_running_disk_jobs, -1);

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(227)">../src/disk_io_thread.cpp:1219</a></td><td>a potentially more efficient solution would be to have a special queue for retry jobs, that's only ever run when a job completes, in any thread. It would only work if counters::num_running_disk_jobs > 0</td></tr><tr id="227" style="display: none;" colspan="3"><td colspan="3"><h2>a potentially more efficient solution would be to have a special
queue for retry jobs, that's only ever run when a job completes, in
any thread. It would only work if counters::num_running_disk_jobs > 0</h2><h4>../src/disk_io_thread.cpp:1219</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">				check_cache_level(l, completed_jobs);
				TORRENT_ASSERT(l.owns_lock());
				--m_cache_check_state;
			}
		}
		else
		{
			m_cache_check_state = cache_check_reinvoke;
		}
		l.unlock();

		if (ret == retry_job)
		{
			job_queue&amp; q = queue_for_job(j);

			std::unique_lock&lt;std::mutex&gt; l2(m_job_mutex);
			// to avoid busy looping here, give up
			// our quanta in case there aren't any other
			// jobs to run in between

<div style="background: #ffff00" width="100%">
</div>			TORRENT_ASSERT((j-&gt;flags &amp; disk_io_job::in_progress) || !j-&gt;storage);

			bool const need_sleep = q.m_queued_jobs.empty();
			q.m_queued_jobs.push_back(j);
			l2.unlock();
			if (need_sleep) std::this_thread::yield();
			return;
		}

		if (ret == defer_handler) return;

		j-&gt;ret = ret;

		completed_jobs.push_back(j);
	}

	status_t disk_io_thread::do_uncached_read(disk_io_job* j)
	{
		j-&gt;argument = disk_buffer_holder(*this, m_disk_cache.allocate_buffer("send buffer"), 0x4000);
		auto&amp; buffer = boost::get&lt;disk_buffer_holder&gt;(j-&gt;argument);
		if (buffer.get() == nullptr)
		{
			j-&gt;error.ec = error::no_memory;
			j-&gt;error.operation = operation_t::alloc_cache_piece;
			return status_t::fatal_disk_error;
		}

		time_point const start_time = clock_type::now();

		open_mode_t const file_flags = file_flags_for_job(j
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(228)">../src/disk_io_thread.cpp:1968</a></td><td>this is potentially very expensive. One way to solve it would be to have a fence for just this one piece.</td></tr><tr id="228" style="display: none;" colspan="3"><td colspan="3"><h2>this is potentially very expensive. One way to solve
it would be to have a fence for just this one piece.</h2><h4>../src/disk_io_thread.cpp:1968</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		disk_io_job* j = allocate_job(job_action_t::file_priority);
		j-&gt;storage = m_torrents[storage]-&gt;shared_from_this();
		j-&gt;argument = std::move(prios);
		j-&gt;callback = std::move(handler);

		add_fence_job(j);
	}

	void disk_io_thread::async_clear_piece(storage_index_t const storage
		, piece_index_t const index, std::function&lt;void(piece_index_t)&gt; handler)
	{
		disk_io_job* j = allocate_job(job_action_t::clear_piece);
		j-&gt;storage = m_torrents[storage]-&gt;shared_from_this();
		j-&gt;piece = index;
		j-&gt;callback = std::move(handler);

		// regular jobs are not guaranteed to be executed in-order
		// since clear piece must guarantee that all write jobs that
		// have been issued finish before the clear piece job completes

<div style="background: #ffff00" width="100%">		add_fence_job(j);
</div>	}

	void disk_io_thread::clear_piece(storage_index_t const storage
		, piece_index_t const index)
	{

		storage_interface* st = m_torrents[storage].get();
		std::unique_lock&lt;std::mutex&gt; l(m_cache_mutex);

		cached_piece_entry* pe = m_disk_cache.find_piece(st, index);
		if (pe == nullptr) return;
		TORRENT_PIECE_ASSERT(pe-&gt;hashing == false, pe);
		pe-&gt;hashing_done = 0;
		pe-&gt;hash.reset();

		// evict_piece returns true if the piece was in fact
		// evicted. A piece may fail to be evicted if there
		// are still outstanding operations on it, which should
		// never be the case when this function is used
		// in fact, no jobs should really be hung on this piece
		// at this point
		jobqueue_t jobs;
		bool const ok = m_disk_cache.evict_piece(pe, jobs, block_cache::allow_ghost);
		TORRENT_PIECE_ASSERT(ok, pe);
		TORRENT_UNUSED(ok);
		fail_jobs(storage_error(boost::asio::error::operation_aborted), jobs);
	}

	void disk_io_thread::kick_hasher(cached_piece_entry* pe, std::unique_lock&lt;std::mutex&gt;&amp; l)
	{
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(229)">../src/disk_io_thread.cpp:2225</a></td><td>we should probably just hang the job on the piece and make sure the hasher gets kicked</td></tr><tr id="229" style="display: none;" colspan="3"><td colspan="3"><h2>we should probably just hang the job on the piece and make sure the hasher gets kicked</h2><h4>../src/disk_io_thread.cpp:2225</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		if (pe == nullptr)
		{
			std::uint16_t const cache_state = std::uint16_t((j-&gt;flags &amp; disk_interface::volatile_read)
				? cached_piece_entry::volatile_read_lru
				: cached_piece_entry::read_lru1);
			pe = m_disk_cache.allocate_piece(j, cache_state);
		}
		if (pe == nullptr)
		{
			j-&gt;error.ec = error::no_memory;
			j-&gt;error.operation = operation_t::alloc_cache_piece;
			return status_t::fatal_disk_error;
		}

		if (pe-&gt;hashing)
		{
			TORRENT_PIECE_ASSERT(pe-&gt;hash, pe);
			// another thread is hashing this piece right now
			// try again in a little bit
			DLOG("do_hash: retry\n");
<div style="background: #ffff00" width="100%">			return retry_job;
</div>		}

		pe-&gt;hashing = 1;

		TORRENT_PIECE_ASSERT(pe-&gt;cache_state &lt;= cached_piece_entry::read_lru1
			|| pe-&gt;cache_state == cached_piece_entry::read_lru2, pe);

		piece_refcount_holder refcount_holder(pe);

		if (!pe-&gt;hash)
		{
			pe-&gt;hashing_done = 0;
			pe-&gt;hash.reset(new partial_hash);
		}
		partial_hash* ph = pe-&gt;hash.get();

		int const blocks_in_piece = (piece_size + default_block_size - 1) / default_block_size;

		// we don't care about anything to the left of ph-&gt;offset
		// since those blocks have already been hashed.
		// we just care about [firs_block, first_block + blocks_left]
		int const first_block = ph-&gt;offset / default_block_size;
		int const blocks_left = blocks_in_piece - first_block;

		//   ph-&gt;offset
		//           |  first_block
		//           |   |
		//           v   v
		// +---+---+---+---+---+---+
		// |   |   |   |   |   |   |
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(230)">../src/settings_pack.cpp:505</a></td><td>it would be nice to reserve() these vectors up front</td></tr><tr id="230" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to reserve() these vectors up front</h2><h4>../src/settings_pack.cpp:505</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			s.set_str(settings_pack::string_type_base + i, str_settings[i].default_value);
			TORRENT_ASSERT(s.get_str(settings_pack::string_type_base + i) == str_settings[i].default_value);
		}

		for (int i = 0; i &lt; settings_pack::num_int_settings; ++i)
		{
			s.set_int(settings_pack::int_type_base + i, int_settings[i].default_value);
			TORRENT_ASSERT(s.get_int(settings_pack::int_type_base + i) == int_settings[i].default_value);
		}

		for (int i = 0; i &lt; settings_pack::num_bool_settings; ++i)
		{
			s.set_bool(settings_pack::bool_type_base + i, bool_settings[i].default_value);
			TORRENT_ASSERT(s.get_bool(settings_pack::bool_type_base + i) == bool_settings[i].default_value);
		}
	}

	settings_pack default_settings()
	{
		settings_pack ret;
<div style="background: #ffff00" width="100%">		for (int i = 0; i &lt; settings_pack::num_string_settings; ++i)
</div>		{
			if (str_settings[i].default_value == nullptr) continue;
			ret.set_str(settings_pack::string_type_base + i, str_settings[i].default_value);
		}

		for (int i = 0; i &lt; settings_pack::num_int_settings; ++i)
		{
			ret.set_int(settings_pack::int_type_base + i, int_settings[i].default_value);
		}

		for (int i = 0; i &lt; settings_pack::num_bool_settings; ++i)
		{
			ret.set_bool(settings_pack::bool_type_base + i, bool_settings[i].default_value);
		}
		return ret;
	}

	void apply_pack(settings_pack const* pack, aux::session_settings&amp; sett
		, aux::session_impl* ses)
	{
		using fun_t = void (aux::session_impl::*)();
		std::vector&lt;fun_t&gt; callbacks;

		for (auto const&amp; p : pack-&gt;m_strings)
		{
			// disregard setting indices that are not string types
			if ((p.first &amp; settings_pack::type_mask) != settings_pack::string_type_base)
				continue;

			// ignore settings that are out of bounds
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(231)">../src/http_parser.cpp:138</a></td><td>remove to_string() if we're in C++14</td></tr><tr id="231" style="display: none;" colspan="3"><td colspan="3"><h2>remove to_string() if we're in C++14</h2><h4>../src/http_parser.cpp:138</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			// component or hostname.
			if (end &lt;= start + 2) end = std::string::npos;

			// if this fails, the referrer is just url-scheme and hostname. We can
			// just append the location to it.
			if (end != std::string::npos)
				url.resize(end);

			// however, we may still need to insert a '/' in case neither side
			// has one. We know the location doesn't start with a / already.
			// so, if the referrer doesn't end with one, add it.
			ensure_trailing_slash(url);
			url += location;
		}
		return url;
	}

	std::string const&amp; http_parser::header(string_view const key) const
	{
		static std::string const empty;
<div style="background: #ffff00" width="100%">		auto const i = m_header.find(key.to_string());
</div>		if (i == m_header.end()) return empty;
		return i-&gt;second;
	}

	boost::optional&lt;seconds32&gt; http_parser::header_duration(string_view const key) const
	{
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(232)">../src/http_parser.cpp:146</a></td><td>remove to_string() if we're in C++14</td></tr><tr id="232" style="display: none;" colspan="3"><td colspan="3"><h2>remove to_string() if we're in C++14</h2><h4>../src/http_parser.cpp:146</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
			// however, we may still need to insert a '/' in case neither side
			// has one. We know the location doesn't start with a / already.
			// so, if the referrer doesn't end with one, add it.
			ensure_trailing_slash(url);
			url += location;
		}
		return url;
	}

	std::string const&amp; http_parser::header(string_view const key) const
	{
		static std::string const empty;
		auto const i = m_header.find(key.to_string());
		if (i == m_header.end()) return empty;
		return i-&gt;second;
	}

	boost::optional&lt;seconds32&gt; http_parser::header_duration(string_view const key) const
	{
<div style="background: #ffff00" width="100%">		auto const i = m_header.find(key.to_string());
</div>		if (i == m_header.end()) return boost::none;
		auto const val = std::atol(i-&gt;second.c_str());
		if (val &lt;= 0) return boost::none;
		return seconds32(val);
	}

	http_parser::~http_parser() = default;

	http_parser::http_parser(int const flags) : m_flags(flags) {}

	std::tuple&lt;int, int&gt; http_parser::incoming(
		span&lt;char const&gt; recv_buffer, bool&amp; error)
	{
		TORRENT_ASSERT(recv_buffer.size() &gt;= m_recv_buffer.size());
		std::tuple&lt;int, int&gt; ret(0, 0);
		std::ptrdiff_t start_pos = m_recv_buffer.size();

		// early exit if there's nothing new in the receive buffer
		if (start_pos == recv_buffer.size()) return ret;
		m_recv_buffer = recv_buffer;

		if (m_state == error_state)
		{
			error = true;
			return ret;
		}

		char const* pos = recv_buffer.data() + m_recv_pos;

restart_response:
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(233)">../src/pe_crypto.cpp:62</a></td><td>it would be nice to get the literal working</td></tr><tr id="233" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to get the literal working</h2><h4>../src/pe_crypto.cpp:62</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#include &lt;boost/multiprecision/cpp_int.hpp&gt;

// for backwards compatibility with boost &lt; 1.60 which was before export_bits
// and import_bits were introduced
#if BOOST_VERSION &lt; 106000
#include "libtorrent/aux_/cppint_import_export.hpp"
#endif

#include "libtorrent/aux_/disable_warnings_pop.hpp"

#include "libtorrent/random.hpp"
#include "libtorrent/aux_/alloca.hpp"
#include "libtorrent/pe_crypto.hpp"
#include "libtorrent/hasher.hpp"

namespace libtorrent {

	namespace mp = boost::multiprecision;

	namespace {
<div style="background: #ffff00" width="100%">		key_t const dh_prime
</div>			("0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A63A36210000000000090563");
	}

	std::array&lt;char, 96&gt; export_key(key_t const&amp; k)
	{
		std::array&lt;char, 96&gt; ret;
		auto* begin = reinterpret_cast&lt;std::uint8_t*&gt;(ret.data());
		std::uint8_t* end = mp::export_bits(k, begin, 8);

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(234)">../src/pe_crypto.cpp:73</a></td><td>it would be nice to be able to export to a fixed width field, so we wouldn't have to shift it later</td></tr><tr id="234" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to be able to export to a fixed width field, so
we wouldn't have to shift it later</h2><h4>../src/pe_crypto.cpp:73</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#include "libtorrent/random.hpp"
#include "libtorrent/aux_/alloca.hpp"
#include "libtorrent/pe_crypto.hpp"
#include "libtorrent/hasher.hpp"

namespace libtorrent {

	namespace mp = boost::multiprecision;

	namespace {
		key_t const dh_prime
			("0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A63A36210000000000090563");
	}

	std::array&lt;char, 96&gt; export_key(key_t const&amp; k)
	{
		std::array&lt;char, 96&gt; ret;
		auto* begin = reinterpret_cast&lt;std::uint8_t*&gt;(ret.data());
		std::uint8_t* end = mp::export_bits(k, begin, 8);

<div style="background: #ffff00" width="100%">		if (end &lt; begin + 96)
</div>		{
			int const len = int(end - begin);
			std::memmove(begin + 96 - len, begin, aux::numeric_cast&lt;std::size_t&gt;(len));
			std::memset(begin, 0, aux::numeric_cast&lt;std::size_t&gt;(96 - len));
		}
		return ret;
	}

	void rc4_init(const unsigned char* in, std::size_t len, rc4 *state);
	std::size_t rc4_encrypt(unsigned char *out, std::size_t outlen, rc4 *state);

	// Set the prime P and the generator, generate local public key
	dh_key_exchange::dh_key_exchange()
	{
		aux::array&lt;std::uint8_t, 96&gt; random_key;
		aux::random_bytes({reinterpret_cast&lt;char*&gt;(random_key.data())
			, static_cast&lt;std::ptrdiff_t&gt;(random_key.size())});

		// create local key (random)
		mp::import_bits(m_dh_local_secret, random_key.begin(), random_key.end());

		// key = (2 ^ secret) % prime
		m_dh_local_key = mp::powm(key_t(2), m_dh_local_secret, dh_prime);
	}

	// compute shared secret given remote public key
	void dh_key_exchange::compute_secret(std::uint8_t const* remote_pubkey)
	{
		TORRENT_ASSERT(remote_pubkey);
		key_t key;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(235)">../src/udp_socket.cpp:506</a></td><td>use the system resolver_interface here</td></tr><tr id="235" style="display: none;" colspan="3"><td colspan="3"><h2>use the system resolver_interface here</h2><h4>../src/udp_socket.cpp:506</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	m_proxy_settings = ps;

	if (m_abort) return;

	if (ps.type == settings_pack::socks5
		|| ps.type == settings_pack::socks5_pw)
	{
		// connect to socks5 server and open up the UDP tunnel

		m_socks5_connection = std::make_shared&lt;socks5&gt;(m_socket.get_io_service());
		m_socks5_connection-&gt;start(ps);
	}
}

// ===================== SOCKS 5 =========================

void socks5::start(aux::proxy_settings const&amp; ps)
{
	m_proxy_settings = ps;

<div style="background: #ffff00" width="100%">	tcp::resolver::query q(ps.hostname, to_string(ps.port).data());
</div>	ADD_OUTSTANDING_ASYNC("socks5::on_name_lookup");
	m_resolver.async_resolve(q, std::bind(
		&amp;socks5::on_name_lookup, self(), _1, _2));
}

void socks5::on_name_lookup(error_code const&amp; e, tcp::resolver::iterator i)
{
	COMPLETE_ASYNC("socks5::on_name_lookup");

	if (m_abort) return;

	if (e == boost::asio::error::operation_aborted) return;

	if (e) return;

	m_proxy_addr.address(i-&gt;endpoint().address());
	m_proxy_addr.port(i-&gt;endpoint().port());

	error_code ec;
	m_socks5_sock.open(is_v4(m_proxy_addr) ? tcp::v4() : tcp::v6(), ec);

	// enable keepalives
	m_socks5_sock.set_option(boost::asio::socket_base::keep_alive(true), ec);

	ADD_OUTSTANDING_ASYNC("socks5::on_connected");
	m_socks5_sock.async_connect(tcp::endpoint(m_proxy_addr.address(), m_proxy_addr.port())
		, std::bind(&amp;socks5::on_connected, self(), _1));

	ADD_OUTSTANDING_ASYNC("socks5::on_connect_timeout");
	m_timer.expires_from_now(seconds(10));
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(236)">../src/file_storage.cpp:976</a></td><td>padfiles should be removed</td></tr><tr id="236" style="display: none;" colspan="3"><td colspan="3"><h2>padfiles should be removed</h2><h4>../src/file_storage.cpp:976</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	void file_storage::swap(file_storage&amp; ti) noexcept
	{
		using std::swap;
		swap(ti.m_files, m_files);
		swap(ti.m_file_hashes, m_file_hashes);
		swap(ti.m_symlinks, m_symlinks);
		swap(ti.m_mtime, m_mtime);
		swap(ti.m_paths, m_paths);
		swap(ti.m_name, m_name);
		swap(ti.m_total_size, m_total_size);
		swap(ti.m_num_pieces, m_num_pieces);
		swap(ti.m_piece_length, m_piece_length);
	}

	void file_storage::optimize(int const pad_file_limit, int alignment
		, bool const tail_padding)
	{
		if (alignment == -1)
			alignment = m_piece_length;

<div style="background: #ffff00" width="100%">
</div>		std::int64_t off = 0;
		int padding_file = 0;
		for (auto i = m_files.begin(); i != m_files.end(); ++i)
		{
			if ((off % alignment) == 0)
			{
				// this file position is aligned, pick the largest
				// available file to put here. If we encounter a file whose size is
				// divisible by `alignment`, we pick that immediately, since that
				// will not affect whether we're at an aligned position and will
				// improve packing of files
				auto best_match = i;
				for (auto k = i; k != m_files.end(); ++k)
				{
					// a file whose size fits the alignment always takes priority,
					// since it will let us keep placing aligned files
					if ((k-&gt;size % aux::numeric_cast&lt;std::uint64_t&gt;(alignment)) == 0)
					{
						best_match = k;
						break;
					}
					// otherwise, pick the largest file, to have as many bytes be
					// aligned.
					if (best_match-&gt;size &lt; k-&gt;size) best_match = k;
				}

				if (best_match != i)
				{
					int const index = int(best_match - m_files.begin());
					int const cur_index = int(i - m_files.begin());
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(237)">../src/block_cache.cpp:1004</a></td><td>it's somewhat expensive to iterate over this linked list. Presumably because of the random access of memory. It would be nice if pieces with no evictable blocks weren't in this list</td></tr><tr id="237" style="display: none;" colspan="3"><td colspan="3"><h2>it's somewhat expensive
to iterate over this linked list. Presumably because of the random
access of memory. It would be nice if pieces with no evictable blocks
weren't in this list</h2><h4>../src/block_cache.cpp:1004</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	}
	else if (m_last_cache_op == ghost_hit_lru1)
	{
		// when we insert new items or move things from L1 to L2
		// evict blocks from L2
		lru_list[1] = &amp;m_lru[cached_piece_entry::read_lru2];
		lru_list[2] = &amp;m_lru[cached_piece_entry::read_lru1];
	}
	else
	{
		// when we get cache hits in L2 evict from L1
		lru_list[1] = &amp;m_lru[cached_piece_entry::read_lru1];
		lru_list[2] = &amp;m_lru[cached_piece_entry::read_lru2];
	}

	// end refers to which end of the ARC cache we're evicting
	// from. The LFU or the LRU end
	for (int end = 0; num &gt; 0 &amp;&amp; end &lt; 3; ++end)
	{
		// iterate over all blocks in order of last being used (oldest first) and
<div style="background: #ffff00" width="100%">		for (auto i = lru_list[end]-&gt;iterate(); i.get() &amp;&amp; num &gt; 0;)
</div>		{
			cached_piece_entry* pe = i.get();
			TORRENT_PIECE_ASSERT(pe-&gt;in_use, pe);
			i.next();

			if (pe == ignore)
				continue;

			if (pe-&gt;ok_to_evict() &amp;&amp; pe-&gt;num_blocks == 0)
			{
#if TORRENT_USE_INVARIANT_CHECKS
				for (int j = 0; j &lt; pe-&gt;blocks_in_piece; ++j)
					TORRENT_PIECE_ASSERT(pe-&gt;blocks[j].buf == nullptr, pe);
#endif
				TORRENT_PIECE_ASSERT(pe-&gt;refcount == 0, pe);
				move_to_ghost(pe);
				continue;
			}

			TORRENT_PIECE_ASSERT(pe-&gt;num_dirty == 0, pe);

			// all blocks are pinned in this piece, skip it
			if (pe-&gt;num_blocks &lt;= pe-&gt;pinned) continue;

			// go through the blocks and evict the ones that are not dirty and not
			// referenced
			int removed = 0;
			for (int j = 0; j &lt; pe-&gt;blocks_in_piece &amp;&amp; num &gt; 0; ++j)
			{
				cached_block_entry&amp; b = pe-&gt;blocks[j];
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(238)">../src/block_cache.cpp:1075</a></td><td>this should probably only be done every n:th time</td></tr><tr id="238" style="display: none;" colspan="3"><td colspan="3"><h2>this should probably only be done every n:th time</h2><h4>../src/block_cache.cpp:1075</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			}

			if (pe-&gt;ok_to_evict() &amp;&amp; pe-&gt;num_blocks == 0)
			{
#if TORRENT_USE_INVARIANT_CHECKS
				for (int j = 0; j &lt; pe-&gt;blocks_in_piece; ++j)
					TORRENT_PIECE_ASSERT(pe-&gt;blocks[j].buf == nullptr, pe);
#endif
				move_to_ghost(pe);
			}
		}
	}

	// if we can't evict enough blocks from the read cache, also look at write
	// cache pieces for blocks that have already been written to disk and can be
	// evicted the first pass, we only evict blocks that have been hashed, the
	// second pass we flush anything this is potentially a very expensive
	// operation, since we're likely to have iterate every single block in the
	// cache, and we might not get to evict anything.

<div style="background: #ffff00" width="100%">	if (num &gt; 0 &amp;&amp; m_read_cache_size &gt; m_pinned_blocks)
</div>	{
		for (int pass = 0; pass &lt; 2 &amp;&amp; num &gt; 0; ++pass)
		{
			for (auto i = m_lru[cached_piece_entry::write_lru].iterate(); i.get() &amp;&amp; num &gt; 0;)
			{
				cached_piece_entry* pe = i.get();
				TORRENT_PIECE_ASSERT(pe-&gt;in_use, pe);

				i.next();

				if (pe == ignore)
					continue;

				if (pe-&gt;ok_to_evict() &amp;&amp; pe-&gt;num_blocks == 0)
				{
#if TORRENT_USE_INVARIANT_CHECKS
					for (int j = 0; j &lt; pe-&gt;blocks_in_piece; ++j)
						TORRENT_PIECE_ASSERT(pe-&gt;blocks[j].buf == nullptr, pe);
#endif
					TORRENT_PIECE_ASSERT(pe-&gt;refcount == 0, pe);
					erase_piece(pe);
					continue;
				}

				// all blocks in this piece are dirty
				if (pe-&gt;num_dirty == pe-&gt;num_blocks)
					continue;

				int end = pe-&gt;blocks_in_piece;

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(239)">../src/block_cache.cpp:1709</a></td><td>create a holder for refcounts that automatically decrement</td></tr><tr id="239" style="display: none;" colspan="3"><td colspan="3"><h2>create a holder for refcounts that automatically decrement</h2><h4>../src/block_cache.cpp:1709</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	j-&gt;argument = disk_buffer_holder(allocator
		, allocate_buffer("send buffer"), 0x4000);
	if (!boost::get&lt;disk_buffer_holder&gt;(j-&gt;argument)) return -2;

	while (size &gt; 0)
	{
		TORRENT_PIECE_ASSERT(pe-&gt;blocks[block].buf, pe);
		int const to_copy = std::min(default_block_size - block_offset, size);
		std::memcpy(boost::get&lt;disk_buffer_holder&gt;(j-&gt;argument).get()
			+ buffer_offset
			, pe-&gt;blocks[block].buf + block_offset
			, aux::numeric_cast&lt;std::size_t&gt;(to_copy));
		pe-&gt;blocks[block].cache_hit = 1;
		size -= to_copy;
		block_offset = 0;
		buffer_offset += to_copy;
		++block;
	}
	// we incremented the refcount for both of these blocks.
	// now decrement it.
<div style="background: #ffff00" width="100%">	dec_block_refcount(pe, start_block, ref_reading);
</div>	if (blocks_to_read == 2) dec_block_refcount(pe, start_block + 1, ref_reading);
	maybe_free_piece(pe);
	return j-&gt;d.io.buffer_size;
}

void block_cache::reclaim_block(storage_interface* st, aux::block_cache_reference const&amp; ref)
{
	TORRENT_ASSERT(st != nullptr);
	int const blocks_per_piece = (st-&gt;files().piece_length() + default_block_size - 1) / default_block_size;
	piece_index_t const piece(ref.cookie / blocks_per_piece);
	int const block(ref.cookie % blocks_per_piece);

	cached_piece_entry* pe = find_piece(st, piece);
	TORRENT_ASSERT(pe);
	if (pe == nullptr) return;

	TORRENT_PIECE_ASSERT(pe-&gt;in_use, pe);

	TORRENT_PIECE_ASSERT(pe-&gt;blocks[block].buf, pe);
	dec_block_refcount(pe, block, block_cache::ref_reading);

	TORRENT_PIECE_ASSERT(m_send_buffer_blocks &gt; 0, pe);
	--m_send_buffer_blocks;

	maybe_free_piece(pe);
}

bool block_cache::maybe_free_piece(cached_piece_entry* pe)
{
	if (!pe-&gt;ok_to_evict()
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(240)">../src/kademlia/item.cpp:146</a></td><td>implement ctor for entry from bdecode_node?</td></tr><tr id="240" style="display: none;" colspan="3"><td colspan="3"><h2>implement ctor for entry from bdecode_node?</h2><h4>../src/kademlia/item.cpp:146</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	return ed25519_sign({str, len}, pk, sk);
}

item::item(public_key const&amp; pk, span&lt;char const&gt; salt)
	: m_salt(salt.data(), static_cast&lt;std::size_t&gt;(salt.size()))
	, m_pk(pk)
	, m_seq(0)
	, m_mutable(true)
{}

item::item(entry v)
	: m_value(std::move(v))
	, m_seq(0)
	, m_mutable(false)
{}

item::item(bdecode_node const&amp; v)
	: m_seq(0)
	, m_mutable(false)
{
<div style="background: #ffff00" width="100%">	m_value = v;
</div>}

item::item(entry v, span&lt;char const&gt; salt
	, sequence_number const seq, public_key const&amp; pk, secret_key const&amp; sk)
{
	assign(std::move(v), salt, seq, pk, sk);
}

void item::assign(entry v)
{
	m_mutable = false;
	m_value = std::move(v);
}

void item::assign(entry v, span&lt;char const&gt; salt
	, sequence_number const seq, public_key const&amp; pk, secret_key const&amp; sk)
{
	std::array&lt;char, 1000&gt; buffer;
	int const bsize = bencode(buffer.begin(), v);
	TORRENT_ASSERT(bsize &lt;= 1000);
	m_sig = sign_mutable_item(span&lt;char const&gt;(buffer).first(bsize)
		, salt, seq, pk, sk);
	m_salt.assign(salt.data(), static_cast&lt;std::size_t&gt;(salt.size()));
	m_pk = pk;
	m_seq = seq;
	m_mutable = true;
	m_value = std::move(v);
}

void item::assign(bdecode_node const&amp; v)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(241)">../src/kademlia/node.cpp:1164</a></td><td>keep the returned value to pass as a limit to write_nodes_entries when implemented</td></tr><tr id="241" style="display: none;" colspan="3"><td colspan="3"><h2>keep the returned value to pass as a limit
to write_nodes_entries when implemented</h2><h4>../src/kademlia/node.cpp:1164</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		}
	}
	else if (query == "sample_infohashes")
	{
		static key_desc_t const msg_desc[] = {
			{"target", bdecode_node::string_t, 20, 0},
			{"want", bdecode_node::list_t, 0, key_desc_t::optional},
		};

		bdecode_node msg_keys[2];
		if (!verify_message(arg_ent, msg_desc, msg_keys, error_string))
		{
			m_counters.inc_stats_counter(counters::dht_invalid_sample_infohashes);
			incoming_error(e, error_string);
			return;
		}

		m_counters.inc_stats_counter(counters::dht_sample_infohashes_in);
		sha1_hash const target(msg_keys[0].string_ptr());

<div style="background: #ffff00" width="100%">		m_storage.get_infohashes_sample(reply);
</div>
		write_nodes_entries(target, msg_keys[1], reply);
	}
	else
	{
		// if we don't recognize the message but there's a
		// 'target' or 'info_hash' in the arguments, treat it
		// as find_node to be future compatible
		bdecode_node target_ent = arg_ent.dict_find_string("target");
		if (!target_ent || target_ent.string_length() != 20)
		{
			target_ent = arg_ent.dict_find_string("info_hash");
			if (!target_ent || target_ent.string_length() != 20)
			{
				incoming_error(e, "unknown message");
				return;
			}
		}

		sha1_hash const target(target_ent.string_ptr());
		// always return nodes as well as peers
		write_nodes_entries(target, arg_ent.dict_find_list("want"), reply);
	}
}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(242)">../src/kademlia/node.cpp:1192</a></td><td>limit number of entries in the result</td></tr><tr id="242" style="display: none;" colspan="3"><td colspan="3"><h2>limit number of entries in the result</h2><h4>../src/kademlia/node.cpp:1192</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// if we don't recognize the message but there's a
		// 'target' or 'info_hash' in the arguments, treat it
		// as find_node to be future compatible
		bdecode_node target_ent = arg_ent.dict_find_string("target");
		if (!target_ent || target_ent.string_length() != 20)
		{
			target_ent = arg_ent.dict_find_string("info_hash");
			if (!target_ent || target_ent.string_length() != 20)
			{
				incoming_error(e, "unknown message");
				return;
			}
		}

		sha1_hash const target(target_ent.string_ptr());
		// always return nodes as well as peers
		write_nodes_entries(target, arg_ent.dict_find_list("want"), reply);
	}
}

<div style="background: #ffff00" width="100%">void node::write_nodes_entries(sha1_hash const&amp; info_hash
</div>	, bdecode_node const&amp; want, entry&amp; r)
{
	// if no wants entry was specified, include a nodes
	// entry based on the protocol the request came in with
	if (want.type() != bdecode_node::list_t)
	{
		std::vector&lt;node_entry&gt; n;
		m_table.find_node(info_hash, n, 0);
		r[protocol_nodes_key()] = write_nodes_entry(n);
		return;
	}

	// if there is a wants entry then we may need to reach into
	// another node's routing table to get nodes of the requested type
	// we use a map maintained by the owning dht_tracker to find the
	// node associated with each string in the want list, which may
	// include this node
	for (int i = 0; i &lt; want.list_size(); ++i)
	{
		bdecode_node wanted = want.list_at(i);
		if (wanted.type() != bdecode_node::string_t)
			continue;
		node* wanted_node = m_get_foreign_node(info_hash, wanted.string_value().to_string());
		if (!wanted_node) continue;
		std::vector&lt;node_entry&gt; n;
		wanted_node-&gt;m_table.find_node(info_hash, n, 0);
		r[wanted_node-&gt;protocol_nodes_key()] = write_nodes_entry(n);
	}
}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(243)">../src/kademlia/routing_table.cpp:152</a></td><td>arvidn note when it's across IPv4 and IPv6, adding (dht_global_nodes) would make sense. in the future though, where we may have one DHT node per external interface (which may be multiple of the same address family), then it becomes a bit trickier</td></tr><tr id="243" style="display: none;" colspan="3"><td colspan="3"><h2>arvidn note
when it's across IPv4 and IPv6, adding (dht_global_nodes) would
make sense. in the future though, where we may have one DHT node
per external interface (which may be multiple of the same address
family), then it becomes a bit trickier</h2><h4>../src/kademlia/routing_table.cpp:152</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">void routing_table::status(std::vector&lt;dht_routing_bucket&gt;&amp; s) const
{
	for (auto const&amp; i : m_buckets)
	{
		dht_routing_bucket b;
		b.num_nodes = int(i.live_nodes.size());
		b.num_replacements = int(i.replacements.size());
		s.push_back(b);
	}
}

#if TORRENT_ABI_VERSION == 1
void routing_table::status(session_status&amp; s) const
{
	int dht_nodes;
	int dht_node_cache;
	int ignore;
	std::tie(dht_nodes, dht_node_cache, ignore) = size();
	s.dht_nodes += dht_nodes;
	s.dht_node_cache += dht_node_cache;
<div style="background: #ffff00" width="100%">	s.dht_global_nodes += num_global_nodes();
</div>
	for (auto const&amp; i : m_buckets)
	{
		dht_routing_bucket b;
		b.num_nodes = int(i.live_nodes.size());
		b.num_replacements = int(i.replacements.size());
#if TORRENT_ABI_VERSION == 1
		b.last_active = 0;
#endif
		s.dht_routing_table.push_back(b);
	}
}
#endif

std::tuple&lt;int, int, int&gt; routing_table::size() const
{
	int nodes = 0;
	int replacements = 0;
	int confirmed = 0;
	for (auto const&amp; i : m_buckets)
	{
		nodes += int(i.live_nodes.size());
		confirmed += static_cast&lt;int&gt;(std::count_if(i.live_nodes.begin(), i.live_nodes.end()
			, [](node_entry const&amp; k) { return k.confirmed(); } ));

		replacements += int(i.replacements.size());
	}
	return std::make_tuple(nodes, replacements, confirmed);
}

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(244)">../src/kademlia/put_data.cpp:88</a></td><td>what if o is not an instance of put_data_observer? This need to be redesigned for better type safety.</td></tr><tr id="244" style="display: none;" colspan="3"><td colspan="3"><h2>what if o is not an instance of put_data_observer? This need to be
redesigned for better type safety.</h2><h4>../src/kademlia/put_data.cpp:88</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	}
}

void put_data::done()
{
	m_done = true;

#ifndef TORRENT_DISABLE_LOGGING
	get_node().observer()-&gt;log(dht_logger::traversal, "[%u] %s DONE, response %d, timeout %d"
		, id(), name(), num_responses(), num_timeouts());
#endif

	m_put_callback(m_data, num_responses());
	traversal_algorithm::done();
}

bool put_data::invoke(observer_ptr o)
{
	if (m_done) return false;

<div style="background: #ffff00" width="100%">	auto* po = static_cast&lt;put_data_observer*&gt;(o.get());
</div>
	entry e;
	e["y"] = "q";
	e["q"] = "put";
	entry&amp; a = e["a"];
	a["v"] = m_data.value();
	a["token"] = po-&gt;m_token;
	if (m_data.is_mutable())
	{
		a["k"] = m_data.pk().bytes;
		a["seq"] = m_data.seq().value;
		a["sig"] = m_data.sig().bytes;
		if (!m_data.salt().empty())
		{
			a["salt"] = m_data.salt();
		}
	}

	m_node.stats_counters().inc_stats_counter(counters::dht_put_out);

	return m_node.m_rpc.invoke(e, o-&gt;target_ep(), o);
}

} } // namespace libtorrent::dht
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(245)">../src/kademlia/node_id.cpp:64</a></td><td>it's a little bit weird to return 159 - leading zeroes. It should probably be 160 - leading zeroes, but all other code in here is tuned to this expectation now, and it doesn't really matter (other than complexity)</td></tr><tr id="245" style="display: none;" colspan="3"><td colspan="3"><h2>it's a little bit weird to return 159 - leading zeroes. It should
probably be 160 - leading zeroes, but all other code in here is tuned to
this expectation now, and it doesn't really matter (other than complexity)</h2><h4>../src/kademlia/node_id.cpp:64</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
// returns the distance between the two nodes
// using the kademlia XOR-metric
node_id distance(node_id const&amp; n1, node_id const&amp; n2)
{
	return n1 ^ n2;
}

// returns true if: distance(n1, ref) &lt; distance(n2, ref)
bool compare_ref(node_id const&amp; n1, node_id const&amp; n2, node_id const&amp; ref)
{
	node_id const lhs = n1 ^ ref;
	node_id const rhs = n2 ^ ref;
	return lhs &lt; rhs;
}

// returns n in: 2^n &lt;= distance(n1, n2) &lt; 2^(n+1)
// useful for finding out which bucket a node belongs to
int distance_exp(node_id const&amp; n1, node_id const&amp; n2)
{
<div style="background: #ffff00" width="100%">	return std::max(159 - distance(n1, n2).count_leading_zeroes(), 0);
</div>}

int min_distance_exp(node_id const&amp; n1, std::vector&lt;node_id&gt; const&amp; ids)
{
	TORRENT_ASSERT(ids.size() &gt; 0);

	int min = 160; // see distance_exp for the why of this constant
	for (auto const&amp; node_id : ids)
	{
		min = std::min(min, distance_exp(n1, node_id));
	}

	return min;
}

node_id generate_id_impl(address const&amp; ip_, std::uint32_t r)
{
	std::uint8_t* ip = nullptr;

	static std::uint8_t const v4mask[] = { 0x03, 0x0f, 0x3f, 0xff };
	static std::uint8_t const v6mask[] = { 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff };
	std::uint8_t const* mask = nullptr;
	int num_octets = 0;

	address_v4::bytes_type b4{};
	address_v6::bytes_type b6{};
	if (ip_.is_v6())
	{
		b6 = ip_.to_v6().to_bytes();
		ip = b6.data();
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(246)">../src/kademlia/dht_tracker.cpp:317</a></td><td>pick the closest node rather than the first</td></tr><tr id="246" style="display: none;" colspan="3"><td colspan="3"><h2>pick the closest node rather than the first</h2><h4>../src/kademlia/dht_tracker.cpp:317</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			n.second.dht.new_write_key();

#ifndef TORRENT_DISABLE_LOGGING
		m_log-&gt;log(dht_logger::tracker, "*** new write key***");
#endif
	}

	void dht_tracker::update_storage_node_ids()
	{
		std::vector&lt;sha1_hash&gt; ids;
		for (auto&amp; n : m_nodes)
			ids.push_back(n.second.dht.nid());
		m_storage.update_node_ids(ids);
	}

	node* dht_tracker::get_node(node_id const&amp; id, std::string const&amp; family_name)
	{
		TORRENT_UNUSED(id);
		for (auto&amp; n : m_nodes)
		{
<div style="background: #ffff00" width="100%">			if (n.second.dht.protocol_family_name() == family_name)
</div>				return &amp;n.second.dht;
		}

		return nullptr;
	}

	void dht_tracker::get_peers(sha1_hash const&amp; ih
		, std::function&lt;void(std::vector&lt;tcp::endpoint&gt; const&amp;)&gt; f)
	{
		for (auto&amp; n : m_nodes)
			n.second.dht.get_peers(ih, f, {}, {});
	}

	void dht_tracker::announce(sha1_hash const&amp; ih, int listen_port
		, announce_flags_t const flags
		, std::function&lt;void(std::vector&lt;tcp::endpoint&gt; const&amp;)&gt; f)
	{
		for (auto&amp; n : m_nodes)
			n.second.dht.announce(ih, listen_port, flags, f);
	}

	void dht_tracker::sample_infohashes(udp::endpoint const&amp; ep, sha1_hash const&amp; target
		, std::function&lt;void(time_duration
			, int, std::vector&lt;sha1_hash&gt;
			, std::vector&lt;std::pair&lt;sha1_hash, udp::endpoint&gt;&gt;)&gt; f)
	{
		for (auto&amp; n : m_nodes)
		{
			if (ep.protocol() != (n.first.get_external_address().is_v4() ? udp::v4() : udp::v6()))
				continue;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(247)">../include/libtorrent/config.hpp:44</a></td><td>don't include that here. Make each header that use the export macros include it instead. and move it to aux_</td></tr><tr id="247" style="display: none;" colspan="3"><td colspan="3"><h2>don't include that here. Make each header that use the export macros
include it instead. and move it to aux_</h2><h4>../include/libtorrent/config.hpp:44</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

*/

#ifndef TORRENT_CONFIG_HPP_INCLUDED
#define TORRENT_CONFIG_HPP_INCLUDED

#include "libtorrent/aux_/disable_warnings_push.hpp"

#define _FILE_OFFSET_BITS 64

#include &lt;boost/config.hpp&gt;

#include "libtorrent/aux_/disable_warnings_pop.hpp"

<div style="background: #ffff00" width="100%">#include "libtorrent/aux_/export.hpp"
</div>
#ifdef __linux__
#include &lt;linux/version.h&gt; // for LINUX_VERSION_CODE and KERNEL_VERSION
#endif // __linux

#if defined __MINGW64__ || defined __MINGW32__
// GCC warns on format codes that are incompatible with glibc, which the windows
// format codes are. So we need to disable those for mingw targets
#pragma GCC diagnostic ignored "-Wformat"
#pragma GCC diagnostic ignored "-Wformat-extra-args"
#endif

// ====== CLANG ========

#if defined __clang__

# if !defined TORRENT_BUILDING_LIBRARY
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(248)">../include/libtorrent/config.hpp:64</a></td><td>figure out which version of clang this is supported in</td></tr><tr id="248" style="display: none;" colspan="3"><td colspan="3"><h2>figure out which version of clang this is supported in</h2><h4>../include/libtorrent/config.hpp:64</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#include "libtorrent/aux_/disable_warnings_pop.hpp"

#include "libtorrent/aux_/export.hpp"

#ifdef __linux__
#include &lt;linux/version.h&gt; // for LINUX_VERSION_CODE and KERNEL_VERSION
#endif // __linux

#if defined __MINGW64__ || defined __MINGW32__
// GCC warns on format codes that are incompatible with glibc, which the windows
// format codes are. So we need to disable those for mingw targets
#pragma GCC diagnostic ignored "-Wformat"
#pragma GCC diagnostic ignored "-Wformat-extra-args"
#endif

// ====== CLANG ========

#if defined __clang__

# if !defined TORRENT_BUILDING_LIBRARY
<div style="background: #ffff00" width="100%">#  define TORRENT_DEPRECATED_ENUM __attribute__ ((deprecated))
</div>#  define TORRENT_DEPRECATED_MEMBER __attribute__ ((deprecated))
# endif

// ======= GCC =========

#elif defined __GNUC__

#ifdef _GLIBCXX_CONCEPT_CHECKS
#define TORRENT_COMPLETE_TYPES_REQUIRED 1
#endif

// deprecation markup is only enabled when libtorrent
// headers are included by clients, not while building
// libtorrent itself
# if __GNUC__ &gt;= 3 &amp;&amp; !defined TORRENT_BUILDING_LIBRARY
#  define TORRENT_DEPRECATED __attribute__ ((deprecated))
# endif

# if __GNUC__ &gt;= 6 &amp;&amp; !defined TORRENT_BUILDING_LIBRARY
#  define TORRENT_DEPRECATED_ENUM __attribute__ ((deprecated))
#  define TORRENT_DEPRECATED_MEMBER __attribute__ ((deprecated))
# endif

// ======= SUNPRO =========

#elif defined __SUNPRO_CC

#define TORRENT_COMPLETE_TYPES_REQUIRED 1

// ======= MSVC =========
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(249)">../include/libtorrent/performance_counters.hpp:47</a></td><td>move this out of counters</td></tr><tr id="249" style="display: none;" colspan="3"><td colspan="3"><h2>move this out of counters</h2><h4>../include/libtorrent/performance_counters.hpp:47</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

*/

#ifndef TORRENT_PERFORMANCE_COUNTERS_HPP_INCLUDED
#define TORRENT_PERFORMANCE_COUNTERS_HPP_INCLUDED

#include "libtorrent/config.hpp"
#include "libtorrent/aux_/array.hpp"

#include &lt;cstdint&gt;
#include &lt;atomic&gt;
#include &lt;mutex&gt;

namespace libtorrent {

	struct TORRENT_EXTRA_EXPORT counters
	{
<div style="background: #ffff00" width="100%">		enum stats_counter_t
</div>		{
			// the number of peers that were disconnected this
			// tick due to protocol error
			error_peers,
			disconnected_peers,
			eof_peers,
			connreset_peers,
			connrefused_peers,
			connaborted_peers,
			notconnected_peers,
			perm_peers,
			buffer_peers,
			unreachable_peers,
			broken_pipe_peers,
			addrinuse_peers,
			no_access_peers,
			invalid_arg_peers,
			aborted_peers,

			piece_requests,
			max_piece_requests,
			invalid_piece_requests,
			choked_piece_requests,
			cancelled_piece_requests,
			piece_rejects,
			error_incoming_peers,
			error_outgoing_peers,
			error_rc4_peers,
			error_encrypted_peers,
			error_tcp_peers,
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(250)">../include/libtorrent/performance_counters.hpp:151</a></td><td>should keepalives be in here too? how about dont-have, share-mode, upload-only</td></tr><tr id="250" style="display: none;" colspan="3"><td colspan="3"><h2>should keepalives be in here too?
how about dont-have, share-mode, upload-only</h2><h4>../include/libtorrent/performance_counters.hpp:151</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			// successful incoming connections (not rejected for any reason)
			incoming_connections,

			// counts events where the network
			// thread wakes up
			on_read_counter,
			on_write_counter,
			on_tick_counter,
			on_lsd_counter,
			on_lsd_peer_counter,
			on_udp_counter,
			on_accept_counter,
			on_disk_queue_counter,
			on_disk_counter,

#if TORRENT_ABI_VERSION == 1
			torrent_evicted_counter,
#endif

			// bittorrent message counters
<div style="background: #ffff00" width="100%">			num_incoming_choke,
</div>			num_incoming_unchoke,
			num_incoming_interested,
			num_incoming_not_interested,
			num_incoming_have,
			num_incoming_bitfield,
			num_incoming_request,
			num_incoming_piece,
			num_incoming_cancel,
			num_incoming_dht_port,
			num_incoming_suggest,
			num_incoming_have_all,
			num_incoming_have_none,
			num_incoming_reject,
			num_incoming_allowed_fast,
			num_incoming_ext_handshake,
			num_incoming_pex,
			num_incoming_metadata,
			num_incoming_extended,

			num_outgoing_choke,
			num_outgoing_unchoke,
			num_outgoing_interested,
			num_outgoing_not_interested,
			num_outgoing_have,
			num_outgoing_bitfield,
			num_outgoing_request,
			num_outgoing_piece,
			num_outgoing_cancel,
			num_outgoing_dht_port,
			num_outgoing_suggest,
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(251)">../include/libtorrent/performance_counters.hpp:493</a></td><td>some space could be saved here by making gauges 32 bits</td></tr><tr id="251" style="display: none;" colspan="3"><td colspan="3"><h2>some space could be saved here by making gauges 32 bits</h2><h4>../include/libtorrent/performance_counters.hpp:493</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;"></pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(252)">../include/libtorrent/performance_counters.hpp:494</a></td><td>restore these to regular integers. Instead have one copy of the counters per thread and collect them at convenient synchronization points</td></tr><tr id="252" style="display: none;" colspan="3"><td colspan="3"><h2>restore these to regular integers. Instead have one copy
of the counters per thread and collect them at convenient
synchronization points</h2><h4>../include/libtorrent/performance_counters.hpp:494</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#ifdef ATOMIC_LLONG_LOCK_FREE
#define TORRENT_COUNTER_NOEXCEPT noexcept
#else
#define TORRENT_COUNTER_NOEXCEPT
#endif

		counters() TORRENT_COUNTER_NOEXCEPT;

		counters(counters const&amp;) TORRENT_COUNTER_NOEXCEPT;
		counters&amp; operator=(counters const&amp;) TORRENT_COUNTER_NOEXCEPT;

		// returns the new value
		std::int64_t inc_stats_counter(int c, std::int64_t value = 1) TORRENT_COUNTER_NOEXCEPT;
		std::int64_t operator[](int i) const TORRENT_COUNTER_NOEXCEPT;

		void set_value(int c, std::int64_t value) TORRENT_COUNTER_NOEXCEPT;
		void blend_stats_counter(int c, std::int64_t value, int ratio) TORRENT_COUNTER_NOEXCEPT;

	private:

<div style="background: #ffff00" width="100%">#ifdef ATOMIC_LLONG_LOCK_FREE
</div>		aux::array&lt;std::atomic&lt;std::int64_t&gt;, num_counters&gt; m_stats_counter;
#else
		// if the atomic type is't lock-free, use a single lock instead, for
		// the whole array
		mutable std::mutex m_mutex;
		aux::array&lt;std::int64_t, num_counters&gt; m_stats_counter;
#endif
	};
}

#endif
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(253)">../include/libtorrent/peer_connection.hpp:186</a></td><td>make this a raw pointer (to save size in the first cache line) and make the constructor take a raw pointer. torrent objects should always outlive their peers</td></tr><tr id="253" style="display: none;" colspan="3"><td colspan="3"><h2>make this a raw pointer (to save size in
the first cache line) and make the constructor
take a raw pointer. torrent objects should always
outlive their peers</h2><h4>../include/libtorrent/peer_connection.hpp:186</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			, m_snubbed(false)
			, m_interesting(false)
			, m_choked(true)
			, m_ignore_stats(false)
		{}

		// explicitly disallow assignment, to silence msvc warning
		peer_connection_hot_members&amp; operator=(peer_connection_hot_members const&amp;) = delete;

	protected:

		// the pieces the other end have
		typed_bitfield&lt;piece_index_t&gt; m_have_piece;

		// this is the torrent this connection is
		// associated with. If the connection is an
		// incoming connection, this is set to zero
		// until the info_hash is received. Then it's
		// set to the torrent it belongs to.

<div style="background: #ffff00" width="100%">		std::weak_ptr&lt;torrent&gt; m_torrent;
</div>
	public:

		// a back reference to the session
		// the peer belongs to.
		aux::session_interface&amp; m_ses;

		// settings that apply to this peer
		aux::session_settings const&amp; m_settings;

	protected:

		// this is true if this connection has been added
		// to the list of connections that will be closed.
		bool m_disconnecting:1;

		// this is true until this socket has become
		// writable for the first time (i.e. the
		// connection completed). While connecting
		// the timeout will not be triggered. This is
		// because windows XP SP2 may delay connection
		// attempts, which means that the connection
		// may not even have been attempted when the
		// time out is reached.
		bool m_connecting:1;

		// this is set to true if the last time we tried to
		// pick a piece to download, we could only find
		// blocks that were already requested from other
		// peers. In this case, we should not try to pick
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(254)">../include/libtorrent/peer_connection.hpp:980</a></td><td>factor this out into its own class with a virtual interface torrent and session should implement this interface</td></tr><tr id="254" style="display: none;" colspan="3"><td colspan="3"><h2>factor this out into its own class with a virtual interface
torrent and session should implement this interface</h2><h4>../include/libtorrent/peer_connection.hpp:980</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// the local endpoint for this peer, i.e. our address
		// and our port. If this is set for outgoing connections
		// before the connection completes, it means we want to
		// force the connection to be bound to the specified interface.
		// if it ends up being bound to a different local IP, the connection
		// is closed.
		tcp::endpoint m_local;

		// remote peer's id
		peer_id m_peer_id;

	protected:

		template &lt;typename Fun, typename... Args&gt;
		void wrap(Fun f, Args&amp;&amp;... a);

		// statistics about upload and download speeds
		// and total amount of uploads and downloads for
		// this peer
<div style="background: #ffff00" width="100%">		stat m_statistics;
</div>
		// the number of outstanding bytes expected
		// to be received by extensions
		int m_extension_outstanding_bytes = 0;

		// the number of time critical requests
		// queued up in the m_request_queue that
		// soon will be committed to the download
		// queue. This is included in download_queue_time()
		// so that it can be used while adding more
		// requests and take the previous requests
		// into account without submitting it all
		// immediately
		int m_queued_time_critical = 0;

		// the number of bytes we are currently reading
		// from disk, that will be added to the send
		// buffer as soon as they complete
		int m_reading_bytes = 0;

		// options used for the piece picker. These flags will
		// be augmented with flags controlled by other settings
		// like sequential download etc. These are here to
		// let plugins control flags that should always be set
		picker_options_t m_picker_options{};

		// the number of invalid piece-requests
		// we have got from this peer. If the request
		// queue gets empty, and there have been
		// invalid requests, we can assume the
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(255)">../include/libtorrent/piece_picker.hpp:731</a></td><td>should this be allocated lazily?</td></tr><tr id="255" style="display: none;" colspan="3"><td colspan="3"><h2>should this be allocated lazily?</h2><h4>../include/libtorrent/piece_picker.hpp:731</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// download list it may live in now
		std::vector&lt;downloading_piece&gt;::iterator update_piece_state(
			std::vector&lt;downloading_piece&gt;::iterator dp);

	private:

#if TORRENT_USE_ASSERTS || TORRENT_USE_INVARIANT_CHECKS
		index_range&lt;download_queue_t&gt; categories() const
		{ return {{}, piece_picker::piece_pos::num_download_categories}; }
#endif

		// the following vectors are mutable because they sometimes may
		// be updated lazily, triggered by const functions

		// this maps indices to number of peers that has this piece and
		// index into the m_piece_info vectors.
		// piece_pos::we_have_index means that we have the piece, so it
		// doesn't exist in the piece_info buckets
		// pieces with the filtered flag set doesn't have entries in
		// the m_piece_info buckets either
<div style="background: #ffff00" width="100%">		mutable aux::vector&lt;piece_pos, piece_index_t&gt; m_piece_map;
</div>
		// this indicates whether a block has been marked as a pad
		// block or not. It's indexed by block index, i.e. piece_index
		// * blocks_per_piece + block. These blocks should not be
		// picked and are considered to be had
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(256)">../include/libtorrent/piece_picker.hpp:738</a></td><td>this could be a much more efficient data structure</td></tr><tr id="256" style="display: none;" colspan="3"><td colspan="3"><h2>this could be a much more efficient data structure</h2><h4>../include/libtorrent/piece_picker.hpp:738</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#if TORRENT_USE_ASSERTS || TORRENT_USE_INVARIANT_CHECKS
		index_range&lt;download_queue_t&gt; categories() const
		{ return {{}, piece_picker::piece_pos::num_download_categories}; }
#endif

		// the following vectors are mutable because they sometimes may
		// be updated lazily, triggered by const functions

		// this maps indices to number of peers that has this piece and
		// index into the m_piece_info vectors.
		// piece_pos::we_have_index means that we have the piece, so it
		// doesn't exist in the piece_info buckets
		// pieces with the filtered flag set doesn't have entries in
		// the m_piece_info buckets either
		mutable aux::vector&lt;piece_pos, piece_index_t&gt; m_piece_map;

		// this indicates whether a block has been marked as a pad
		// block or not. It's indexed by block index, i.e. piece_index
		// * blocks_per_piece + block. These blocks should not be
		// picked and are considered to be had
<div style="background: #ffff00" width="100%">		bitfield m_pad_blocks;
</div>
		// tracks the number of blocks in a specific piece that are pad blocks
		std::unordered_map&lt;piece_index_t, int&gt; m_pads_in_piece;

		// the number of bits set in the m_pad_blocks bitfield, i.e.
		// the number of blocks marked as pads
		int m_num_pad_blocks = 0;

		// the number of pad blocks that we already have
		int m_have_pad_blocks = 0;

		// the number of pad blocks part of filtered pieces we don't have
		int m_filtered_pad_blocks = 0;

		// the number of pad blocks we have that are also filtered
		int m_have_filtered_pad_blocks = 0;

		// the number of seeds. These are not added to
		// the availability counters of the pieces
		int m_seeds = 0;

		// the number of pieces that have passed the hash check
		int m_num_passed = 0;

		// this vector contains all piece indices that are pickable
		// sorted by priority. Pieces are in random random order
		// among pieces with the same priority
		mutable aux::vector&lt;piece_index_t, prio_index_t&gt; m_pieces;

		// these are indices to the priority boundaries inside
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(257)">../include/libtorrent/piece_picker.hpp:804</a></td><td>it would be more intuitive to account "wanted" pieces instead of filtered</td></tr><tr id="257" style="display: none;" colspan="3"><td colspan="3"><h2>it would be more intuitive to account "wanted" pieces
instead of filtered</h2><h4>../include/libtorrent/piece_picker.hpp:804</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			, download_queue_t&gt; m_downloads;

		// this holds the information of the blocks in partially downloaded
		// pieces. the downloading_piece::info index point into this vector for
		// its storage
		aux::vector&lt;block_info&gt; m_block_info;

		// these are block ranges in m_block_info that are free. The numbers
		// in here, when multiplied by m_blocks_per_piece is the index to the
		// first block in the range that's free to use by a new downloading_piece.
		// this is a free-list.
		std::vector&lt;std::uint16_t&gt; m_free_block_infos;

		std::uint16_t m_blocks_per_piece = 0;
		std::uint16_t m_blocks_in_last_piece = 0;

		// the number of filtered pieces that we don't already
		// have. total_number_of_pieces - number_of_pieces_we_have
		// - num_filtered is supposed to the number of pieces
		// we still want to download
<div style="background: #ffff00" width="100%">		int m_num_filtered = 0;
</div>
		// the number of pieces we have that also are filtered
		int m_num_have_filtered = 0;

		// we have all pieces in the range [0, m_cursor)
		// m_cursor is the first piece we don't have
		piece_index_t m_cursor{0};

		// we have all pieces in the range [m_reverse_cursor, end)
		// m_reverse_cursor is the first piece where we also have
		// all the subsequent pieces
		piece_index_t m_reverse_cursor{0};

		// the number of pieces we have (i.e. passed + flushed).
		// This includes pieces that we have filtered but still have
		int m_num_have = 0;

		// if this is set to true, it means update_pieces()
		// has to be called before accessing m_pieces.
		mutable bool m_dirty = false;
	public:

		enum { max_pieces = (std::numeric_limits&lt;int&gt;::max)() - 1 };

	};
}

#endif // TORRENT_PIECE_PICKER_HPP_INCLUDED
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(258)">../include/libtorrent/upnp.hpp:145</a></td><td>support using the windows API for UPnP operations as well</td></tr><tr id="258" style="display: none;" colspan="3"><td colspan="3"><h2>support using the windows API for UPnP operations as well</h2><h4>../include/libtorrent/upnp.hpp:145</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">{
	bool in_error_code = false;
	bool exit = false;
	int error_code = -1;
};

struct ip_address_parse_state: error_code_parse_state
{
	bool in_ip_address = false;
	std::string ip_address;
};

TORRENT_EXTRA_EXPORT void find_control_url(int type, string_view, parse_state&amp; state);

TORRENT_EXTRA_EXPORT void find_error_code(int type, string_view string
	, error_code_parse_state&amp; state);

TORRENT_EXTRA_EXPORT void find_ip_address(int type, string_view string
	, ip_address_parse_state&amp; state);

<div style="background: #ffff00" width="100%">struct TORRENT_EXTRA_EXPORT upnp final
</div>	: std::enable_shared_from_this&lt;upnp&gt;
	, single_threaded
{
	upnp(io_service&amp; ios
		, std::string const&amp; user_agent
		, aux::portmap_callback&amp; cb
		, bool ignore_nonrouters);
	~upnp();

	void set_user_agent(std::string const&amp; v) { m_user_agent = v; }

	void start();

	// Attempts to add a port mapping for the specified protocol. Valid protocols are
	// ``upnp::tcp`` and ``upnp::udp`` for the UPnP class and ``natpmp::tcp`` and
	// ``natpmp::udp`` for the NAT-PMP class.
	//
	// ``external_port`` is the port on the external address that will be mapped. This
	// is a hint, you are not guaranteed that this port will be available, and it may
	// end up being something else. In the portmap_alert_ notification, the actual
	// external port is reported.
	//
	// ``local_port`` is the port in the local machine that the mapping should forward
	// to.
	//
	// The return value is an index that identifies this port mapping. This is used
	// to refer to mappings that fails or succeeds in the portmap_error_alert_ and
	// portmap_alert_ respectively. If The mapping fails immediately, the return value
	// is -1, which means failure. There will not be any error alert notification for
	// mappings that fail with a -1 return value.
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(259)">../include/libtorrent/block_cache.hpp:223</a></td><td>make this 32 bits and to count seconds since the block cache was created</td></tr><tr id="259" style="display: none;" colspan="3"><td colspan="3"><h2>make this 32 bits and to count seconds since the block cache was created</h2><h4>../include/libtorrent/block_cache.hpp:223</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		tailqueue&lt;disk_io_job&gt; read_jobs;

		piece_index_t get_piece() const { return piece; }
		void* get_storage() const { return storage.get(); }

		bool operator==(cached_piece_entry const&amp; rhs) const
		{ return piece == rhs.piece &amp;&amp; storage.get() == rhs.storage.get(); }

		// if this is set, we'll be calculating the hash
		// for this piece. This member stores the interim
		// state while we're calculating the hash.
		std::unique_ptr&lt;partial_hash&gt; hash;

		// the pointers to the block data. If this is a ghost
		// cache entry, there won't be any data here
		aux::unique_ptr&lt;cached_block_entry[]&gt; blocks;

		// the last time a block was written to this piece
		// plus the minimum amount of time the block is guaranteed
		// to stay in the cache
<div style="background: #ffff00" width="100%">		time_point expire = min_time();
</div>
		piece_index_t piece{0};

		// the number of dirty blocks in this piece
		std::uint64_t num_dirty:14;

		// the number of blocks in the cache for this piece
		std::uint64_t num_blocks:14;

		// the total number of blocks in this piece (and the number
		// of elements in the blocks array)
		std::uint64_t blocks_in_piece:14;

		// ---- 64 bit boundary ----

		// while we have an outstanding async hash operation
		// working on this piece, 'hashing' is set to 1
		// When the operation returns, this is set to 0.
		std::uint16_t hashing:1;

		// if we've completed at least one hash job on this
		// piece, and returned it. This is set to one
		std::uint16_t hashing_done:1;

		// if this is true, whenever refcount hits 0,
		// this piece should be deleted from the cache
		// (not just demoted)
		std::uint16_t marked_for_deletion:1;

		// this is set to true once we flush blocks past
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(260)">../include/libtorrent/sha1_hash.hpp:58</a></td><td>find a better place for these functions</td></tr><tr id="260" style="display: none;" colspan="3"><td colspan="3"><h2>find a better place for these functions</h2><h4>../include/libtorrent/sha1_hash.hpp:58</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;array&gt;

#include "libtorrent/aux_/disable_warnings_push.hpp"
#include &lt;boost/range/combine.hpp&gt;
#include "libtorrent/aux_/disable_warnings_pop.hpp"

#include "libtorrent/config.hpp"
#include "libtorrent/assert.hpp"
#include "libtorrent/aux_/byteswap.hpp"
#include "libtorrent/aux_/ffs.hpp"
#include "libtorrent/span.hpp"

#if TORRENT_USE_IOSTREAM
#include &lt;iosfwd&gt;
#endif // TORRENT_USE_IOSTREAM

namespace libtorrent {

<div style="background: #ffff00" width="100%">namespace aux {
</div>
		TORRENT_EXTRA_EXPORT void bits_shift_left(span&lt;std::uint32_t&gt; number, int n);
		TORRENT_EXTRA_EXPORT void bits_shift_right(span&lt;std::uint32_t&gt; number, int n);
	}

	// This type holds an N digest or any other kind of N bits
	// sequence. It implements a number of convenience functions, such
	// as bit operations, comparison operators etc.
	//
	// This data structure is 32 bits aligned, like it's the case for
	// each SHA-N specification.
	template &lt;std::ptrdiff_t N&gt;
	class digest32
	{
		static_assert(N % 32 == 0, "N must be a multiple of 32");
		static constexpr std::ptrdiff_t number_size = N / 32;
		constexpr static int bits_in_byte = 8;
	public:

		using difference_type = std::ptrdiff_t;
		using index_type = std::ptrdiff_t;

		// the size of the hash in bytes
		static constexpr difference_type size() noexcept { return N / bits_in_byte; }

		// constructs an all-zero digest
		digest32() noexcept { clear(); }

		digest32(digest32 const&amp;) noexcept = default;
		digest32&amp; operator=(digest32 const&amp;) noexcept = default;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(261)">../include/libtorrent/settings_pack.hpp:1165</a></td><td>deprecate this ``max_rejects`` is the number of piece requests we will reject in a row while a peer is choked before the peer is considered abusive and is disconnected.</td></tr><tr id="261" style="display: none;" colspan="3"><td colspan="3"><h2>deprecate this
``max_rejects`` is the number of piece requests we will reject in a
row while a peer is choked before the peer is considered abusive
and is disconnected.</h2><h4>../include/libtorrent/settings_pack.hpp:1165</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
			// this is the minimum allowed announce interval for a tracker. This
			// is specified in seconds and is used as a sanity check on what is
			// returned from a tracker. It mitigates hammering misconfigured
			// trackers.
			min_announce_interval,

			// this is the number of seconds a torrent is considered active after
			// it was started, regardless of upload and download speed. This is so
			// that newly started torrents are not considered inactive until they
			// have a fair chance to start downloading.
			auto_manage_startup,

			// ``seeding_piece_quota`` is the number of pieces to send to a peer,
			// when seeding, before rotating in another peer to the unchoke set.
			// It defaults to 3 pieces, which means that when seeding, any peer
			// we've sent more than this number of pieces to will be unchoked in
			// favour of a choked peer.
			seeding_piece_quota,

<div style="background: #ffff00" width="100%">			max_rejects,
</div>
			// specifies the buffer sizes set on peer sockets. 0 (which is the
			// default) means the OS default (i.e. don't change the buffer sizes).
			// The socket buffer sizes are changed using setsockopt() with
			// SOL_SOCKET/SO_RCVBUF and SO_SNDBUFFER.
			recv_socket_buffer_size,
			send_socket_buffer_size,

			// the max number of bytes a single peer connection's receive buffer is
			// allowed to grow to.
			max_peer_recv_buffer_size,

#if TORRENT_ABI_VERSION == 1
			// ``file_checks_delay_per_block`` is the number of milliseconds to
			// sleep in between disk read operations when checking torrents. This
			// defaults to 0, but can be set to higher numbers to slow down the
			// rate at which data is read from the disk while checking. This may
			// be useful for background tasks that doesn't matter if they take a
			// bit longer, as long as they leave disk I/O time for other
			// processes.
			file_checks_delay_per_block TORRENT_DEPRECATED_ENUM,
#else
			deprecated_file_checks_delay_per_block,
#endif

			// ``read_cache_line_size`` is the number of blocks to read into the
			// read cache when a read cache miss occurs. Setting this to 0 is
			// essentially the same thing as disabling read cache. The number of
			// blocks read into the read cache is always capped by the piece
			// boundary.
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(262)">../include/libtorrent/proxy_base.hpp:188</a></td><td>it would be nice to remember the bind port and bind once we know where the proxy is m_sock.bind(endpoint, ec);</td></tr><tr id="262" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to remember the bind port and bind once we know where the proxy is
m_sock.bind(endpoint, ec);</h2><h4>../include/libtorrent/proxy_base.hpp:188</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	void bind(endpoint_type const&amp; /* endpoint */)
	{
//		m_sock.bind(endpoint);
	}
#endif

	error_code cancel(error_code&amp; ec)
	{
		return m_sock.cancel(ec);
	}

	void bind(endpoint_type const&amp; /* endpoint */, error_code&amp; /* ec */)
	{
		// the reason why we ignore binds here is because we don't
		// (necessarily) yet know what address family the proxy
		// will resolve to, and binding to the wrong one would
		// break our connection attempt later. The caller here
		// doesn't necessarily know that we're proxying, so this
		// bind address is based on the final endpoint, not the
		// proxy.
<div style="background: #ffff00" width="100%">	}
</div>
#ifndef BOOST_NO_EXCEPTIONS
	void open(protocol_type const&amp;)
	{
//		m_sock.open(p);
	}
#endif

	void open(protocol_type const&amp;, error_code&amp;)
	{
		// we need to ignore this for the same reason as stated
		// for ignoring bind()
//		m_sock.open(p, ec);
	}

#ifndef BOOST_NO_EXCEPTIONS
	void close()
	{
		m_remote_endpoint = endpoint_type();
		m_sock.close();
		m_resolver.cancel();
	}
#endif

	void close(error_code&amp; ec)
	{
		m_remote_endpoint = endpoint_type();
		m_sock.close(ec);
		m_resolver.cancel();
	}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(263)">../include/libtorrent/peer_connection_interface.hpp:50</a></td><td>make this interface smaller!</td></tr><tr id="263" style="display: none;" colspan="3"><td colspan="3"><h2>make this interface smaller!</h2><h4>../include/libtorrent/peer_connection_interface.hpp:50</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
*/

#ifndef TORRENT_PEER_CONNECTION_INTERFACE_HPP
#define TORRENT_PEER_CONNECTION_INTERFACE_HPP

#include "libtorrent/fwd.hpp"
#include "libtorrent/socket.hpp"
#include "libtorrent/error_code.hpp"
#include "libtorrent/alert_types.hpp"
#include "libtorrent/operations.hpp" // for operation_t enum
#include "libtorrent/units.hpp"

namespace libtorrent {

	struct torrent_peer;
	class stat;

	using disconnect_severity_t = aux::strong_typedef&lt;std::uint8_t, struct disconnect_severity_tag&gt;;

<div style="background: #ffff00" width="100%">	struct TORRENT_EXTRA_EXPORT peer_connection_interface
</div>	{
		static constexpr disconnect_severity_t normal{0};
		static constexpr disconnect_severity_t failure{1};
		static constexpr disconnect_severity_t peer_error{2};

		virtual tcp::endpoint const&amp; remote() const = 0;
		virtual tcp::endpoint local_endpoint() const = 0;
		virtual void disconnect(error_code const&amp; ec
			, operation_t op, disconnect_severity_t = peer_connection_interface::normal) = 0;
		virtual peer_id const&amp; pid() const = 0;
		virtual peer_id our_pid() const = 0;
		virtual void set_holepunch_mode() = 0;
		virtual torrent_peer* peer_info_struct() const = 0;
		virtual void set_peer_info(torrent_peer* pi) = 0;
		virtual bool is_outgoing() const = 0;
		virtual void add_stat(std::int64_t downloaded, std::int64_t uploaded) = 0;
		virtual bool fast_reconnect() const = 0;
		virtual bool is_choked() const = 0;
		virtual bool failed() const = 0;
		virtual stat const&amp; statistics() const = 0;
		virtual void get_peer_info(peer_info&amp; p) const = 0;
#ifndef TORRENT_DISABLE_LOGGING
		virtual bool should_log(peer_log_alert::direction_t direction) const = 0;
		virtual void peer_log(peer_log_alert::direction_t direction
			, char const* event, char const* fmt = "", ...) const noexcept TORRENT_FORMAT(4,5) = 0;
#endif
	protected:
		~peer_connection_interface() {}
	};
}
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(264)">../include/libtorrent/announce_entry.hpp:86</a></td><td>include the number of peers received from this tracker, at last announce</td></tr><tr id="264" style="display: none;" colspan="3"><td colspan="3"><h2>include the number of peers received from this tracker, at last
announce</h2><h4>../include/libtorrent/announce_entry.hpp:86</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		std::string message;

		// if this tracker failed the last time it was contacted
		// this error code specifies what error occurred
		error_code last_error;

		// the local endpoint of the listen interface associated with this endpoint
		tcp::endpoint local_endpoint;

		// the time of next tracker announce
		time_point32 next_announce = (time_point32::min)();

		// no announces before this time
		time_point32 min_announce = (time_point32::min)();

	private:
		// internal
		aux::listen_socket_handle socket;

	public:
<div style="background: #ffff00" width="100%">
</div>		// these are either -1 or the scrape information this tracker last
		// responded with. *incomplete* is the current number of downloaders in
		// the swarm, *complete* is the current number of seeds in the swarm and
		// *downloaded* is the cumulative number of completed downloads of this
		// torrent, since the beginning of time (from this tracker's point of
		// view).

		// if this tracker has returned scrape data, these fields are filled in
		// with valid numbers. Otherwise they are set to -1. the number of
		// current downloaders
		int scrape_incomplete = -1;
		int scrape_complete = -1;

		int scrape_downloaded = -1;

		// the number of times in a row we have failed to announce to this
		// tracker.
		std::uint8_t fails : 7;

		// true while we're waiting for a response from the tracker.
		bool updating : 1;

		// set to true when we get a valid response from an announce
		// with event=started. If it is set, we won't send start in the subsequent
		// announces.
		bool start_sent : 1;

		// set to true when we send a event=completed.
		bool complete_sent : 1;

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(265)">../include/libtorrent/broadcast_socket.hpp:57</a></td><td>refactor these out too</td></tr><tr id="265" style="display: none;" colspan="3"><td colspan="3"><h2>refactor these out too</h2><h4>../include/libtorrent/broadcast_socket.hpp:57</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#include "libtorrent/config.hpp"
#include "libtorrent/io_service_fwd.hpp"
#include "libtorrent/socket.hpp"
#include "libtorrent/address.hpp"
#include "libtorrent/error_code.hpp"
#include "libtorrent/string_view.hpp"
#include "libtorrent/span.hpp"

#include &lt;memory&gt;
#include &lt;list&gt;
#include &lt;array&gt;

namespace libtorrent {

	TORRENT_EXTRA_EXPORT bool is_local(address const&amp; a);
	TORRENT_EXTRA_EXPORT bool is_loopback(address const&amp; addr);
	TORRENT_EXTRA_EXPORT bool is_any(address const&amp; addr);
	TORRENT_EXTRA_EXPORT bool is_teredo(address const&amp; addr);
	TORRENT_EXTRA_EXPORT bool is_ip_address(std::string const&amp; host);

<div style="background: #ffff00" width="100%">	template &lt;typename Endpoint&gt;
</div>	bool is_v4(Endpoint const&amp; ep)
	{
		return ep.protocol() == Endpoint::protocol_type::v4();
	}
	template &lt;typename Endpoint&gt;
	bool is_v6(Endpoint const&amp; ep)
	{
		return ep.protocol() == Endpoint::protocol_type::v6();
	}

	// determines if the operating system supports IPv6
	TORRENT_EXTRA_EXPORT bool supports_ipv6();
	address ensure_v6(address const&amp; a);

	using receive_handler_t = std::function&lt;void(udp::endpoint const&amp; from
		, span&lt;char const&gt; buffer)&gt;;

	class TORRENT_EXTRA_EXPORT broadcast_socket
	{
	public:
		explicit broadcast_socket(udp::endpoint const&amp; multicast_endpoint);
		~broadcast_socket() { close(); }

		void open(receive_handler_t handler, io_service&amp; ios
			, error_code&amp; ec, bool loopback = true);

		enum flags_t { flag_broadcast = 1 };
		void send(char const* buffer, int size, error_code&amp; ec, int flags = 0);

		void close();
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(266)">../include/libtorrent/identify_client.hpp:47</a></td><td>hide this declaration when deprecated functions are disabled, and remove its internal use</td></tr><tr id="266" style="display: none;" colspan="3"><td colspan="3"><h2>hide this declaration when deprecated functions are disabled, and
remove its internal use</h2><h4>../include/libtorrent/identify_client.hpp:47</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

*/

#ifndef TORRENT_IDENTIFY_CLIENT_HPP_INCLUDED
#define TORRENT_IDENTIFY_CLIENT_HPP_INCLUDED

#include "libtorrent/config.hpp"

#if TORRENT_ABI_VERSION == 1
#include "libtorrent/aux_/disable_warnings_push.hpp"
#include &lt;boost/optional.hpp&gt;
#include "libtorrent/aux_/disable_warnings_pop.hpp"
#endif

#include "libtorrent/peer_id.hpp"
#include "libtorrent/fingerprint.hpp"

<div style="background: #ffff00" width="100%">namespace libtorrent {
</div>
namespace aux {

	TORRENT_EXTRA_EXPORT
	std::string identify_client_impl(const peer_id&amp; p);

}

	// these functions don't really need to be public. This mechanism of
	// advertising client software and version is also out-dated.

	// This function can can be used to extract a string describing a client
	// version from its peer-id. It will recognize most clients that have this
	// kind of identification in the peer-id.
	TORRENT_DEPRECATED_EXPORT
	std::string identify_client(const peer_id&amp; p);

#if TORRENT_ABI_VERSION == 1

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#endif
#ifdef _MSC_VER
#pragma warning(push, 1)
#pragma warning(disable: 4996)
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(267)">../include/libtorrent/utp_stream.hpp:426</a></td><td>implement blocking write. Low priority since it's not used (yet)</td></tr><tr id="267" style="display: none;" colspan="3"><td colspan="3"><h2>implement blocking write. Low priority since it's not used (yet)</h2><h4>../include/libtorrent/utp_stream.hpp:426</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			, end(buffers.end()); i != end; ++i)
#endif
		{
			using boost::asio::buffer_cast;
			using boost::asio::buffer_size;
			add_read_buffer(buffer_cast&lt;void*&gt;(*i), buffer_size(*i));
#if TORRENT_USE_ASSERTS
			buf_size += buffer_size(*i);
#endif
		}
		std::size_t ret = read_some(true);
		TORRENT_ASSERT(ret &lt;= buf_size);
		TORRENT_ASSERT(ret &gt; 0);
		return ret;
	}

	template &lt;class Const_Buffers&gt;
	std::size_t write_some(Const_Buffers const&amp; /* buffers */, error_code&amp; /* ec */)
	{
		TORRENT_ASSERT(false &amp;&amp; "not implemented!");
<div style="background: #ffff00" width="100%">		return 0;
</div>	}

#ifndef BOOST_NO_EXCEPTIONS
	template &lt;class Mutable_Buffers&gt;
	std::size_t read_some(Mutable_Buffers const&amp; buffers)
	{
		error_code ec;
		std::size_t ret = read_some(buffers, ec);
		if (ec)
			boost::throw_exception(boost::system::system_error(ec));
		return ret;
	}

	template &lt;class Const_Buffers&gt;
	std::size_t write_some(Const_Buffers const&amp; buffers)
	{
		error_code ec;
		std::size_t ret = write_some(buffers, ec);
		if (ec)
			boost::throw_exception(boost::system::system_error(ec));
		return ret;
	}
#endif

	template &lt;class Const_Buffers, class Handler&gt;
	void async_write_some(Const_Buffers const&amp; buffers, Handler const&amp; handler)
	{
		if (m_impl == nullptr)
		{
			m_io_service.post(std::bind&lt;void&gt;(handler
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(268)">../include/libtorrent/torrent_info.hpp:117</a></td><td>there may be some opportunities to optimize the size if torrent_info. specifically to turn some std::string and std::vector into pointers</td></tr><tr id="268" style="display: none;" colspan="3"><td colspan="3"><h2>there may be some opportunities to optimize the size if torrent_info.
specifically to turn some std::string and std::vector into pointers</h2><h4>../include/libtorrent/torrent_info.hpp:117</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		std::string url;

		// Optional authentication. If this is set, it's passed
		// in as HTTP basic auth to the web seed. The format is:
		// username:password.
		std::string auth;

		// Any extra HTTP headers that need to be passed to the web seed
		headers_t extra_headers;

		// The type of web seed (see type_t)
		std::uint8_t type;
	};

	// hidden
	class from_span_t {};

	// used to disambiguate a bencoded buffer and a filename
	extern TORRENT_EXPORT from_span_t from_span;

<div style="background: #ffff00" width="100%">	class TORRENT_EXPORT torrent_info
</div>	{
	public:

		// The constructor that takes an info-hash  will initialize the info-hash
		// to the given value, but leave all other fields empty. This is used
		// internally when downloading torrents without the metadata. The
		// metadata will be created by libtorrent as soon as it has been
		// downloaded from the swarm.
		//
		// The constructor that takes a bdecode_node will create a torrent_info
		// object from the information found in the given torrent_file. The
		// bdecode_node represents a tree node in an bencoded file. To load an
		// ordinary .torrent file into a bdecode_node, use bdecode().
		//
		// The version that takes a buffer pointer and a size will decode it as a
		// .torrent file and initialize the torrent_info object for you.
		//
		// The version that takes a filename will simply load the torrent file
		// and decode it inside the constructor, for convenience. This might not
		// be the most suitable for applications that want to be able to report
		// detailed errors on what might go wrong.
		//
		// There is an upper limit on the size of the torrent file that will be
		// loaded by the overload taking a filename. If it's important that even
		// very large torrent files are loaded, use one of the other overloads.
		//
		// The overloads that takes an ``error_code const&amp;`` never throws if an
		// error occur, they will simply set the error code to describe what went
		// wrong and not fully initialize the torrent_info object. The overloads
		// that do not take the extra error_code parameter will always throw if
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(269)">../include/libtorrent/torrent_info.hpp:619</a></td><td>change the type to std::shared_ptr in C++17</td></tr><tr id="269" style="display: none;" colspan="3"><td colspan="3"><h2>change the type to std::shared_ptr in C++17</h2><h4>../include/libtorrent/torrent_info.hpp:619</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		// these or strings of the "collections" key from the torrent file. The
		// pointers point directly into the info_section buffer and when copied,
		// these pointers must be corrected to point into the new buffer. The
		// int is the length of the string. Strings are not 0-terminated.
		std::vector&lt;std::pair&lt;char const*, int&gt;&gt; m_collections;

		// these are the collections from outside of the info-dict. These are
		// owning strings, since we only keep the info-section around, these
		// cannot be pointers into that buffer.
		std::vector&lt;std::string&gt; m_owned_collections;

		// if this is a merkle torrent, this is the merkle
		// tree. It has space for merkle_num_nodes(merkle_num_leafs(num_pieces))
		// hashes
		aux::vector&lt;sha1_hash&gt; m_merkle_tree;

		// this is a copy of the info section from the torrent.
		// it use maintained in this flat format in order to
		// make it available through the metadata extension
<div style="background: #ffff00" width="100%">		boost::shared_array&lt;char&gt; m_info_section;
</div>
		// this is a pointer into the m_info_section buffer
		// pointing to the first byte of the first SHA-1 hash
		char const* m_piece_hashes = nullptr;

		// if a comment is found in the torrent file
		// this will be set to that comment
		std::string m_comment;

		// an optional string naming the software used
		// to create the torrent file
		std::string m_created_by;

		// the info section parsed. points into m_info_section
		// parsed lazily
		mutable bdecode_node m_info_dict;

		// if a creation date is found in the torrent file
		// this will be set to that, otherwise it'll be
		// 1970, Jan 1
		std::time_t m_creation_date = 0;

		// the hash that identifies this torrent
		sha1_hash m_info_hash;

		// the number of bytes in m_info_section
		std::int32_t m_info_section_size = 0;

		// the index to the first leaf. This is where the hash for the
		// first piece is stored
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(270)">../include/libtorrent/torrent.hpp:238</a></td><td>make this a raw pointer. perhaps keep the shared_ptr around further down the object to maintain an owner</td></tr><tr id="270" style="display: none;" colspan="3"><td colspan="3"><h2>make this a raw pointer. perhaps keep the shared_ptr
around further down the object to maintain an owner</h2><h4>../include/libtorrent/torrent.hpp:238</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		web_seed_t&amp; operator=(web_seed_t const&amp;) = default;
		web_seed_t(web_seed_t const&amp;) = default;
#endif
	};

	struct TORRENT_EXTRA_EXPORT torrent_hot_members
	{
		torrent_hot_members(aux::session_interface&amp; ses
			, add_torrent_params const&amp; p, bool session_paused);

	protected:
		// the piece picker. This is allocated lazily. When we don't
		// have anything in the torrent (for instance, if it hasn't
		// been started yet) or if we have everything, there is no
		// picker. It's allocated on-demand the first time we need
		// it in torrent::need_picker(). In order to tell the
		// difference between having everything and nothing in
		// the case there is no piece picker, see m_have_all.
		std::unique_ptr&lt;piece_picker&gt; m_picker;

<div style="background: #ffff00" width="100%">		std::shared_ptr&lt;torrent_info&gt; m_torrent_file;
</div>
		// a back reference to the session
		// this torrent belongs to.
		aux::session_interface&amp; m_ses;

		// this vector is sorted at all times, by the pointer value.
		// use sorted_insert() and sorted_find() on it. The GNU STL
		// implementation on Darwin uses significantly less memory to
		// represent a vector than a set, and this set is typically
		// relatively small, and it's cheap to copy pointers.
		aux::vector&lt;peer_connection*&gt; m_connections;

		// the scrape data from the tracker response, this
		// is optional and may be 0xffffff
		std::uint32_t m_complete:24;

		// set to true when this torrent may not download anything
		bool m_upload_mode:1;

		// this is set to false as long as the connections
		// of this torrent hasn't been initialized. If we
		// have metadata from the start, connections are
		// initialized immediately, if we didn't have metadata,
		// they are initialized right after files_checked().
		// valid_resume_data() will return false as long as
		// the connections aren't initialized, to avoid
		// them from altering the piece-picker before it
		// has been initialized with files_checked().
		bool m_connections_initialized:1;

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(271)">../include/libtorrent/torrent.hpp:412</a></td><td>make graceful pause also finish all sending blocks before disconnecting</td></tr><tr id="271" style="display: none;" colspan="3"><td colspan="3"><h2>make graceful pause also finish all sending blocks
before disconnecting</h2><h4>../include/libtorrent/torrent.hpp:412</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// checks to see if this peer id is used in one of our own outgoing
		// connections.
		bool is_self_connection(peer_id const&amp; pid) const;

		void on_resume_data_checked(status_t status, storage_error const&amp; error);
		void on_force_recheck(status_t status, storage_error const&amp; error);
		void on_piece_hashed(piece_index_t piece, sha1_hash const&amp; piece_hash
			, storage_error const&amp; error);
		void files_checked();
		void start_checking();

		void start_announcing();
		void stop_announcing();

		void send_share_mode();
		void send_upload_only();

		void set_share_mode(bool s);
		bool share_mode() const { return m_share_mode; }

<div style="background: #ffff00" width="100%">		bool graceful_pause() const { return m_graceful_pause_mode; }
</div>
		torrent_flags_t flags() const;
		void set_flags(torrent_flags_t flags, torrent_flags_t mask);

		void set_upload_mode(bool b);
		bool upload_mode() const { return m_upload_mode || m_graceful_pause_mode; }
		bool is_upload_only() const { return is_finished() || upload_mode(); }

		int seed_rank(aux::session_settings const&amp; s) const;

		void add_piece(piece_index_t piece, char const* data, add_piece_flags_t flags);
		void on_disk_write_complete(storage_error const&amp; error
			, peer_request const&amp; p);

		void set_progress_ppm(int p) { m_progress_ppm = std::uint32_t(p); }
		struct read_piece_struct
		{
			boost::shared_array&lt;char&gt; piece_data;
			int blocks_left;
			bool fail;
			error_code error;
		};
		void read_piece(piece_index_t piece);
		void on_disk_read_complete(disk_buffer_holder block, disk_job_flags_t, storage_error const&amp; se
			, peer_request const&amp; r, std::shared_ptr&lt;read_piece_struct&gt; rp);

		storage_mode_t storage_mode() const;

		// this will flag the torrent as aborted. The main
		// loop in session_impl will check for this state
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(272)">../include/libtorrent/torrent.hpp:1268</a></td><td>this wastes 5 bits per file</td></tr><tr id="272" style="display: none;" colspan="3"><td colspan="3"><h2>this wastes 5 bits per file</h2><h4>../include/libtorrent/torrent.hpp:1268</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#ifndef TORRENT_DISABLE_EXTENSIONS
		std::list&lt;std::shared_ptr&lt;torrent_plugin&gt;&gt; m_extensions;
#endif

		// used for tracker announces
		deadline_timer m_tracker_timer;

		// used to detect when we are active or inactive for long enough
		// to trigger the auto-manage logic
		deadline_timer m_inactivity_timer;

		// this is the upload and download statistics for the whole torrent.
		// it's updated from all its peers once every second.
		libtorrent::stat m_stat;

		// -----------------------------

		// this vector is allocated lazily. If no file priorities are
		// ever changed, this remains empty. Any unallocated slot
		// implicitly means the file has priority 4.
<div style="background: #ffff00" width="100%">		aux::vector&lt;download_priority_t, file_index_t&gt; m_file_priority;
</div>
		// this object is used to track download progress of individual files
		aux::file_progress m_file_progress;

		// a queue of the most recent low-availability pieces we accessed on disk.
		// These are good candidates for suggesting other peers to request from
		// us.
		aux::suggest_piece m_suggest_pieces;

		aux::vector&lt;announce_entry&gt; m_trackers;

		// this list is sorted by time_critical_piece::deadline
		std::vector&lt;time_critical_piece&gt; m_time_critical_pieces;

		std::string m_trackerid;
#if TORRENT_ABI_VERSION == 1
		// deprecated in 1.1
		std::string m_username;
		std::string m_password;
#endif

		std::string m_save_path;

#if TORRENT_ABI_VERSION == 1
		// deprecated in 1.2

		// if we don't have the metadata, this is a url to
		// the torrent file
		std::string m_url;

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(273)">../include/libtorrent/kademlia/msg.hpp:85</a></td><td>move this to its own .hpp/.cpp pair?</td></tr><tr id="273" style="display: none;" colspan="3"><td colspan="3"><h2>move this to its own .hpp/.cpp pair?</h2><h4>../include/libtorrent/kademlia/msg.hpp:85</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">	int flags;

	enum {
		// this argument is optional, parsing will not
		// fail if it's not present
		optional = 1,
		// for dictionaries, the following entries refer
		// to child nodes to this node, up until and including
		// the next item that has the last_child flag set.
		// these flags are nestable
		parse_children = 2,
		// this is the last item in a child dictionary
		last_child = 4,
		// the size argument refers to that the size
		// has to be divisible by the number, instead
		// of having that exact size
		size_divisible = 8
	};
};

<div style="background: #ffff00" width="100%">TORRENT_EXTRA_EXPORT bool verify_message_impl(bdecode_node const&amp; msg, span&lt;key_desc_t const&gt; desc
</div>	, span&lt;bdecode_node&gt; ret, span&lt;char&gt; error);

// verifies that a message has all the required
// entries and returns them in ret
template &lt;int Size&gt;
bool verify_message(bdecode_node const&amp; msg, key_desc_t const (&amp;desc)[Size]
	, bdecode_node (&amp;ret)[Size], span&lt;char&gt; error)
{
	return verify_message_impl(msg, desc, ret, error);
}

} }

#endif
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(274)">../include/libtorrent/kademlia/item.hpp:58</a></td><td>since this is a public function, it should probably be moved out of this header and into one with other public functions.</td></tr><tr id="274" style="display: none;" colspan="3"><td colspan="3"><h2>since this is a public function, it should probably be moved
out of this header and into one with other public functions.</h2><h4>../include/libtorrent/kademlia/item.hpp:58</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">#include &lt;libtorrent/entry.hpp&gt;
#include &lt;libtorrent/span.hpp&gt;
#include &lt;libtorrent/kademlia/types.hpp&gt;

namespace libtorrent { namespace dht {

// calculate the target hash for an immutable item.
TORRENT_EXTRA_EXPORT sha1_hash item_target_id(span&lt;char const&gt; v);

// calculate the target hash for a mutable item.
TORRENT_EXTRA_EXPORT sha1_hash item_target_id(span&lt;char const&gt; salt
	, public_key const&amp; pk);

TORRENT_EXTRA_EXPORT bool verify_mutable_item(
	span&lt;char const&gt; v
	, span&lt;char const&gt; salt
	, sequence_number seq
	, public_key const&amp; pk
	, signature const&amp; sig);

<div style="background: #ffff00" width="100%">
</div>// given a byte range ``v`` and an optional byte range ``salt``, a
// sequence number, public key ``pk`` (must be 32 bytes) and a secret key
// ``sk`` (must be 64 bytes), this function produces a signature which
// is written into a 64 byte buffer pointed to by ``sig``. The caller
// is responsible for allocating the destination buffer that's passed in
// as the ``sig`` argument. Typically it would be allocated on the stack.
TORRENT_EXPORT signature sign_mutable_item(
	span&lt;char const&gt; v
	, span&lt;char const&gt; salt
	, sequence_number seq
	, public_key const&amp; pk
	, secret_key const&amp; sk);

class TORRENT_EXTRA_EXPORT item
{
public:
	item() {}
	item(public_key const&amp; pk, span&lt;char const&gt; salt);
	explicit item(entry v);
	item(entry v
		, span&lt;char const&gt; salt
		, sequence_number seq
		, public_key const&amp; pk
		, secret_key const&amp; sk);
	explicit item(bdecode_node const&amp; v);

	void assign(entry v);
	void assign(entry v, span&lt;char const&gt; salt
		, sequence_number seq
		, public_key const&amp; pk
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(275)">../include/libtorrent/aux_/session_impl.hpp:196</a></td><td>make these direct members and generate shared_ptrs to them which alias the listen_socket_t shared_ptr</td></tr><tr id="275" style="display: none;" colspan="3"><td colspan="3"><h2>make these direct members and generate shared_ptrs to them
which alias the listen_socket_t shared_ptr</h2><h4>../include/libtorrent/aux_/session_impl.hpp:196</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">		// on the NAT box itself. This is the port that has
		// to be published to peers, since this is the port
		// the client is reachable through.
		int tcp_external_port = 0;
		int udp_external_port = 0;

		// 0 is natpmp 1 is upnp
		port_mapping_t tcp_port_mapping[2];
		port_mapping_t udp_port_mapping[2];

		// indicates whether this is an SSL listen socket or not
		transport ssl = transport::plaintext;

		duplex incoming = duplex::accept_incoming;

		// the actual sockets (TCP listen socket and UDP socket)
		// An entry does not necessarily have a UDP or TCP socket. One of these
		// pointers may be nullptr!
		// These must be shared_ptr to avoid a dangling reference if an
		// incoming packet is in the event queue when the socket is erased
<div style="background: #ffff00" width="100%">		std::shared_ptr&lt;tcp::acceptor&gt; sock;
</div>		std::shared_ptr&lt;aux::session_udp_socket&gt; udp_sock;

		// since udp packets are expected to be dispatched frequently, this saves
		// time on handler allocation every time we read again.
		aux::handler_storage&lt;TORRENT_READ_HANDLER_MAX_SIZE&gt; udp_handler_storage;

		std::shared_ptr&lt;natpmp&gt; natpmp_mapper;

		// the key is an id that is used to identify the
		// client with the tracker only.
		std::uint32_t tracker_key = 0;

		// set to true when we receive an incoming connection from this listen
		// socket
		bool incoming_connection = false;
	};

		struct TORRENT_EXTRA_EXPORT listen_endpoint_t
		{
			listen_endpoint_t(address const&amp; adr, int p, std::string dev, transport s
				, duplex d = duplex::accept_incoming)
				: addr(adr), port(p), device(std::move(dev)), ssl(s), incoming(d) {}

			bool operator==(listen_endpoint_t const&amp; o) const
			{
				return addr == o.addr &amp;&amp; port == o.port &amp;&amp; device == o.device &amp;&amp; ssl == o.ssl;
			}

			address addr;
			int port;
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(276)">../include/libtorrent/aux_/session_impl.hpp:986</a></td><td>replace this by a proper asio timer</td></tr><tr id="276" style="display: none;" colspan="3"><td colspan="3"><h2>replace this by a proper asio timer</h2><h4>../include/libtorrent/aux_/session_impl.hpp:986</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">			ssl::context* ssl_ctx() override { return &amp;m_ssl_ctx; }
			void on_incoming_utp_ssl(std::shared_ptr&lt;socket_type&gt; const&amp; s);
			void ssl_handshake(error_code const&amp; ec, std::shared_ptr&lt;socket_type&gt; s);
#endif

			// round-robin index into m_outgoing_interfaces
			mutable std::uint8_t m_interface_index = 0;

			std::shared_ptr&lt;listen_socket_t&gt; setup_listener(
				listen_endpoint_t const&amp; lep, error_code&amp; ec);

#ifndef TORRENT_DISABLE_DHT
			dht::dht_state m_dht_state;
#endif

			// this is initialized to the unchoke_interval
			// session_setting and decreased every second.
			// when it reaches zero, it is reset to the
			// unchoke_interval and the unchoke set is
			// recomputed.
<div style="background: #ffff00" width="100%">			int m_unchoke_time_scaler = 0;
</div>
			// this is used to decide when to recalculate which
			// torrents to keep queued and which to activate
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(277)">../include/libtorrent/aux_/session_impl.hpp:991</a></td><td>replace this by a proper asio timer</td></tr><tr id="277" style="display: none;" colspan="3"><td colspan="3"><h2>replace this by a proper asio timer</h2><h4>../include/libtorrent/aux_/session_impl.hpp:991</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
			// round-robin index into m_outgoing_interfaces
			mutable std::uint8_t m_interface_index = 0;

			std::shared_ptr&lt;listen_socket_t&gt; setup_listener(
				listen_endpoint_t const&amp; lep, error_code&amp; ec);

#ifndef TORRENT_DISABLE_DHT
			dht::dht_state m_dht_state;
#endif

			// this is initialized to the unchoke_interval
			// session_setting and decreased every second.
			// when it reaches zero, it is reset to the
			// unchoke_interval and the unchoke set is
			// recomputed.
			int m_unchoke_time_scaler = 0;

			// this is used to decide when to recalculate which
			// torrents to keep queued and which to activate
<div style="background: #ffff00" width="100%">			int m_auto_manage_time_scaler = 0;
</div>
			// works like unchoke_time_scaler but it
			// is only decreased when the unchoke set
			// is recomputed, and when it reaches zero,
			// the optimistic unchoke is moved to another peer.
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(278)">../include/libtorrent/aux_/session_impl.hpp:998</a></td><td>replace this by a proper asio timer</td></tr><tr id="278" style="display: none;" colspan="3"><td colspan="3"><h2>replace this by a proper asio timer</h2><h4>../include/libtorrent/aux_/session_impl.hpp:998</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
#ifndef TORRENT_DISABLE_DHT
			dht::dht_state m_dht_state;
#endif

			// this is initialized to the unchoke_interval
			// session_setting and decreased every second.
			// when it reaches zero, it is reset to the
			// unchoke_interval and the unchoke set is
			// recomputed.
			int m_unchoke_time_scaler = 0;

			// this is used to decide when to recalculate which
			// torrents to keep queued and which to activate
			int m_auto_manage_time_scaler = 0;

			// works like unchoke_time_scaler but it
			// is only decreased when the unchoke set
			// is recomputed, and when it reaches zero,
			// the optimistic unchoke is moved to another peer.
<div style="background: #ffff00" width="100%">			int m_optimistic_unchoke_time_scaler = 0;
</div>
			// works like unchoke_time_scaler. Each time
			// it reaches 0, and all the connections are
			// used, the worst connection will be disconnected
			// from the torrent with the most peers
			int m_disconnect_time_scaler = 90;

			// when this scaler reaches zero, it will
			// scrape one of the auto managed, paused,
			// torrents.
			int m_auto_scrape_time_scaler = 180;

			// statistics gathered from all torrents.
			stat m_stat;

			// implements session_interface
			void sent_bytes(int bytes_payload, int bytes_protocol) override;
			void received_bytes(int bytes_payload, int bytes_protocol) override;
			void trancieve_ip_packet(int bytes, bool ipv6) override;
			void sent_syn(bool ipv6) override;
			void received_synack(bool ipv6) override;

			int m_peak_up_rate = 0;
			int m_peak_down_rate = 0;

			void on_tick(error_code const&amp; e);

			void try_connect_more_peers();
			void auto_manage_checking_torrents(std::vector&lt;torrent*&gt;&amp; list
				, int&amp; limit);
</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(279)">../include/libtorrent/aux_/session_interface.hpp:221</a></td><td>it would be nice to not have this be part of session_interface</td></tr><tr id="279" style="display: none;" colspan="3"><td colspan="3"><h2>it would be nice to not have this be part of session_interface</h2><h4>../include/libtorrent/aux_/session_interface.hpp:221</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
		virtual std::uint16_t listen_port() const = 0;
		virtual std::uint16_t ssl_listen_port() const = 0;

		virtual int listen_port(aux::transport ssl, address const&amp; local_addr) = 0;

		virtual void for_each_listen_socket(std::function&lt;void(aux::listen_socket_handle const&amp;)&gt; f) = 0;

		// ask for which interface and port to bind outgoing peer connections on
		virtual bool has_udp_outgoing_sockets() const = 0;
		virtual tcp::endpoint bind_outgoing_socket(socket_type&amp; s, address const&amp;
			remote_address, error_code&amp; ec) const = 0;
		virtual bool verify_bound_address(address const&amp; addr, bool utp
			, error_code&amp; ec) = 0;

#ifndef TORRENT_DISABLE_MUTABLE_TORRENTS
		virtual std::vector&lt;std::shared_ptr&lt;torrent&gt;&gt; find_collection(
			std::string const&amp; collection) const = 0;
#endif

<div style="background: #ffff00" width="100%">		virtual proxy_settings proxy() const = 0;
</div>
#if TORRENT_USE_I2P
		virtual proxy_settings i2p_proxy() const = 0;
		virtual char const* i2p_session() const = 0;
#endif

		virtual void prioritize_connections(std::weak_ptr&lt;torrent&gt; t) = 0;

		virtual void trigger_auto_manage() = 0;

		virtual void apply_settings_pack(std::shared_ptr&lt;settings_pack&gt; pack) = 0;
		virtual session_settings const&amp; settings() const = 0;

		// the tracker request object must be moved in
		virtual void queue_tracker_request(tracker_request&amp;&amp; req
			, std::weak_ptr&lt;request_callback&gt; c) = 0;
		void queue_tracker_request(tracker_request const&amp; req
			, std::weak_ptr&lt;request_callback&gt; c) = delete;

		// peer-classes
		virtual void set_peer_classes(peer_class_set* s, address const&amp; a, int st) = 0;
		virtual peer_class_pool const&amp; peer_classes() const = 0;
		virtual peer_class_pool&amp; peer_classes() = 0;
		virtual bool ignore_unchoke_slots_set(peer_class_set const&amp; set) const = 0;
		virtual int copy_pertinent_channels(peer_class_set const&amp; set
			, int channel, bandwidth_channel** dst, int m) = 0;
		virtual int use_quota_overhead(peer_class_set&amp; set, int amount_down, int amount_up) = 0;

		virtual bandwidth_manager* get_bandwidth_manager(int channel) = 0;

</pre></td></tr><tr style="background: #ccc"><td>relevance&nbsp;0</td><td><a href="javascript:expand(280)">../include/libtorrent/aux_/max_path.hpp:38</a></td><td>Make this count Unicode characters instead of bytes on windows</td></tr><tr id="280" style="display: none;" colspan="3"><td colspan="3"><h2>Make this count Unicode characters instead of bytes on windows</h2><h4>../include/libtorrent/aux_/max_path.hpp:38</h4><pre style="background: #f6f6f6; border: solid 1px #ddd;">
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

*/

#ifndef TORRENT_MAX_PATH_HPP_INCLUDED
#define TORRENT_MAX_PATH_HPP_INCLUDED

// on windows, NAME_MAX refers to Unicode characters
// on linux it refers to bytes (utf-8 encoded)
<div style="background: #ffff00" width="100%">
</div>// windows
#if defined FILENAME_MAX
#define TORRENT_MAX_PATH FILENAME_MAX

// beos
#elif defined B_PATH_NAME_LENGTH
#define TORRENT_MAX_PATH B_PATH_NAME_LENGTH

// solaris
#elif defined MAXPATH
#define TORRENT_MAX_PATH MAXPATH

// none of the above
#else
// this is the maximum number of characters in a
// path element / filename on windows and also on many filesystems commonly used
// on linux
#define TORRENT_MAX_PATH 255

#ifdef _MSC_VER
#pragma message ( "unknown platform, assuming the longest path is 255" )
#else
#warning "unknown platform, assuming the longest path is 255"
#endif

#endif // FILENAME_MAX

#endif // TORRENT_MAX_PATH_HPP_INCLUDED
</pre></td></tr></table></body></html>